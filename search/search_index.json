{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Embedded Sharepoint Documentation","text":"<p>Welcome to the Embedded Sharepoint! Embedded-Sharepoint contains the shared embedded files to build and develop for our custom STM32 PCBs.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<p>Follow the installation instructions for your specific platform, found here</p>"},{"location":"#command-usage","title":"Command Usage","text":"<p>The Makefile in the top level directory compiles all needed files for the STM32, it is not meant to be called directly, instead you must call it from a different Makefile</p>"},{"location":"#running-tests","title":"Running tests","text":"<p>In the test/ directory there is a Makefile meant for just running test files. Every test file should end with <code>_test</code>  To run a test do:</p> <pre><code>make TEST=[name of test file without _test_ and the .c extension] PROJECT_TARGET=[name of the STM32 you want to compile for]\n\n# For example:\nmake TEST=blinky PROJECT_TARGET=stm32f413rht\n# This compiles the blinky_test.c test for the STM32F413RHT\n</code></pre> <p>For all PROJECT_TARGET options, see the STM32_Ports page</p>"},{"location":"#flashing-code","title":"Flashing code","text":"<p>Once your code is compiled, use the makefile in the <code>test/</code> directory to flash your built code to the microcontroller. If you are running WSL there are some extra steps to connect the STM32 to your computer, which can be found here.</p> <p>Run the following command to flash:</p> <pre><code>make flash\n</code></pre>"},{"location":"#adding-embedded-sharepoint-to-your-project","title":"Adding Embedded Sharepoint to your project","text":"<p>Follow these instructions on how to add Embedded Sharepoint to your project</p>"},{"location":"#contributing","title":"Contributing","text":"<p>See our Issues to see what you can work on! Once you're ready for a review please open a pull request to merge into main. Pull Requests explained </p>"},{"location":"#porting","title":"Porting","text":"<p>A valid port of an STM requires three things:</p> <ol> <li>A directory under stm/stm32f4xx, stm/stm32l4xx, or stm/stm32g4xx must be generated with the generic name of the microcontroller. This is typically stm32 followed by four characters specifying the series and line (stm32f413, stm32l431, etc.)</li> <li>A linker script under the aforementioned directory. This can be autogenerated by STM32CubeMX or grabbed from the internet. The name should take the form of STM32*_FLASH.ld, and should include the full name of the processor (STM32F413RHTx_FLASH.ld, STM32L431CBTx_FLASH.ld, etc.)</li> <li>A startup assembly file including the vector table and some basic handlers (most important being Reset_Handler). This can be autogenerated by STM32CubeMX or grabbed from the internet. The name should take the form of startup_stm32 followed by the four characters specifying the series and line and then xx (startup_stm32f413xx.s, startup_stm32l431xx.s)</li> <li>A configuration file with the exact MCU name (e.g. stm32l432kcu.cfg) specifying which BSP modules to disable in a space separated list like so:     <code>BSP_DISABLE=CAN UART ADC</code>     Please check which peripherals actually exist on your MCU, or be prepared for strange build errors.</li> </ol> <p>The Makefile will expect this exact naming structure, so please ensure you've set it up properly. If everything goes to plan, you should be able to build with PROJECT_TARGET set to the full name of the port.</p>"},{"location":"CubeMX/","title":"CubeMX","text":"<p>STM32 CubeMX is a graphical tool made by STMicro to help in creating STM32 hardware and software. While the generated code is not always optimal, CubeMX is extremely useful for figuring out pin alternate functions, setting up clock trees, and quickly enabling peripherals.</p>"},{"location":"CubeMX/#1-installing-cubemx","title":"1. Installing CubeMX","text":"<p>Download CubeMX here.</p>"},{"location":"CubeMX/#2-using-the-cubemx-microcontroller-editor","title":"2. Using the CubeMX Microcontroller Editor","text":"<ol> <li>Open \"STM32CubeMX\".  </li> <li>Press \"Access to MCU Selector\".  </li> <li>Search for your MCU part number (e.g. STM32F413RHT)</li> <li>Click \"Start Project\" and CubeMX will generate a project workspace.</li> </ol> Note: This is the configuration view for the STM32F413RHT so your pinout might look slightly different."},{"location":"CubeMX/#3-editing-peripheral-settings","title":"3. Editing Peripheral Settings","text":"<p>This section will show you how to change configurations for peripherals you wish to interface.</p>"},{"location":"CubeMX/#31-selecting-a-peripheral","title":"3.1 Selecting a Peripheral","text":"<ul> <li>On the left-hand side of CubeMX, locate the pane with the \"Categories\" tab selected.</li> <li>Toggle the dropdowns to see the peripherals that are supported on your MCU:</li> </ul> <p>Analog - ADCs, DACs Timers - TIM1, TIM2, ... Connectivity - I\u00b2C, USART / UART, SPI </p> <ul> <li>Now, you can select the peripherals you want to enable (e.g., USART1, I2C1, TIM2, etc.).  </li> <li>CubeMX will automatically assign the required pins on the microcontroller diagram.  </li> <li>If there are conflicts (e.g., two peripherals trying to use the same pin), CubeMX will show a warning and let you reassign pins manually.  </li> <li>Hover over the microcontroller diagram and click on a pin to change its function or remap it.</li> </ul> Yay, we can configure our peripherals now!"},{"location":"CubeMX/#32-configuring-a-peripheral","title":"3.2 Configuring a Peripheral","text":"<ul> <li>Clicking a specific peripheral opens a settings window for that peripheral.  </li> <li> <p>The \"Mode\" and \"Configuration\" windows can be used to change configurations for a specific peripheral</p> </li> <li> <p>Examples of configurations:   \u00a0\u00a0-  USART: baud rate, word length, stop bits, parity, DMA options   \u00a0\u00a0-  Timers: PWM mode, clock source, prescaler values, channel mappings   \u00a0\u00a0-  ADC: resolution, sampling time, number of channels, trigger source</p> </li> <li> <p>You can also configure NVIC interrupts and enable/disable them from this window.</p> </li> </ul>"},{"location":"CubeMX/#33-clock-configuration","title":"3.3 Clock Configuration","text":"<ul> <li>Go to the \"Clock Configuration\" tab.  </li> <li>Set up the input oscillator (HSI, HSE, LSE) and PLL settings.  </li> <li>To change derived clock speeds enter your desired value and CubeMX will calculate the necessary prescalers to get there.</li> <li>If you exceed limits, CubeMX will flag the error in red.</li> </ul> \u23f0\u23f0\u23f0"},{"location":"CubeMX/#4-generating-code","title":"4. Generating Code","text":"<ol> <li>Press the \"Project Manager\" tab.  </li> <li>Under \"Code Generator\" you can specify project name, location, and toolchain (e.g., STM32CubeIDE, Keil, IAR, or Makefile).  </li> <li>Click \"Generate Code\" (you may have to install firmware packages for the MCU \ud83d\ude34).  </li> <li>Open the generated project in your chosen IDE and enjoy!</li> </ol>"},{"location":"DBC/","title":"Table of Contents","text":"<ul> <li>Bps (daybreak)</li> <li>Contactor</li> <li>Controls</li> <li>Prohelion Wavesculptor22</li> <li>Tpee Mppt[a]</li> <li>Tpee Mppt[b]</li> </ul>"},{"location":"DBC/#bps-daybreakdbc","title":"bps (Daybreak).dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages","title":"Messages","text":"ID Name DLC Signals 0x2 BPS_Trip 1 BPS_Trip 0x101 BPS_All_Clea 1 BPS_All_Clear 0x102 BPS_Contactor_State 1 HV_Contactor, Array_Contactor 0x103 BPS_Current 4 Current 0x104 BPS_Voltage_Array 5 Voltage_idx, Voltage_Value 0x105 BPS_Temperature_Array 5 Temperature_idx, Temperature_Value 0x106 BPS_SOC 4 SoC 0x107 BPS_WDog_Trigger 1 WDog_Trig 0x108 BPS_CAN_Error 1 BPS_CAN_Error 0x109 BPS_Command 8 BPS_Command 0x10B BPS_Supplemental_Voltage 2 Supplemental_Voltage 0x10C BPS_Charge_Enabled 1 Charge_Enabled 0x10D BPS_Voltage_Summary 8 Pack_Voltage, Voltage_Range, Voltage_Timestamp 0x10E BPS_Temperature_Summary 8 Average_Temp, Temperature_Range, Temperature_Timestamp 0x10F BPS_Fault_State 1 BPS_Fault_State"},{"location":"DBC/#signals","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit BPS_Trip BPS_Trip [0:0] 1 1 0 0 1 BPS_All_Clear BPS_All_Clea [0:0] 1 1 0 0 1 HV_Contactor BPS_Contactor_State [2:2] 1 1 0 0 1 Array_Contactor BPS_Contactor_State [0:0] 1 1 0 0 1 Current BPS_Current [0:31] 32 1 0 -20000 100000 mA Voltage_idx BPS_Voltage_Array [0:7] 8 1 0 0 31 Voltage_Value BPS_Voltage_Array [8:39] 32 1 0 0 1000000 mV Temperature_idx BPS_Temperature_Array [0:7] 8 1 0 0 31 Temperature_Value BPS_Temperature_Array [8:39] 32 1 0 0 1000000 mC SoC BPS_SOC [0:31] 32 1 0 0 100 % WDog_Trig BPS_WDog_Trigger [0:0] 1 1 0 0 1 BPS_CAN_Error BPS_CAN_Error [0:0] 1 1 0 0 1 BPS_Command BPS_Command [0:31] 32 1 0 None None Supplemental_Voltage BPS_Supplemental_Voltage [0:15] 16 1 0 0 65535 mV Charge_Enabled BPS_Charge_Enabled [0:0] 1 1 0 0 1 Pack_Voltage BPS_Voltage_Summary [0:23] 24 1 0 0 16777215 mV Voltage_Range BPS_Voltage_Summary [24:47] 24 1 0 0 16777215 mV Voltage_Timestamp BPS_Voltage_Summary [48:63] 16 1 0 0 65535 ms Average_Temp BPS_Temperature_Summary [0:23] 24 1 0 None None mC Temperature_Range BPS_Temperature_Summary [24:47] 24 1 0 None None mC Temperature_Timestamp BPS_Temperature_Summary [48:63] 16 1 0 None None ms BPS_Fault_State BPS_Fault_State [0:7] 8 1 0 0 12"},{"location":"DBC/#contactordbc","title":"contactor.dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_1","title":"Messages","text":"ID Name DLC Signals 0x401 Precharge_Timeout 1 Motor_Precharge_Timeout, Array_Precharge_Timeout 0x400 Contactor_Sense 2 Actual_Motor_Sense, Expected_Motor_Sense, Motor_Sense_Fault, Motor_Precharge_Sense, Expected_Motor_Precharge_Sense, Motor_Precharge_Sense_Fault, Array_Precharge_Sense, Expected_Array_Precharge_Sense, Array_Prechage_Sense_Fault"},{"location":"DBC/#signals_1","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit Motor_Precharge_Timeout Precharge_Timeout [0:0] 1 1 0 0 1 Array_Precharge_Timeout Precharge_Timeout [1:1] 1 1 0 None None Actual_Motor_Sense Contactor_Sense [0:0] 1 1 0 0 1 Expected_Motor_Sense Contactor_Sense [1:1] 1 1 0 None None Motor_Sense_Fault Contactor_Sense [2:2] 1 1 0 0 1 Motor_Precharge_Sense Contactor_Sense [3:3] 1 1 0 0 1 Expected_Motor_Precharge_Sense Contactor_Sense [4:4] 1 1 0 0 1 Motor_Precharge_Sense_Fault Contactor_Sense [5:5] 1 1 0 0 1 Array_Precharge_Sense Contactor_Sense [6:6] 1 1 0 0 1 Expected_Array_Precharge_Sense Contactor_Sense [7:7] 1 1 0 0 1 Array_Prechage_Sense_Fault Contactor_Sense [8:8] 1 1 0 0 1"},{"location":"DBC/#controlsdbc","title":"controls.dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_2","title":"Messages","text":"ID Name DLC Signals 0x581 IO_State 3 Acceleration_Percentage, Brake_Percentage, IGN_Array, IGN_Motor, Regen_SW, Forward_Gear, Reverse_Gear, Cruz_EN, Cruz_Set, Brake_Light 0x583 Controls_Fault 1 Controls_Fault, Motor_Controller_Fault, BPS_Fault, Pedals_Fault, CarCAN_Fault, Internal_Controls_Fault, OS_Fault, Lakshay_Fault 0x584 Motor_Controller_Safe 1 Motor_Safe, Motor_Controller_Error 0x221 Motor_Drive_Command 8 Motor_Velocity_Setpoint, Motor_Current_Setpoint 0x222 Motor_Power_Command 8 Motor_Power_Setpoint 0x585 Pedals_Raw_Voltage 4 Brake_Raw, Accel_Raw"},{"location":"DBC/#signals_2","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit Acceleration_Percentage IO_State [0:7] 8 1 0 0 100 Percentage Brake_Percentage IO_State [8:15] 8 1 0 0 100 Percentage the brake is pressed IGN_Array IO_State [16:16] 1 1 0 0 1 Array Ignition On IGN_Motor IO_State [17:17] 1 1 0 0 1 Motor Ignition On Regen_SW IO_State [18:18] 1 1 0 0 1 Regen Switched On Forward_Gear IO_State [19:19] 1 1 0 0 1 Forward switch Reverse_Gear IO_State [20:20] 1 1 0 0 1 Reverse switch Cruz_EN IO_State [21:21] 1 1 0 0 1 Cruise Enable Cruz_Set IO_State [22:22] 1 1 0 0 1 Cruise Set Brake_Light IO_State [23:23] 1 1 0 0 1 Brakelight state Controls_Fault Controls_Fault [0:0] 1 1 0 0 1 Motor_Controller_Fault Controls_Fault [1:1] 1 1 0 0 1 BPS_Fault Controls_Fault [2:2] 1 1 0 0 1 Pedals_Fault Controls_Fault [3:3] 1 1 0 None None CarCAN_Fault Controls_Fault [4:4] 1 1 0 0 1 Internal_Controls_Fault Controls_Fault [5:5] 1 1 0 0 1 OS_Fault Controls_Fault [6:6] 1 1 0 0 1 Lakshay_Fault Controls_Fault [7:7] 1 1 0 0 1 Motor_Safe Motor_Controller_Safe [0:0] 1 1 0 0 1 Motor_Controller_Error Motor_Controller_Safe [1:1] 1 1 0 0 1 Motor_Velocity_Setpoint Motor_Drive_Command [0:31] 32 1 0 None None rpm Motor_Current_Setpoint Motor_Drive_Command [32:63] 32 1 0 None None % Motor_Power_Setpoint Motor_Power_Command [32:63] 32 1 0 None None % Brake_Raw Pedals_Raw_Voltage [0:14] 15 1 0 0 3300 mV Accel_Raw Pedals_Raw_Voltage [16:30] 15 1 0 0 3300 mV"},{"location":"DBC/#prohelion_wavesculptor22dbc","title":"prohelion_wavesculptor22.dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_3","title":"Messages","text":"ID Name DLC Signals 0x240 IDInfo 8 TritiumID, SerialNumber 0x241 Status 8 LimitOutputVoltagePWM, LimitMotorCurrent, LimitVelocity, LimitBusCurrent, LimitBusVoltageUpper, LimitBusVoltageLower, LimitIpmOrMotorTemp, LimitReserved, ErrorHardwareOverCurrent, ErrorSoftwareOverCurrent, ErrorDcBusOverVoltage, ErrorBadMotorPositionHallSeq, ErrorWatchdogCausedLastReset, ErrorConfigRead, Error15vRailUnderVoltage, ErrorDesaturationFault, ErrorMotorOverSpeed, ErrorReserved, ActiveMotor, TxErrorCount, RxErrorCount 0x242 BusMeasurement 8 BusVoltage, BusCurrent 0x243 VelocityMeasurement 8 MotorVelocity, VehicleVelocity 0x244 PhaseCurrentMeasurement 8 PhaseCurrentB, PhaseCurrentC 0x245 MotorVoltageVectorMeasurement 8 Vq, Vd 0x246 MotorCurrentVectorMeasurement 8 Iq, Id 0x247 BackEMFMeasurementPrediction 8 BEMFq, BEMFd 0x248 VoltageRail15VMeasurement 8 ReservedSupply15V, Supply15V 0x249 VoltageRail3V31V9Measurement 8 Supply1V9, Supply3V3 0x24A Reserved0A 8 Reserved0A0, Reserved0A1 0x24B HeatsinkMotorTempMeasurement 8 MotorTemp, HeatsinkTemp 0x24C DspBoardTempMeasurement 8 DspBoardTemp, ReservedDspBoardTemp 0x24D Reserved0D 8 Reserved0D0, Reserved0D1 0x24E OdometerBusAhMeasurement 8 Odometer, DCBusAh 0x257 SlipSpeedMeasurement 8 SlipSpeed, ReservedSlipSpeed"},{"location":"DBC/#signals_3","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit TritiumID IDInfo [0:31] 32 1 0 None None SerialNumber IDInfo [32:63] 32 1 0 None None LimitOutputVoltagePWM Status [0:0] 1 1 0 0 1 On / Off LimitMotorCurrent Status [1:1] 1 1 0 0 1 On / Off LimitVelocity Status [2:2] 1 1 0 0 1 On / Off LimitBusCurrent Status [3:3] 1 1 0 0 1 On / Off LimitBusVoltageUpper Status [4:4] 1 1 0 0 1 On / Off LimitBusVoltageLower Status [5:5] 1 1 0 0 1 On / Off LimitIpmOrMotorTemp Status [6:6] 1 1 0 0 1 On / Off LimitReserved Status [7:15] 9 1 0 0 511 On / Off ErrorHardwareOverCurrent Status [16:16] 1 1 0 0 1 On / Off ErrorSoftwareOverCurrent Status [17:17] 1 1 0 0 1 On / Off ErrorDcBusOverVoltage Status [18:18] 1 1 0 0 1 On / Off ErrorBadMotorPositionHallSeq Status [19:19] 1 1 0 0 1 On / Off ErrorWatchdogCausedLastReset Status [20:20] 1 1 0 0 1 On / Off ErrorConfigRead Status [21:21] 1 1 0 0 1 On / Off Error15vRailUnderVoltage Status [22:22] 1 1 0 0 1 On / Off ErrorDesaturationFault Status [23:23] 1 1 0 0 1 On / Off ErrorMotorOverSpeed Status [24:24] 1 1 0 0 1 On / Off ErrorReserved Status [25:31] 7 1 0 None None On / Off ActiveMotor Status [32:47] 16 1 0 None None TxErrorCount Status [48:55] 8 1 0 None None RxErrorCount Status [56:63] 8 1 0 None None BusVoltage BusMeasurement [0:31] 32 1 0 0 100 V BusCurrent BusMeasurement [32:63] 32 1 0 0 1000 A MotorVelocity VelocityMeasurement [0:31] 32 1 0 None None rpm VehicleVelocity VelocityMeasurement [32:63] 32 2.237 0 None None mph PhaseCurrentB PhaseCurrentMeasurement [0:31] 32 1 0 None None A_rms PhaseCurrentC PhaseCurrentMeasurement [32:63] 32 1 0 None None A_rms Vq MotorVoltageVectorMeasurement [0:31] 32 1 0 None None V Vd MotorVoltageVectorMeasurement [32:63] 32 1 0 None None V Iq MotorCurrentVectorMeasurement [0:31] 32 1 0 None None A Id MotorCurrentVectorMeasurement [32:63] 32 1 0 None None A BEMFq BackEMFMeasurementPrediction [0:31] 32 1 0 None None V BEMFd BackEMFMeasurementPrediction [32:63] 32 1 0 None None V ReservedSupply15V VoltageRail15VMeasurement [0:31] 32 1 0 None None Supply15V VoltageRail15VMeasurement [32:63] 32 1 0 None None V Supply1V9 VoltageRail3V31V9Measurement [0:31] 32 1 0 None None V Supply3V3 VoltageRail3V31V9Measurement [32:63] 32 1 0 None None V Reserved0A0 Reserved0A [0:31] 32 1 0 None None Reserved0A1 Reserved0A [32:63] 32 1 0 None None MotorTemp HeatsinkMotorTempMeasurement [0:31] 32 1 0 None None C HeatsinkTemp HeatsinkMotorTempMeasurement [32:63] 32 1 0 None None C DspBoardTemp DspBoardTempMeasurement [0:31] 32 1 0 None None C ReservedDspBoardTemp DspBoardTempMeasurement [32:63] 32 1 0 None None Reserved0D0 Reserved0D [0:31] 32 1 0 None None Reserved0D1 Reserved0D [32:63] 32 1 0 None None Odometer OdometerBusAhMeasurement [0:31] 32 1 0 None None m DCBusAh OdometerBusAhMeasurement [32:63] 32 1 0 None None Ah SlipSpeed SlipSpeedMeasurement [0:31] 32 1 0 None None Hz ReservedSlipSpeed SlipSpeedMeasurement [32:63] 32 1 0 None None"},{"location":"DBC/#tpee_mpptadbc","title":"tpee_mppt[A].dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_4","title":"Messages","text":"ID Name DLC Signals 0x201 MPPT_32_0_Status 5 MPPT_Mode, MPPT_Fault, MPPT_Enabled, MPPT_AmbientTemperature, MPPT_HeatsinkTemperature 0x200 MPPT_32_0_Power 8 MPPT_Vin, MPPT_Iin, MPPT_Vout, MPPT_Iout 0x209 MPPT_32_0_SetMode 1 Boost_Enable"},{"location":"DBC/#signals_4","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit MPPT_Mode MPPT_32_0_Status [0:7] 8 1 0 None None MPPT_Fault MPPT_32_0_Status [8:15] 8 1 0 None None MPPT_Enabled MPPT_32_0_Status [16:23] 8 1 0 None None MPPT_AmbientTemperature MPPT_32_0_Status [31:38] 8 1 0 -128 127 C MPPT_HeatsinkTemperature MPPT_32_0_Status [39:46] 8 1 0 -128 127 C MPPT_Vin MPPT_32_0_Power [7:22] 16 0.01 0 -327.68 327.67 V MPPT_Iin MPPT_32_0_Power [23:38] 16 0.0005 0 -16.384 16.3835 A MPPT_Vout MPPT_32_0_Power [39:54] 16 0.01 0 -327.68 327.67 V MPPT_Iout MPPT_32_0_Power [55:70] 16 0.0005 0 None None A Boost_Enable MPPT_32_0_SetMode [0:0] 1 1 0 0 1"},{"location":"DBC/#tpee_mpptbdbc","title":"tpee_mppt[B].dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_5","title":"Messages","text":"ID Name DLC Signals 0x211 MPPT_33_0_Status 5 MPPT_Mode, MPPT_Fault, MPPT_Enabled, MPPT_AmbientTemperature, MPPT_HeatsinkTemperature 0x210 MPPT_33_0_Power 8 MPPT_Vin, MPPT_Iin, MPPT_Vout, MPPT_Iout 0x219 MPPT_33_0_SetMode 1 Boost_Enable"},{"location":"DBC/#signals_5","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit MPPT_Mode MPPT_33_0_Status [0:7] 8 1 0 None None MPPT_Fault MPPT_33_0_Status [8:15] 8 1 0 None None MPPT_Enabled MPPT_33_0_Status [16:23] 8 1 0 None None MPPT_AmbientTemperature MPPT_33_0_Status [31:38] 8 1 0 -128 127 C MPPT_HeatsinkTemperature MPPT_33_0_Status [39:46] 8 1 0 -128 127 C MPPT_Vin MPPT_33_0_Power [7:22] 16 0.01 0 -327.68 327.67 V MPPT_Iin MPPT_33_0_Power [23:38] 16 0.0005 0 -16.384 16.3835 A MPPT_Vout MPPT_33_0_Power [39:54] 16 0.01 0 -327.68 327.67 V MPPT_Iout MPPT_33_0_Power [55:70] 16 0.0005 0 None None A Boost_Enable MPPT_33_0_SetMode [0:0] 1 1 0 0 1"},{"location":"EMC2305/","title":"EMC2305 PWM Fan Controller Driver Documentation","text":""},{"location":"EMC2305/#overview","title":"Overview","text":"<p>The EMC2305 is a 5\u2011channel PWM fan controller with optional closed\u2011loop RPM control using tachometer feedback. Driver functions must be called while the FreeRTOS scheduler is active.</p>"},{"location":"EMC2305/#minimal-working-example","title":"Minimal Working Example","text":"<p>WARNING. Don't just copy this code without reading the rest of this page. Lakshay Gupta takes all responsibility for incorrect information regarding this driver. Happy cooling :D</p> <pre><code>// Assuming I2C was initialized and interrupt callbacks overridden\n// Reference \n\n#include \"EMC2305.h\"\n\nI2C_HandleTypeDef hi2c1;\nEMC2305_HandleTypeDef chip;\n\nvoid Init_Task(void* argument) {\n    // Initialize EMC2305\n    // Only call from ONE task!\n    if (EMC2305_Init(&amp;chip, &amp;hi2c1, 0x4D) != EMC2305_OK) {\n        Error_Handler();\n    }\n\n    // Task kills itself\n    vTaskDelete(NULL);\n}\n\nvoid EMC2305_Task_1(void* argument) {\n    // Allow chip to power on\n    vTaskDelay(pdMS_TO_TICKS(250));\n\n    // Set global config\n    EMC2305_Global_Config config = { 0 };\n    config.watchdog_enable = true;\n\n    if (EMC2305_SetGlobalConfig(&amp;chip, &amp;config) != EMC2305_OK) {\n        Error_Handler();\n    }\n\n    // Set config1 and config2\n    EMC2305_Fan_Config1 config1 = { 0 };\n    config1.enable_closed_loop = false; // Set this to true if using FSC (Closed Loop RPM Control). False for using PWM directly\n    config1.edges = EMC2305_EDG_5; // 5 edges is default for 2 pole fans\n    config1.range = EMC2305_RNG_2000;\n\n    EMC2305_Fan_Config2 config2 = { 0 };\n    config2.enable_ramp_rate_ctl = true;\n    config2.enable_glitch_filter = true;\n    config2.error_window = EMC2305_ERG_200RPM;\n    config2.derivative_options = EMC2305_DPT_BOTH;\n\n    if (EMC2305_SetFanConfig(&amp;chip, EMC2305_FAN2, &amp;config1, &amp;config2) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Depends on the fan lol (should be in fan datasheet)\n    if (EMC2305_SetPWMBaseFrequency(&amp;chip, EMC2305_FAN2, EMC2305_PWM_19k53) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Set minimum drive to 0%\n    if (EMC2305_WriteReg(&amp;chip, EMC2305_FAN_REG_ADDR(EMC2305_FAN2, EMC2305_REG_FAN1_MIN_DRIVE), 0x00) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Set PID Gain to lowest (1x)\n    if (EMC2305_WriteReg(&amp;chip, EMC2305_FAN_REG_ADDR(EMC2305_FAN2, EMC2305_REG_GAIN1), 0x00) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Set PWM output mode to open-drain (use false for push-pull)\n    if (EMC2305_SetPWMOutputMode(&amp;chip, EMC2305_FAN2, true) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Control with direct PWM\n    // Set PWM2 duty cycle to 25%\n    if (EMC2305_SetFanPWM(&amp;chip, EMC2305_FAN2, 25) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Control with closed-loop FSC\n    // Set RPM to 3000\n    if (EMC2305_SetFanRPM(&amp;chip, EMC2305_FAN2, 3000) != EMC2305_OK) {\n        Error_Handler();\n    };\n}\n\nint main(void) {\n    // Init your HAL, System Clock, and Peripherals here\n\n    // Create tasks\n    xTaskCreateStatic(Init_Task,\n        \"Init Task\",\n        configMINIMAL_STACK_SIZE,\n        NULL,\n        tskIDLE_PRIORITY + 1,\n        initTaskStack,\n        &amp;initTaskBuffer);\n\n    xTaskCreateStatic(EMC2305_Task_1,\n        \"EMC2305 Task 1\",\n        configMINIMAL_STACK_SIZE,\n        NULL,\n        tskIDLE_PRIORITY + 2,\n        emc2305TaskStack_1,\n        &amp;emc2305TaskBuffer_1);\n\n    vTaskStartScheduler();\n\n    while (1) {\n    }\n\n    return 0;\n}\n\n// I2C Transmit Interrupt Callback\nvoid HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef* hi2c) {\n    EMC2305_I2C_MasterTxCpltCallback(hi2c);\n}\n\n// I2C Receive Interrupt Callback\nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef* hi2c) {\n    EMC2305_I2C_MasterTxCpltCallback(hi2c);\n}\n</code></pre>"},{"location":"EMC2305/#required-hardware-setup","title":"Required Hardware Setup","text":""},{"location":"EMC2305/#mcu-requirements","title":"MCU Requirements","text":"<p>Your board must have:</p> <ul> <li>An STM32 MCU using STM32 HAL (PSOM, LSOM, or any of our other custom STM32 boards)</li> <li>A configured I2C peripheral (interrupt\u2011driven)</li> <li>FreeRTOS enabled in your project (all Embedded-Sharepoint projects use RTOS by default)</li> </ul> <p>This driver relies on:</p> <ul> <li><code>HAL_I2C_Master_Transmit_IT()</code></li> <li><code>HAL_I2C_Master_Receive_IT()</code></li> <li>FreeRTOS queues, semaphores, and static task creation</li> </ul>"},{"location":"EMC2305/#fan-electrical-requirements","title":"Fan Electrical Requirements","text":"<p>Fans may be controlled via:</p> <ul> <li>Push\u2011pull PWM (driven to high and low logic levels)</li> <li>Open\u2011drain PWM (only driven low, requires an external pull\u2011up)</li> </ul> <p>This is configured per\u2011fan using:</p> <pre><code>EMC2305_SetPWMOutputMode()\n</code></pre>"},{"location":"EMC2305/#initialization-process-required-order","title":"Initialization Process (Required Order)","text":""},{"location":"EMC2305/#prerequisites","title":"Prerequisites","text":"<p>Before calling any EMC2305 function:</p> <ul> <li>FreeRTOS scheduler must be running</li> <li>The STM32 I2C peripheral must be initialized</li> <li>I2C interrupts must be enabled</li> </ul>"},{"location":"EMC2305/#required-hal-callbacks","title":"Required HAL Callbacks","text":"<p>You must forward these HAL callbacks:</p> <pre><code>void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c) {\n    EMC2305_I2C_MasterTxCpltCallback(hi2c);\n}\n\nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c) {\n    EMC2305_I2C_MasterRxCpltCallback(hi2c);\n}\n</code></pre> <p>Without this, all I2C operations will hang.</p>"},{"location":"EMC2305/#driver-initialization","title":"Driver Initialization","text":"<p>The first thing you need to do is initialize the chip using this function. It may only be called from one RTOS task (recommended to do this in your init task). An example using I2C bus 1 and the default chip address (0x4D):</p> <pre><code>EMC2305_HandleTypeDef chip;\n\nEMC2305_Init(&amp;chip, &amp;hi2c1, 0x4D);\n</code></pre> <p>What this does internally:</p> <ul> <li>Stores the HAL I2C handle</li> <li>Converts the 7\u2011bit address to HAL format (<code>&lt;&lt; 1</code>)</li> <li>Creates RTOS objects</li> <li>Spawns the I2C worker task</li> <li>Associates the chip with a specific I2C instance</li> <li> <p>Verifies:</p> </li> <li> <p>Product ID (<code>PID == 0b00</code>)</p> </li> <li>Manufacturer ID (<code>0x5D</code>)</li> </ul> <p>If any step fails, <code>EMC2305_ERR</code> is returned.</p>"},{"location":"EMC2305/#core-configuration-functions","title":"Core Configuration Functions","text":""},{"location":"EMC2305/#global-chip-configuration","title":"Global Chip Configuration","text":"<pre><code>EMC2305_Global_Config cfg = {\n    .alert_mask = false,\n    .disable_smbus_timeout = true,\n    .watchdog_enable = false,\n    .drive_ext_clk = false,\n    .use_ext_clk = false,\n};\n\nEMC2305_SetGlobalConfig(&amp;chip, &amp;cfg);\n</code></pre> <p>Controls global chip behavior.</p>"},{"location":"EMC2305/#software-lock-optional","title":"Software Lock (Optional)","text":"<pre><code>EMC2305_EnableSWLock(&amp;chip);\n</code></pre> <ul> <li>Makes all SWL registers read\u2011only</li> <li>Lock persists until power cycle</li> <li>Use only after configuration is complete</li> <li>Do not use this unless you are very confident in your settings</li> </ul>"},{"location":"EMC2305/#operating-modes","title":"Operating Modes","text":""},{"location":"EMC2305/#openloop-pwm-mode-simple","title":"Open\u2011Loop PWM Mode (Simple)","text":"<p>When to use:</p> <ul> <li>You just want to set a duty cycle</li> <li>Fan tach feedback is unavailable or unnecessary</li> </ul> <p>Required configuration:</p> <ul> <li><code>enable_closed_loop = false</code></li> </ul> <p>Control function:</p> <p>Example to set Fan 1 PWM output to 60%:</p> <pre><code>EMC2305_SetFanPWM(&amp;chip, EMC2305_FAN1, 60);\n</code></pre>"},{"location":"EMC2305/#closedloop-rpm-control-recommended","title":"Closed\u2011Loop RPM Control (Recommended)","text":"<p>When to use:</p> <ul> <li>You need stable RPM across voltage/temperature changes</li> <li>You have tach feedback connected</li> </ul> <p>Required configuration:</p> <pre><code>EMC2305_Fan_Config1 cfg1 = {\n    .enable_closed_loop = true,\n    .range = EMC2305_RNG_2000,\n    .edges = EMC2305_EDG_5,\n    .update_time = EMC2305_UDT_100,\n};\n\nEMC2305_Fan_Config2 cfg2 = {\n    .enable_ramp_rate_ctl = true,\n    .enable_glitch_filter = true,\n    .derivative_options = EMC2305_DPT_BOTH,\n    .error_window = EMC2305_ERG_200RPM,\n};\n\nEMC2305_SetFanConfig(&amp;chip, EMC2305_FAN1, &amp;cfg1, &amp;cfg2);\n</code></pre> <p>Control function:</p> <pre><code>EMC2305_SetFanRPM(&amp;chip, EMC2305_FAN1, 3000);\n</code></pre>"},{"location":"EMC2305/#fan-control-api-summary","title":"Fan Control API Summary","text":"Purpose Function Set PWM duty <code>EMC2305_SetFanPWM()</code> Set RPM target <code>EMC2305_SetFanRPM()</code> Read RPM <code>EMC2305_GetFanRPM()</code> Read PWM <code>EMC2305_GetFanPWM()</code> Read fault status <code>EMC2305_GetFanStatus()</code>"},{"location":"EMC2305/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"EMC2305/#using-apis-before-rtos-starts","title":"Using APIs Before RTOS Starts","text":"<p>\u274c Wrong</p> <pre><code>EMC2305_SetFanPWM(...);\n</code></pre> <p>before <code>vTaskStartScheduler()</code></p> <p>\u2714 Correct</p> <p>Call all APIs from tasks only.</p>"},{"location":"EMC2305/#missing-hal-i2c-callbacks","title":"Missing HAL I2C Callbacks","text":"<p>Symptoms:</p> <ul> <li>Functions block forever</li> <li>Timeouts occur</li> </ul> <p>Fix:</p> <ul> <li>Forward HAL callbacks exactly as shown above</li> </ul>"},{"location":"EMC2305/#queue-semaphore-exhaustion","title":"Queue / Semaphore Exhaustion","text":"<p>If too many tasks call EMC2305 APIs simultaneously:</p> <ul> <li><code>EMC2305_ReadReg()</code> returns <code>EMC2305_ERR</code></li> </ul> <p>Fix:</p> <ul> <li>Increase <code>EMC2305_QUEUE_LENGTH</code></li> <li>Avoid excessive polling</li> </ul>"},{"location":"EMC2305/#wrong-control-mode","title":"Wrong Control Mode","text":"<p>Calling:</p> <pre><code>EMC2305_SetFanPWM()\n</code></pre> <p>while closed\u2011loop control is enabled will not work as expected (and vice-versa).</p>"},{"location":"EMC2305/#debugging-guide","title":"Debugging Guide","text":""},{"location":"EMC2305/#chip-not-detected","title":"Chip Not Detected","text":"<p>Check:</p> <ul> <li>I2C address (passed as 7\u2011bit, not shifted)</li> <li>SDA/SCL wiring</li> <li>Pull\u2011ups present</li> </ul>"},{"location":"EMC2305/#rpm-always-reads-uint16_max","title":"RPM Always Reads UINT16_MAX","text":"<p>Causes:</p> <ul> <li>Invalid fan index</li> <li>I2C read failure</li> <li>Tach reading = 0</li> </ul>"},{"location":"EMC2305/#fan-status-flags","title":"Fan Status Flags","text":"<p>Use:</p> <pre><code>EMC2305_Fan_Status status = EMC2305_GetFanStatus(&amp;chip);\n</code></pre> <p>Flags indicate:</p> <ul> <li>Watchdog expiration</li> <li>Spin failure</li> <li>Stall detection</li> <li>Drive failure</li> </ul>"},{"location":"FlashAndTheBug/","title":"Flashing and Debugging on an MCU","text":"<p>This page will walk you through how you can flash your C code on an MCU using Embedded Sharepoint!</p> <p>... and also debug it \ud83e\udee0</p> <p>\u2139\ufe0f Prerequisite :  Make sure you've added Embedded Sharepoint.</p>"},{"location":"FlashAndTheBug/#attaching-usb-devices-in-wsl","title":"Attaching USB devices in WSL","text":"<p>When you plug in your STM32 device, it won't automatically get recognized by your WSL</p> <p>To attach a USB device on WSL you need to install <code>usbipd-win</code>.</p> <ol> <li>Install WinGet if you haven't already using these instructions</li> <li>Open your powershell in administrator mode</li> <li>Run <code>winget install --interactive --exact dorssel.usbipd-win</code></li> </ol> <p>Once we have <code>usbipd</code> we can bind and attach USB devices.</p> <ol> <li>Open Powershell and \"Run as Administrator\".</li> <li>Run <code>usbipd list</code> to get a list of all USB buses.</li> <li>Locate the device called \"ST-Link Debug\" and note the \"BUSID\" (usually in the format of number-number ).</li> <li>Run <code>usbipd bind --busid &lt;BUSID&gt;</code>.</li> <li>Run <code>usbipd attach --wsl --busid &lt;BUSID&gt;</code> (must have an instance of WSL running).</li> </ol> <p>And you're good!</p> <p>Confirm that your device is shared to WSL by running <code>lsusb</code> in your WSL terminal.  </p>"},{"location":"FlashAndTheBug/#attach-usb-devices-using-usbipd-extension","title":"Attach USB devices using USBIPD extension","text":"<p>If you're using VSCode then you can use the <code>USBIPD Connect</code> extension to streamline the process.</p> <p>Once the extension is installed you should see an <code>Attach</code> button at the bottom of your VSCode that when pressed will show you all USB devices. You can now press the ST-Link USB device to connect to it. </p> <p>Note: The extension only works with ST-Links/Nucleos that you\u2019ve previously connected. If you want to use a new device, you\u2019ll need to go through the full manual usbipd setup first. Once a device has been connected manually, the extension can be used to reconnect it quickly in the future.</p>"},{"location":"FlashAndTheBug/#hardware-interface","title":"Hardware Interface","text":"<p>There are two main methods for programming the STM32 microcontrollers we use on our boards: Serial Wire Debug (SWD) and UART. SWD is available on any board with a 4-pin programming header. UART requires a USB-UART conversion chip, along with a USB-C port, which can be found on the PSOM and LSOM, for example.</p>"},{"location":"FlashAndTheBug/#swd-setup","title":"SWD Setup","text":"<p>SWD is a two-wire protocol that is an alternative to JTAG. JTAG is the most common interface for debugging/accessing MCU registers, but it requires 4 pins to communicate while SWD only requires 2, so many ARM microcontrollers will use SWD to ease pin requirements.</p> <p>To program the STM32 microcontroller with SWD, we use an ST-Link\u2014a tool from STMicroelectronics that runs dedicated firmware designed to program STM32 devices.</p> <p>If you take a look at your STM32 Nucleo you should notice two sections on the board:</p> <p></p> Red ST-Link for Debugging Blue STM32 MCU and Peripherals"},{"location":"FlashAndTheBug/#st-link-connector","title":"ST-Link Connector","text":"<p>Your board may have the jumpers ON or OFF on the ST-Link Connector (CN2).</p> <p>ON - you are programming the INTERNAL STM32 MCU (Nucleo)</p> <p>OFF - you are programming the EXTERNAL STM32 MCU (Solar Board)</p> <p>Decide whether you need jumpers based on which MCU you are trying to program.</p> <p>\u2139\ufe0f If you're unsure, run <code>st-info --probe</code> to see the MCU you're flashing to.</p>"},{"location":"FlashAndTheBug/#swd-connector","title":"SWD Connector","text":"<p>When programming an external MCU (not on the Nucleo) the 6-pin SWD connector (CN4) on the ST-Link will be used. </p> <p>Here's the pinout for reference</p> Pin CN4 Designation 1 VDD_TARGET VDD from application 2 SWCLK SWD clock 3 GND Ground 4 SWDIO SWD data I/O 5 NRST RESET of target STM32 6 SWO Reserved <p>On our solar boards we have a SWD interface that looks like this</p> <p>After connecting the corresponding pins you'll be able to program the MCU on your board.</p>"},{"location":"FlashAndTheBug/#uart-setup","title":"UART Setup","text":"<p>UART is the simplest way to program our boards, only requiring a USB-C cable to connect to your laptop. However, while it does allow for flashing and serial monitoring using <code>printf</code>, it does not allow you to run OpenOCD and GDB to step through your code.</p> <p>To connect to your board over UART, plug in a USB-C data cable to the board and your computer. Verify that the board powers up (LEDs turn on) and that you can see the USB-UART chip as a COM port in Device Manager (Windows) or using <code>lsusb_mac</code>/<code>lsusb</code> (MacOS/Linux). On WSL, use <code>usbipd</code> to bind and attach the board the same way you would for ST-Link.</p> <p></p> <p>When programming over UART, you'll have to use the Boot switch and Reset button on the board (PSOM shown below) to enter and exit the bootloader (special section of code that can erase/write to flash memory). When the Boot switch is set to USR, the MCU will start executing your flashed code whenever the Reset button is pressed. When the Boot switch is set to EXT, the MCU will enter the bootloader and wait for any of its peripherals to receive an erase/flash command. In this case, the command will come over UART from the USB-UART converter, but it can also come from CAN, SPI, or several other interfaces.</p> <p></p>"},{"location":"FlashAndTheBug/#software-tooling","title":"Software Tooling","text":""},{"location":"FlashAndTheBug/#overview","title":"Overview","text":"<p>The OpenOCD and stlink packages are some software tools we use to flash and debug code on our board. They are two different options for doing the same thing (flashing and debugging via JTAG/SWD).</p> <ul> <li> <p>stlink is a software package developed by STMicroelectronics to interface with an ST-LINK device for programming and debugging purposes.</p> </li> <li> <p>OpenOCD runs a GDB server, which allows us to debug remote targets via GDB. It also lets us write to flash with some extra configuration.</p> </li> </ul> <p>We currently use the OpenOCD GDB server for debugging while using <code>st-flash</code>, a tool in the stlink package for flashing code.</p>"},{"location":"FlashAndTheBug/#implementation","title":"Implementation","text":"<p>Embedded Sharepoint contains Makefiles to simplify the process of flashing code on an MCU. These Makefiles directly call the <code>st-flash</code> command.</p> <p>On an STM32 MCU, flash memory starts at <code>0x8000000</code>.</p> <p></p> <p>After the Makefile compiles your source code into a binary (<code>.bin</code>), it writes to flash using</p> <pre> st-flash write $(BUILD_DIR)/$(TARGET).bin 0x8000000 </pre> <p>NOTE: We're not flashing the <code>.elf</code> file because it contains unnecessary debug symbols that we don't need to simply flash.</p>"},{"location":"FlashAndTheBug/#make-executables","title":"Make Executables","text":"<p>You can use the Makefile from the <code>test/</code> directory to flash files within the <code>tests/</code> directory.</p> <ol> <li> <p>Navigate to the <code>test/</code> directory.</p> </li> <li> <p>If you've set the environment variables mentioned in \"Adding Embedded Sharepoint\" then you can run <code>make TEST=&lt;testfile&gt;</code> where <code>tests/testfile.c</code> is your test.</p> </li> <li> <p>After your code has been compiled and linked you should see information regarding the <code>.elf</code> file created.</p> </li> </ol> <p></p> <p>If you don't see a similar message nor a <code>.elf</code> file in the <code>build/</code> directory, then look at your console output for a specific error traceback.</p>"},{"location":"FlashAndTheBug/#flash","title":"Flash","text":"<p>If you ran the previous section without error then you should have a <code>.bin</code> and a <code>.elf</code> in your <code>build/</code> corresponding to your target MCU.</p> <p>To flash with SWD:</p> <ol> <li>Navigate to <code>test/</code></li> <li>Run <code>make flash</code></li> </ol> <p>Or alternatively with UART:</p> <ol> <li>Navigate to <code>test/</code></li> <li>Flip the boot switch to EXT &amp; press reset</li> <li>Run <code>make flash-uart</code></li> <li>Flip the boot switch to USR &amp; press reset</li> </ol> <p>... and you've flashed to the MCU!</p>"},{"location":"FlashAndTheBug/#debug","title":"Debug","text":""},{"location":"FlashAndTheBug/#gdb","title":"GDB","text":"<p>To debug we'll use OpenOCD. </p> <ol> <li>Navigate to the root directory of Embedded Sharepoint.</li> <li>Run <code>openocd -f openocd-stm32f4x.cfg</code> if you're programming an F4 MCU or the corresponding <code>..l4x.cfg</code> if you're programming an L4.</li> <li>You should see a message that a GDB server was started on port <code>3333</code>.</li> </ol> <p>Open a second terminal session to use GDB</p> <ol> <li>Run <code>gdb-multiarch build/(TARGET).elf</code>. If you aren't in root the filepath will look slightly different. On mac you need to do <code>arm-none-eabi-gdb</code> instead of 'gdb'</li> <li>Verify that GDB is using the debug symbols from the <code>.elf</code> file.</li> <li>Run <code>tar extended-remote :3333</code> to connect to the OpenOCD GDB server.</li> </ol> <p>Step through your code in GDB to analyze execution!</p>"},{"location":"FlashAndTheBug/#serial-monitoring","title":"Serial Monitoring","text":"<p>Another debugging option is serial monitoring. The <code>printf</code> method is integrated into Embedded-Sharepoint.</p> <ol> <li> <p>The <code>HAL_UART_MspGPIOInit()</code> function must be implemented with the proper GPIO initialization (RCC_CLK_ENABLE, GPIO struct filled in, HAL_GPIO_Init called).</p> </li> <li> <p>The <code>UART_HandleTypeDef</code> struct must be initialized with the proper settings before calling printf_init.</p> </li> <li> <p>Run <code>printf_init(UART_HandleTypeDef)</code> with your desired UART to output to. For a Nucleo, this will be specified in the Nucleo user manual which you can find online. For one of our PCBs, check the schematic to see which UART peripheral your USB is connected to. </p> </li> <li> <p><code>printf_init</code> must be run after the RTOS is initialized.</p> </li> <li> <p>Run <code>printf(...)</code> with your desired format!</p> </li> </ol> <p>To view the output, open up an application like PuTTY or picocom.</p> <ul> <li>For PuTTY, click Serial and enter your desired COM port. This should show up on your device manager (for Mac or Linux, run <code>lsusb</code>). Set the baud rate to what you configured the UART for. Hit the big open button at the bottom.</li> <li>For picocom, type in <code>picocom -b &lt;baud-rate&gt; &lt;tty-name&gt;</code> and you should be set.</li> </ul>"},{"location":"Installation/","title":"Installation Instructions","text":"<p>Development for Embedded-Sharepoint requires a Linux environment. Running Linux natively yields the best results, but there are workarounds through Nix on Mac OS or Windows Subsystem for Linux (WSL) on Windows.  </p>"},{"location":"Installation/#prerequisites","title":"Prerequisites","text":"<p>Please ensure you've done the following before moving on:  </p> <ul> <li>Install Visual Studio Code</li> <li>Set up your GitHub account and SSH key.<ul> <li>You need to both generate an ssh key and add it to your github account</li> </ul> </li> <li>Been added to the lhr-solar organization as a member. Ask one of your leads to do so.</li> <li>Install STM32CubeProgrammer</li> <li>Install drivers for the CP210x USB to UART bridge (needed to flash boards using USB)</li> </ul> <p>Any line that starts with <code>#</code> is a comment and you don't need to run it. </p> <pre><code># Clone the embedded sharepoint repository from the internet to your local computer\ngit clone git@github.com:lhr-solar/Embedded-Sharepoint.git --recursive\n# cd (change directory) to enter the Embedded Sharepoint's directory \ncd Embedded-Sharepoint\n</code></pre>"},{"location":"Installation/#linux","title":"Linux","text":"<p>Run the steps in Nix next</p>"},{"location":"Installation/#windows","title":"Windows","text":""},{"location":"Installation/#windows-subsystem-for-linux-wsl","title":"Windows Subsystem for Linux (WSL)","text":"<p>Windows Subsystem for Linux allows you to run a linux terminal on your windows machine. We specifically use WSL2 since it allows USB passthrough for flashing our microcontrollers. To install WSL follow this guide. Make sure to install WSL2 and not WSL1. It will take time to fully install it, but once installed you can open WSL and it will ask you to create a username and password.</p>"},{"location":"Installation/#usbipd","title":"USBIPD","text":"<p>In order to see a USB device in WSL, we need to pass access of a USB device from windows to WSL. You can do this through USBIPD. In an administrator Powershell terminal run:</p> <pre><code>winget install usbipd\n</code></pre>"},{"location":"Installation/#using-wsl","title":"Using WSL","text":"<p>From now on, you'll be writing all of your solar code in WSL. We primary use VSCode as our code IDE, but there are other IDEs/code editors you can use like Vim or Nano.</p> <ol> <li>Open Visual Studio Code</li> <li>Go into extensions menu on the left side of VSCode, select the WSL extension from Microsoft</li> <li>Press CTRL+SHIFT+P and press connect to WSL</li> <li>Now your VSCode is running WSL and you can run it like a Linux environment. For more info see the WSL guide</li> <li>Do the instructions for generating the github ssh key again while you're in WSL </li> </ol> <p>Run the Ubuntu application, and now you'll be in your WSL/Linux environment.</p> <p>Run the steps in Nix next</p>"},{"location":"Installation/#mac","title":"Mac","text":"<p>Run the steps in Nix</p>"},{"location":"Installation/#nix","title":"Nix","text":"<p>Nix is a package manger that lets you write out all the packages you want to install in a human readable format. This simplifies development since I can write out a list of dependencies needed to compile.  </p> <p>Enter the Embedded Sharepoint and run the following commands in the terminal: </p> <p>Make the nix_install script runnable</p> <pre><code>chmod +x ./nix_install.sh\n</code></pre> <p>Run the script to install the needed nix dependencies.</p> <pre><code>sudo ./nix_install.sh\n</code></pre> <p>Enter the nix shell and download dependencies for Embedded-Sharepoint</p> <pre><code>nix develop\n</code></pre> <p>In this nix shell all the dependencies needed for Embedded-Sharepoint should be installed.  Anytime you open a new terminal and want to run compile/flash code you need to run nix develop to open the shell with Sharepoint's dependencies.  </p> <p>Test if installation is succesful by compiling a test </p> <pre><code>cd test\nmake TEST=blinky\n</code></pre> <p>Now that you've successfully compiled a test, we want to flash our code to the microcontroller. The term \"flashing\" in an embedded system refers to putting your code onto the microcontroller. If you're using WSL there are some extra setup steps you need to do to connect to the microcontroller, that can be found here in the <code>Attaching USB devices in WSL</code> section.  </p> <p>After that run <code>lsusb</code> and make sure you see an ST-Link Debug device is seen by your terminal. Then run the following command to flash to your microcontroller</p> <pre><code>make flash\n</code></pre>"},{"location":"Installation/#common-errors","title":"Common Errors","text":""},{"location":"Installation/#could-not-open-usb-device","title":"Could not open USB device","text":"<p>if you're getting: <code>libusb couldn't open USB device /dev/bus/usb/001/003, errno=13</code> This means your user doesn't have permissions to use a USB port.  To fix this run</p> <pre><code>sudo chmod -R 777 /dev/bus/usb/\n</code></pre>"},{"location":"Installation/#cant-flash-after-changing-project_target","title":"Can't flash after changing PROJECT_TARGET","text":"<p>If you build your code for one PROJECT_TARGET and then switch to another, you\u2019ll usually need to run <code>make clean</code> before flashing to remove all old build files. Otherwise, leftover files from the previous build may remain in your build folder, causing <code>make flash</code> to get confused about which <code>.bin</code> file to use.</p>"},{"location":"STM32_Ports/","title":"List of STM32 Port Names","text":""},{"location":"STM32_Ports/#l4","title":"L4","text":"<ul> <li><code>STM32L431CBTx</code><ul> <li><code>PROJECT_TARGET=stm32l431cbt</code></li> </ul> </li> <li><code>STM32L432KCUx</code><ul> <li><code>PROJECT_TARGET=stm32l432kcu</code></li> </ul> </li> <li><code>STM32L476RGTx</code><ul> <li><code>PROJECT_TARGET=stm32l476rgt</code></li> </ul> </li> </ul>"},{"location":"STM32_Ports/#f4","title":"F4","text":"<ul> <li><code>STM32F401REx</code><ul> <li><code>PROJECT_TARGET=stm32f401re</code></li> </ul> </li> <li><code>STM32F413RHTx</code><ul> <li><code>PROJECT_TARGET=stm32f413rht</code></li> </ul> </li> <li><code>STM32F429ZITx</code><ul> <li><code>PROJECT_TARGET=stm32f429zit</code></li> </ul> </li> <li><code>STM32F446RETx</code><ul> <li><code>PROJECT_TARGET=stm32f446ret</code></li> </ul> </li> </ul>"},{"location":"STM32_Ports/#g4","title":"G4","text":"<ul> <li><code>STM32G473XXx</code><ul> <li><code>PROJECT_TARGET=stm32g473xx</code></li> </ul> </li> <li><code>STM32G474XXx</code><ul> <li><code>PROJECT_TARGET=stm32g474xx</code></li> </ul> </li> </ul>"},{"location":"SharepointSubmodule/","title":"Adding Sharepoint To Your Project","text":""},{"location":"SharepointSubmodule/#1-suggested-directories","title":"1. Suggested directories","text":"<p>It is good practice to organize files into folders based on their abstraction from the STM32 hardware. Embedded-Sharepoint contains a folder for the STM32 HAL (Hardware Abstraction Library), which holds low-level calls to the STM32. Above this are drivers that interact with the HAL, and then applications that use the drivers. This application layer is where your RTOS tasks typically run. You should also have a <code>tests/</code> directory. If your repository contains more than just firmware, it's recommended to create a <code>firmware/</code> directory for all your code, including Embedded-Sharepoint.</p> <p>The suggested (minimal) structure is as follows:</p> <pre><code>Firmware/\n\u251c\u2500\u2500 Embedded-Sharepoint/  #  Don't create this folder manually, it'll be created in the next step\n\u251c\u2500\u2500 Makefile              # The makefile that you write\n\u251c\u2500\u2500 core/                 # Stores tasks and main application logic\n\u251c\u2500\u2500 drivers/              # Drivers\n\u251c\u2500\u2500 middleware/           # External libraries stored in the repository\n\u2514\u2500\u2500 tests/                # Unit and integration tests\n</code></pre> <p>These directories should all have Src/ and Inc/ folders to separate the c header and source files.</p>"},{"location":"SharepointSubmodule/#2-add-embedded-sharepoint-as-a-submodule","title":"2. Add Embedded-Sharepoint as a Submodule","text":"<p>A Git submodule is a way to include one Git repository inside another.  Embedded-Sharepoint contains common files so it should be stored as a submodule inside your repository. For more information about submodules: git submodules documentation.</p> <p>Wherever you want to add Embedded-Sharepoint, run: </p> <pre><code>git submodule add https://github.com/lhr-solar/Embedded-Sharepoint.git\ngit submodule update --init --recursive\n</code></pre> <p>Ensure that the link you're using to add this submodule is the HTTPs link and not the SSH link (needed to for automatic github workflows to trigger).</p>"},{"location":"SharepointSubmodule/#3-writing-a-makefile-for-your-project","title":"3. Writing a makefile for your project","text":"<p>A Makefile is a file used to outline how you want your code to compile. There is a Makefile that compiles all needed files for the STM32 (our microcontroller) in the top level of the Embedded Sharepoint. You need to write another Makefile to compile your project files and call the Embedded-Sharepoint Makefile.  There is a minimal template Makefile in the template/ folder in Embedded-Sharepoint. Lines with <code>#\u2757 CHANGE THIS \u2757</code> define where you should make changes to your Makefile. Move the template Makefile to the same directory as your firmware, and rename it to just be called <code>Makefile</code>. </p> <p>For a more in depth tutorial, I suggest visiting this article on Makefiles</p>"},{"location":"SharepointSubmodule/#basic-makefile-syntax","title":"Basic Makefile syntax","text":"<p>This section explains common Makefile syntax used in the template Makefile.</p>"},{"location":"SharepointSubmodule/#comments","title":"Comments","text":"<p>Any line becomes a comment by adding <code>#</code> When adding comments, it's suggested to make them on a separate line from actual Makefile code, i.e avoid</p> <pre><code>PROJECT_TARGET ?= stm32g473xx # this line contains the project target\n</code></pre> <p>and instead do</p> <pre><code># this line contaisn the project target\nPROJECT_TARGET ?= stm32g473xx \n</code></pre> <p>This is because Makefiles can sometimes compile the comments into the command and break directories. </p>"},{"location":"SharepointSubmodule/#conditional-assignments","title":"Conditional Assignments (<code>?=</code>)","text":"<p>The <code>?=</code> operator assigns a value only if the variable is not already set. This allows variables to be overridden from the command line.</p> <pre><code>PROJECT_TARGET ?= stm32g473xx\n</code></pre> <p>This by default sets the <code>PROJECT_TARGET</code> to be <code>stm32g473xx</code>, but by running</p> <pre><code>make PROJECT_TARGET=stm32l432cbt\n</code></pre> <p>The <code>PROJECT_TARGET</code> will be overridden to <code>stm32l432cbt</code></p>"},{"location":"SharepointSubmodule/#variable-expansion","title":"Variable Expansion","text":"<p>Variables are referenced using <code>$(VAR)</code> or <code>${VAR}</code> (both are valid).</p> <pre><code>$(MAKE) -C $(BUILD_MAKEFILE_DIR) all\n@echo \"Building ${PROJECT_TARGET}\"\n</code></pre>"},{"location":"SharepointSubmodule/#wildcards","title":"Wildcards","text":"<p>Makefiles commonly store multiple files or directories as space-separated lists.</p> <pre><code>PROJECT_C_INCLUDES = core/Inc drivers/Inc\nPROJECT_C_SOURCES  = core/Src/main.c drivers/Src/can.c\n</code></pre> <p>Instead of setting these manually, you can do a <code>wildcard</code> search and add all files that meet certain criteria.</p> <pre><code>PROJECT_C_SOURCES = $(wildcard */Src/*.c)\n</code></pre> <p>This looks through all immediate subdirectories for a <code>Src</code> folder and adds all <code>.c</code> files found within.</p>"},{"location":"SharepointSubmodule/#set-project-variables","title":"Set Project Variables","text":"<p>Below are several variables that the Embedded-Sharepoint Makefile uses to compile your code, these variables are used in the template Makefile, and you can update them.</p> <ul> <li><code>PROJECT_TARGET</code>: The STM32 part number (e.g., <code>stm32f446ret</code>)</li> <li><code>PROJECT_C_SOURCES</code>: List of your C source files</li> <li><code>PROJECT_C_INCLUDES</code>: List of your include directories</li> <li><code>PROJECT_BUILD_DIR</code>: Where to place build outputs</li> <li><code>BEAR_ENABLE</code> to make VSCode not mad at you (the red error squiggles). Bear is by default enabled, but you can set it to 0 to turn it off</li> </ul>"},{"location":"SharepointSubmodule/#creating-a-test-folder","title":"Creating a test folder","text":"<p>It's good to be able to test independent portions of your code instead of your whole code base at once. For example, if I have a driver just for controlling lights I should have a test file that just runs some code for my lights driver instead of the whole codebase which could be running a lot of things other than lights.</p> <p>C expects a <code>main()</code> function as the starting point of your code, so the way we generally implement this is filtering out the main.c file where the <code>main()</code> function is implemented, and compiling your test file instead with it's own <code>main()</code> function.  </p> <p>Create a <code>tests/</code> folder to store your tests, then via your Makefile you can compile those tests into your project, by default they will not be compiled. It's also good practice to add a test prefix or suffix to the name of the test file, e.g. <code>test_can.c</code> to show that it's a test file, and to avoid issues on case-insensitive filesystems like on macOS.</p>"},{"location":"SharepointSubmodule/#copy-the-gitignore","title":"Copy the .gitignore","text":"<p>A lot of junk files are generated during compilation, many of those files should not be pushed so we tell git to ignore these files. A <code>.gitignore</code> file tells which files or directories to ignore, so they are not pushed to the remote repository. There is a template .gitignore file in the template/ directory, which you should place in your firmware/ directory. You are also free to add what's in the template to your already existing .gitignore file. </p> <p>The following are files and directories you should not be pushing:</p> <ul> <li><code>.DS_Store</code> these are mac dump files that are generated in every directory</li> <li><code>build/</code> this is where compiled c files are placed by default, if you change the directory in the Makefile this needs to be updated</li> <li><code>.venv/</code> this is where python environment files are stored, and are usually user and OS dependent</li> </ul>"},{"location":"SharepointSubmodule/#4-add-necessary-functions","title":"4. Add necessary functions","text":""},{"location":"SharepointSubmodule/#create-a-mainc","title":"Create a main.c","text":"<p>Your code begins from the <code>main()</code> function, and if there is no <code>main()</code> function defined the code will not compile. The <code>main()</code> function does not necessarily have to be located in a file named <code>main.c</code> but it is good practice. If you want to use any stm32 related header files, please include the <code>stm32xx_hal.h</code> header file.</p>"},{"location":"SharepointSubmodule/#define-systemclock_config","title":"Define SystemClock_Config","text":"<p>The <code>SystemClock_Config</code> function configures the clock that your STM32 runs on (things like clock frequency, clock source, etc). If the clock is not setup properly then you risk unexpected behavior since a lot of low level embedded code runs using the system clock. We normally run the system clock at 80mhz.</p> <p>We define the SystemClock_Config function as \"weak\", which means that the function can be overridden by a different implementation of the function. We have a default implementation in the stm32xx_hal_init.c file, which by default initializes the internal oscillator of some specific Nucleo's clock, but since we operate with a variety of Nucleos and processors you should redefine the function for your specific usecase.</p> <p>Generate a new SystemClock_Config in STM32CubeMX and add it to one of your files in your repository (suggested is your main.c). This should serve as a redefinition of the function and will override the default behavior. Make sure you are generating the code with the correct microcontroller part number in the software, and you are using an external oscillator (if generating code for one of our SOM PCBs). Instructions on how to use CubeMX and generate a SystemClock_Config can be found here.</p>"},{"location":"SharepointSubmodule/#5-compiling-your-repository","title":"5. Compiling your repository","text":"<p>Code compilation must be done in a nix shell, in Embedded-Sharepoint you can normally just run</p> <pre><code>nix develop\n</code></pre> <p>since the <code>flake.nix</code> file is stored in that directory, but in your repository the flake.nix file is stored in a different directory. To enter the Nix shell when the <code>flake.nix</code> file is stored somewhere else, simply run:</p> <pre><code>nix develop [directory to where flake.nix is]\n</code></pre> <p>For example:</p> <pre><code>nix develop ./Embedded-Sharepoint\n</code></pre> <p>Once you're in the nix shell, run </p> <pre><code>make\n</code></pre> <p>in the same directory as your new Makefile.</p> <p>If you do not want to type that out everytime, you can create a bash script that runs the nix develop command and hardcodes the directory where the nix file is. See this example in VCU</p>"},{"location":"SharepointSubmodule/#6-create-a-readme","title":"6. Create a README","text":"<p>A README.md file is very important for onboarding instructions, and to outline workflows. A README should explain how to go from cloning a repository to how to contribute code. The more descriptive the better!</p>"},{"location":"SharepointSubmodule/#examples-of-projects-that-use-embedded-sharepoint","title":"Examples of projects that use Embedded Sharepoint","text":"<ul> <li>BPS-Leader</li> <li>VCU</li> </ul>"},{"location":"dbcEditor/","title":"Editing CAN DBC files","text":""},{"location":"dbcEditor/#what-is-a-can-dbc-file","title":"What is a CAN DBC file","text":"<p>A CAN DBC file stores encodings for CAN messages. CAN messages are grouped into IDs with a length, and then messages have specific signals which have a length and start bit. A CAN message signal stores how a value is packed into raw CAN data, including its bit position, size, scaling factor, offset, and units.  </p> <p>For example, we have Contactor Sense CAN message with an ID of <code>0x400</code>. There are various signals in this message like the state of the Array Contactor, which has a length of 1 bit and stored in the 6th bit.</p> <p>CAN DBC intro</p>"},{"location":"dbcEditor/#how-to-edit-can-dbc-files","title":"How to edit CAN DBC files","text":"<p>To edit CAN DBC files, we use an online DBC editor from CSS Electronics. We also forked the files to Embedded-Sharepoint in the <code>middleware/dbc-editor</code> directory.  </p> <p>To open the CAN DBC editor you can do one of the following:</p> <ul> <li>Open the CAN DBC editor website linked above</li> <li>Open the <code>dbc-editor.html</code> file located in <code>middleware/dbc-editor</code></li> <li>Run <code>make dbc-editor</code> in the Makefile in <code>tests/</code></li> </ul> <p>From the DBC editor you can open and edit any dbc file, all of which are stored in the <code>can/dbc</code> directory.</p> <p>Ensure that your CAN message type is set to standard, and the length of the message (DLC) is not above 8 bytes.</p>"},{"location":"dbcEditor/#suggestions-for-structuring-can-messages","title":"Suggestions for structuring CAN messages","text":"<p>When structuring CAN messages, consider which other devices on the CAN bus are using that message. </p>"},{"location":"dbcEditor/#can-message-packing","title":"CAN message packing","text":"<p>It is usually beneficial to pack as much related data as possible into a single CAN message. Devices on the bus are often limited by the number of CAN IDs they can store in hardware filters, so reducing the total number of unique message IDs helps avoid exhausting filter slots.</p> <p>As long as the message length remains under 8 bytes (for Classical CAN), there is little downside to using more bytes in a single frame.</p>"},{"location":"dbcEditor/#can-multiplexing","title":"CAN multiplexing","text":"<p>CAN message multiplexing allows multiple logical message layouts to share the same CAN ID. A multiplexor signal is used to indicate which set of signals is valid for a given frame.</p> <p>For example, instead of having an ID for every battery module's voltage, you can allocate a set of bits to indicate which module the message is about.</p>"}]}