{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Embedded Sharepoint Documentation","text":"<p>Welcome to the Embedded Sharepoint! Embedded-Sharepoint contains the shared embedded files to build and develop for our custom STM32 PCBs.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#directory-structure","title":"Directory Structure","text":""},{"location":"#command-usage","title":"Command Usage","text":""},{"location":"#adding-sharepoint-to-your-project","title":"Adding Sharepoint To Your Project","text":"<p>Embedded-Sharepoint contains common files so it should be stored as a submodule inside your repository.  </p>"},{"location":"#examples","title":"Examples:","text":"<ul> <li>BPS-Leader</li> <li>Activ-Precharge Board</li> </ul>"},{"location":"#contributing","title":"Contributing","text":""},{"location":"#wsl","title":"WSL","text":""},{"location":"#usb-passthrough","title":"USB PassThrough","text":""},{"location":"#install-usbipd-only-need-to-do-this-the-first-time","title":"Install USBIPD (only need to do this the first time)","text":"<p>In Powershell administrator:</p> <pre><code>winget install usbipd\n</code></pre>"},{"location":"#pass-usb-devices","title":"Pass USB Devices","text":"<p>In PowerShell administrator: </p> <pre><code>usbipd list\nusbipd bind --busid &lt;busid&gt;\nusbipd attach --wsl --busid &lt;busid&gt;\n</code></pre>"},{"location":"#setup","title":"Setup","text":"<p>Note: Docker installs tools for development on Ubuntu 22.04.</p> <p>Note: DO NOT install packages in the docker session. Changes will be lost. Update the Dockerfile instead!</p> <p>Note: If USB devices are detected via lsusb but fail to open, try restarting the container with the device plugged in.</p>"},{"location":"#vs-code","title":"VS Code","text":"<p>Install Dev Containers extension</p> <p>Open repository folder in VS Code</p> <p>F1 \u2192 \"Dev Containers: Open Folder in Container...\"</p> <p>Ensure docker is running</p> <pre><code>sudo systemctl start docker\n</code></pre>"},{"location":"#cli-script","title":"CLI Script","text":"<p>This script sets up a docker container for embedded development.</p> <p>Usage:</p> <pre><code>./start.sh\n</code></pre> <p>Remove Docker Image:</p> <pre><code>docker rmi embedded-sharepoint-dev\n</code></pre>"},{"location":"#porting","title":"Porting","text":"<p>A valid port of an STM requires three things:</p> <ol> <li>A directory under stm/stm32f4xx or stm/stm32l4xx must be generated with the generic name of the microcontroller. This is typically stm32 followed by four characters specifying the series and line (stm32f413, stm32l431, etc.)</li> <li>A linker script under the aforementioned directory. This can be autogenerated by STM32CubeMX or grabbed from the internet. The name should take the form of STM32*_FLASH.ld, and should include the full name of the processor (STM32F413RHTx_FLASH.ld, STM32L431CBTx_FLASH.ld, etc.)</li> <li>A startup assembly file including the vector table and some basic handlers (most important being Reset_Handler). This can be autogenerated by STM32CubeMX or grabbed from the internet. The name should take the form of startup_stm32 followed by the four characters specifying the series and line and then xx (startup_stm32f413xx.s, startup_stm32l431xx.s)</li> </ol> <p>The Makefile will expect this exact naming structure, so please ensure you've set it up properly. If everything goes to plan, you should be able to build with PROJECT_TARGET set to the full name of the port.</p>"},{"location":"DBC/","title":"Table of Contents","text":"<ul> <li>Bps (daybreak)</li> <li>Contactor</li> <li>Controls</li> <li>Prohelion Wavesculptor22</li> <li>Tpee Mppt[a]</li> <li>Tpee Mppt[b]</li> </ul>"},{"location":"DBC/#bps-daybreakdbc","title":"bps (Daybreak).dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages","title":"Messages","text":"ID Name DLC Signals 0x2 BPS_Trip 1 BPS_Trip 0x101 BPS_All_Clea 1 BPS_All_Clear 0x102 BPS_Contactor_State 1 HV_Contactor, Array_Contactor 0x103 BPS_Current 4 Current 0x104 BPS_Voltage_Array 5 Voltage_idx, Voltage_Value 0x105 BPS_Temperature_Array 5 Temperature_idx, Temperature_Value 0x106 BPS_SOC 4 SoC 0x107 BPS_WDog_Trigger 1 WDog_Trig 0x108 BPS_CAN_Error 1 BPS_CAN_Error 0x109 BPS_Command 8 BPS_Command 0x10B BPS_Supplemental_Voltage 2 Supplemental_Voltage 0x10C BPS_Charge_Enabled 1 Charge_Enabled 0x10D BPS_Voltage_Summary 8 Pack_Voltage, Voltage_Range, Voltage_Timestamp 0x10E BPS_Temperature_Summary 8 Average_Temp, Temperature_Range, Temperature_Timestamp 0x10F BPS_Fault_State 1 BPS_Fault_State"},{"location":"DBC/#signals","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit BPS_Trip BPS_Trip [0:0] 1 1 0 0 1 BPS_All_Clear BPS_All_Clea [0:0] 1 1 0 0 1 HV_Contactor BPS_Contactor_State [2:2] 1 1 0 0 1 Array_Contactor BPS_Contactor_State [0:0] 1 1 0 0 1 Current BPS_Current [0:31] 32 1 0 -20000 100000 mA Voltage_idx BPS_Voltage_Array [0:7] 8 1 0 0 31 Voltage_Value BPS_Voltage_Array [8:39] 32 1 0 0 1000000 mV Temperature_idx BPS_Temperature_Array [0:7] 8 1 0 0 31 Temperature_Value BPS_Temperature_Array [8:39] 32 1 0 0 1000000 mC SoC BPS_SOC [0:31] 32 1 0 0 100 % WDog_Trig BPS_WDog_Trigger [0:0] 1 1 0 0 1 BPS_CAN_Error BPS_CAN_Error [0:0] 1 1 0 0 1 BPS_Command BPS_Command [0:31] 32 1 0 None None Supplemental_Voltage BPS_Supplemental_Voltage [0:15] 16 1 0 0 65535 mV Charge_Enabled BPS_Charge_Enabled [0:0] 1 1 0 0 1 Pack_Voltage BPS_Voltage_Summary [0:23] 24 1 0 0 16777215 mV Voltage_Range BPS_Voltage_Summary [24:47] 24 1 0 0 16777215 mV Voltage_Timestamp BPS_Voltage_Summary [48:63] 16 1 0 0 65535 ms Average_Temp BPS_Temperature_Summary [0:23] 24 1 0 None None mC Temperature_Range BPS_Temperature_Summary [24:47] 24 1 0 None None mC Temperature_Timestamp BPS_Temperature_Summary [48:63] 16 1 0 None None ms BPS_Fault_State BPS_Fault_State [0:7] 8 1 0 0 12"},{"location":"DBC/#contactordbc","title":"contactor.dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_1","title":"Messages","text":"ID Name DLC Signals 0x401 Precharge_Timeout 1 Motor_Precharge_Timeout, Array_Precharge_Timeout 0x400 Contactor_Sense 2 Actual_Motor_Sense, Expected_Motor_Sense, Motor_Sense_Fault, Motor_Precharge_Sense, Expected_Motor_Precharge_Sense, Motor_Precharge_Sense_Fault, Array_Precharge_Sense, Expected_Array_Precharge_Sense, Array_Prechage_Sense_Fault"},{"location":"DBC/#signals_1","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit Motor_Precharge_Timeout Precharge_Timeout [0:0] 1 1 0 0 1 Array_Precharge_Timeout Precharge_Timeout [1:1] 1 1 0 None None Actual_Motor_Sense Contactor_Sense [0:0] 1 1 0 0 1 Expected_Motor_Sense Contactor_Sense [1:1] 1 1 0 None None Motor_Sense_Fault Contactor_Sense [2:2] 1 1 0 0 1 Motor_Precharge_Sense Contactor_Sense [3:3] 1 1 0 0 1 Expected_Motor_Precharge_Sense Contactor_Sense [4:4] 1 1 0 0 1 Motor_Precharge_Sense_Fault Contactor_Sense [5:5] 1 1 0 0 1 Array_Precharge_Sense Contactor_Sense [6:6] 1 1 0 0 1 Expected_Array_Precharge_Sense Contactor_Sense [7:7] 1 1 0 0 1 Array_Prechage_Sense_Fault Contactor_Sense [8:8] 1 1 0 0 1"},{"location":"DBC/#controlsdbc","title":"controls.dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_2","title":"Messages","text":"ID Name DLC Signals 0x581 IO_State 3 Acceleration_Percentage, Brake_Percentage, IGN_Array, IGN_Motor, Regen_SW, Forward_Gear, Reverse_Gear, Cruz_EN, Cruz_Set, Brake_Light 0x583 Controls_Fault 1 Controls_Fault, Motor_Controller_Fault, BPS_Fault, Pedals_Fault, CarCAN_Fault, Internal_Controls_Fault, OS_Fault, Lakshay_Fault 0x584 Motor_Controller_Safe 1 Motor_Safe, Motor_Controller_Error 0x221 Motor_Drive_Command 8 Motor_Velocity_Setpoint, Motor_Current_Setpoint 0x222 Motor_Power_Command 8 Motor_Power_Setpoint 0x585 Pedals_Raw_Voltage 4 Brake_Raw, Accel_Raw"},{"location":"DBC/#signals_2","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit Acceleration_Percentage IO_State [0:7] 8 1 0 0 100 Percentage Brake_Percentage IO_State [8:15] 8 1 0 0 100 Percentage the brake is pressed IGN_Array IO_State [16:16] 1 1 0 0 1 Array Ignition On IGN_Motor IO_State [17:17] 1 1 0 0 1 Motor Ignition On Regen_SW IO_State [18:18] 1 1 0 0 1 Regen Switched On Forward_Gear IO_State [19:19] 1 1 0 0 1 Forward switch Reverse_Gear IO_State [20:20] 1 1 0 0 1 Reverse switch Cruz_EN IO_State [21:21] 1 1 0 0 1 Cruise Enable Cruz_Set IO_State [22:22] 1 1 0 0 1 Cruise Set Brake_Light IO_State [23:23] 1 1 0 0 1 Brakelight state Controls_Fault Controls_Fault [0:0] 1 1 0 0 1 Motor_Controller_Fault Controls_Fault [1:1] 1 1 0 0 1 BPS_Fault Controls_Fault [2:2] 1 1 0 0 1 Pedals_Fault Controls_Fault [3:3] 1 1 0 None None CarCAN_Fault Controls_Fault [4:4] 1 1 0 0 1 Internal_Controls_Fault Controls_Fault [5:5] 1 1 0 0 1 OS_Fault Controls_Fault [6:6] 1 1 0 0 1 Lakshay_Fault Controls_Fault [7:7] 1 1 0 0 1 Motor_Safe Motor_Controller_Safe [0:0] 1 1 0 0 1 Motor_Controller_Error Motor_Controller_Safe [1:1] 1 1 0 0 1 Motor_Velocity_Setpoint Motor_Drive_Command [0:31] 32 1 0 None None rpm Motor_Current_Setpoint Motor_Drive_Command [32:63] 32 1 0 None None % Motor_Power_Setpoint Motor_Power_Command [32:63] 32 1 0 None None % Brake_Raw Pedals_Raw_Voltage [0:14] 15 1 0 0 3300 mV Accel_Raw Pedals_Raw_Voltage [16:30] 15 1 0 0 3300 mV"},{"location":"DBC/#prohelion_wavesculptor22dbc","title":"prohelion_wavesculptor22.dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_3","title":"Messages","text":"ID Name DLC Signals 0x240 IDInfo 8 TritiumID, SerialNumber 0x241 Status 8 LimitOutputVoltagePWM, LimitMotorCurrent, LimitVelocity, LimitBusCurrent, LimitBusVoltageUpper, LimitBusVoltageLower, LimitIpmOrMotorTemp, LimitReserved, ErrorHardwareOverCurrent, ErrorSoftwareOverCurrent, ErrorDcBusOverVoltage, ErrorBadMotorPositionHallSeq, ErrorWatchdogCausedLastReset, ErrorConfigRead, Error15vRailUnderVoltage, ErrorDesaturationFault, ErrorMotorOverSpeed, ErrorReserved, ActiveMotor, TxErrorCount, RxErrorCount 0x242 BusMeasurement 8 BusVoltage, BusCurrent 0x243 VelocityMeasurement 8 MotorVelocity, VehicleVelocity 0x244 PhaseCurrentMeasurement 8 PhaseCurrentB, PhaseCurrentC 0x245 MotorVoltageVectorMeasurement 8 Vq, Vd 0x246 MotorCurrentVectorMeasurement 8 Iq, Id 0x247 BackEMFMeasurementPrediction 8 BEMFq, BEMFd 0x248 VoltageRail15VMeasurement 8 ReservedSupply15V, Supply15V 0x249 VoltageRail3V31V9Measurement 8 Supply1V9, Supply3V3 0x24A Reserved0A 8 Reserved0A0, Reserved0A1 0x24B HeatsinkMotorTempMeasurement 8 MotorTemp, HeatsinkTemp 0x24C DspBoardTempMeasurement 8 DspBoardTemp, ReservedDspBoardTemp 0x24D Reserved0D 8 Reserved0D0, Reserved0D1 0x24E OdometerBusAhMeasurement 8 Odometer, DCBusAh 0x257 SlipSpeedMeasurement 8 SlipSpeed, ReservedSlipSpeed"},{"location":"DBC/#signals_3","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit TritiumID IDInfo [0:31] 32 1 0 None None SerialNumber IDInfo [32:63] 32 1 0 None None LimitOutputVoltagePWM Status [0:0] 1 1 0 0 1 On / Off LimitMotorCurrent Status [1:1] 1 1 0 0 1 On / Off LimitVelocity Status [2:2] 1 1 0 0 1 On / Off LimitBusCurrent Status [3:3] 1 1 0 0 1 On / Off LimitBusVoltageUpper Status [4:4] 1 1 0 0 1 On / Off LimitBusVoltageLower Status [5:5] 1 1 0 0 1 On / Off LimitIpmOrMotorTemp Status [6:6] 1 1 0 0 1 On / Off LimitReserved Status [7:15] 9 1 0 0 511 On / Off ErrorHardwareOverCurrent Status [16:16] 1 1 0 0 1 On / Off ErrorSoftwareOverCurrent Status [17:17] 1 1 0 0 1 On / Off ErrorDcBusOverVoltage Status [18:18] 1 1 0 0 1 On / Off ErrorBadMotorPositionHallSeq Status [19:19] 1 1 0 0 1 On / Off ErrorWatchdogCausedLastReset Status [20:20] 1 1 0 0 1 On / Off ErrorConfigRead Status [21:21] 1 1 0 0 1 On / Off Error15vRailUnderVoltage Status [22:22] 1 1 0 0 1 On / Off ErrorDesaturationFault Status [23:23] 1 1 0 0 1 On / Off ErrorMotorOverSpeed Status [24:24] 1 1 0 0 1 On / Off ErrorReserved Status [25:31] 7 1 0 None None On / Off ActiveMotor Status [32:47] 16 1 0 None None TxErrorCount Status [48:55] 8 1 0 None None RxErrorCount Status [56:63] 8 1 0 None None BusVoltage BusMeasurement [0:31] 32 1 0 0 100 V BusCurrent BusMeasurement [32:63] 32 1 0 0 1000 A MotorVelocity VelocityMeasurement [0:31] 32 1 0 None None rpm VehicleVelocity VelocityMeasurement [32:63] 32 2.237 0 None None mph PhaseCurrentB PhaseCurrentMeasurement [0:31] 32 1 0 None None A_rms PhaseCurrentC PhaseCurrentMeasurement [32:63] 32 1 0 None None A_rms Vq MotorVoltageVectorMeasurement [0:31] 32 1 0 None None V Vd MotorVoltageVectorMeasurement [32:63] 32 1 0 None None V Iq MotorCurrentVectorMeasurement [0:31] 32 1 0 None None A Id MotorCurrentVectorMeasurement [32:63] 32 1 0 None None A BEMFq BackEMFMeasurementPrediction [0:31] 32 1 0 None None V BEMFd BackEMFMeasurementPrediction [32:63] 32 1 0 None None V ReservedSupply15V VoltageRail15VMeasurement [0:31] 32 1 0 None None Supply15V VoltageRail15VMeasurement [32:63] 32 1 0 None None V Supply1V9 VoltageRail3V31V9Measurement [0:31] 32 1 0 None None V Supply3V3 VoltageRail3V31V9Measurement [32:63] 32 1 0 None None V Reserved0A0 Reserved0A [0:31] 32 1 0 None None Reserved0A1 Reserved0A [32:63] 32 1 0 None None MotorTemp HeatsinkMotorTempMeasurement [0:31] 32 1 0 None None C HeatsinkTemp HeatsinkMotorTempMeasurement [32:63] 32 1 0 None None C DspBoardTemp DspBoardTempMeasurement [0:31] 32 1 0 None None C ReservedDspBoardTemp DspBoardTempMeasurement [32:63] 32 1 0 None None Reserved0D0 Reserved0D [0:31] 32 1 0 None None Reserved0D1 Reserved0D [32:63] 32 1 0 None None Odometer OdometerBusAhMeasurement [0:31] 32 1 0 None None m DCBusAh OdometerBusAhMeasurement [32:63] 32 1 0 None None Ah SlipSpeed SlipSpeedMeasurement [0:31] 32 1 0 None None Hz ReservedSlipSpeed SlipSpeedMeasurement [32:63] 32 1 0 None None"},{"location":"DBC/#tpee_mpptadbc","title":"tpee_mppt[A].dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_4","title":"Messages","text":"ID Name DLC Signals 0x201 MPPT_32_0_Status 5 MPPT_Mode, MPPT_Fault, MPPT_Enabled, MPPT_AmbientTemperature, MPPT_HeatsinkTemperature 0x200 MPPT_32_0_Power 8 MPPT_Vin, MPPT_Iin, MPPT_Vout, MPPT_Iout 0x209 MPPT_32_0_SetMode 1 Boost_Enable"},{"location":"DBC/#signals_4","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit MPPT_Mode MPPT_32_0_Status [0:7] 8 1 0 None None MPPT_Fault MPPT_32_0_Status [8:15] 8 1 0 None None MPPT_Enabled MPPT_32_0_Status [16:23] 8 1 0 None None MPPT_AmbientTemperature MPPT_32_0_Status [31:38] 8 1 0 -128 127 C MPPT_HeatsinkTemperature MPPT_32_0_Status [39:46] 8 1 0 -128 127 C MPPT_Vin MPPT_32_0_Power [7:22] 16 0.01 0 -327.68 327.67 V MPPT_Iin MPPT_32_0_Power [23:38] 16 0.0005 0 -16.384 16.3835 A MPPT_Vout MPPT_32_0_Power [39:54] 16 0.01 0 -327.68 327.67 V MPPT_Iout MPPT_32_0_Power [55:70] 16 0.0005 0 None None A Boost_Enable MPPT_32_0_SetMode [0:0] 1 1 0 0 1"},{"location":"DBC/#tpee_mpptbdbc","title":"tpee_mppt[B].dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_5","title":"Messages","text":"ID Name DLC Signals 0x211 MPPT_33_0_Status 5 MPPT_Mode, MPPT_Fault, MPPT_Enabled, MPPT_AmbientTemperature, MPPT_HeatsinkTemperature 0x210 MPPT_33_0_Power 8 MPPT_Vin, MPPT_Iin, MPPT_Vout, MPPT_Iout 0x219 MPPT_33_0_SetMode 1 Boost_Enable"},{"location":"DBC/#signals_5","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit MPPT_Mode MPPT_33_0_Status [0:7] 8 1 0 None None MPPT_Fault MPPT_33_0_Status [8:15] 8 1 0 None None MPPT_Enabled MPPT_33_0_Status [16:23] 8 1 0 None None MPPT_AmbientTemperature MPPT_33_0_Status [31:38] 8 1 0 -128 127 C MPPT_HeatsinkTemperature MPPT_33_0_Status [39:46] 8 1 0 -128 127 C MPPT_Vin MPPT_33_0_Power [7:22] 16 0.01 0 -327.68 327.67 V MPPT_Iin MPPT_33_0_Power [23:38] 16 0.0005 0 -16.384 16.3835 A MPPT_Vout MPPT_33_0_Power [39:54] 16 0.01 0 -327.68 327.67 V MPPT_Iout MPPT_33_0_Power [55:70] 16 0.0005 0 None None A Boost_Enable MPPT_33_0_SetMode [0:0] 1 1 0 0 1"},{"location":"Installation/","title":"Installation Instructions","text":"<p>Development for Embedded-Sharepoint requires a linux-based environment. Running linux natively yields the best results, but there are workarounds through UTM virtual machine on Mac OS or Windows Subsystem for Linux (WSL) on Windows.  </p> <p>Please ensure you've done the following before moving on: 1. Follow the instructions here to create your github SSH key 2. Install Visual Studio Code</p>"},{"location":"Installation/#linux","title":"Linux","text":"<p>Thanks for making our lives easy :) </p> <ol> <li>Follow the instructions here to create your github SSH key</li> <li>Run the steps in Nix next</li> </ol>"},{"location":"Installation/#windows","title":"Windows","text":""},{"location":"Installation/#windows-subsystem-for-linux-wsl","title":"Windows Subsystem for Linux (WSL)","text":"<p>Windows Subsystem for Linux allows you to run a linux terminal on your windows machine. We specifically use WSL2 since it allows USB passthrough for flashing our microcontrollers. To install WSL follow this guide. Make sure to install WSL2 and not WSL1. It will take time to fully install it, but once installed you can open WSL and it will ask you to create a username and password.</p>"},{"location":"Installation/#usbipd","title":"USBIPD","text":"<p>In order to see a USB device in WSL, we need to pass access of a USB device from windows to WSL. You can do this through USBIPD. In an administrator Powershell terminal run:</p> <pre><code>winget install usbipd\n</code></pre>"},{"location":"Installation/#mac","title":"Mac","text":"<p>To develop on a Mac we will use UTM, which is an apple application to emulate other operating systems. The following instructions have been tested on an M2 Macbook.</p>"},{"location":"Installation/#utm","title":"UTM","text":""},{"location":"Installation/#download","title":"Download","text":"<p>Download the UTM app here.  Download Ubuntu 24 here. </p>"},{"location":"Installation/#configuring-utm","title":"Configuring UTM","text":"<p>Next we will use the Ubuntu iso image we just downloaded to create a new Ubuntu VM</p> <ol> <li>Open UTM and click on Create a New Virtual Machine.</li> <li>Select Virtualize and then choose Linux.</li> <li>Press browse and select the downloaded ARM-based ISO file.</li> <li>Adjust hardware settings:<ul> <li>Memory: Default is 4000 MB (adjust based on Mac capacity).</li> <li>Storage: Default is 64 GB (adjust as necessary).</li> </ul> </li> <li>No shared directory necessary so press Continue here</li> <li>Name the VM (e.g., Ubuntu 24.04 LTS).</li> <li>Click Save to create the VM.</li> </ol>"},{"location":"Installation/#configuring-ssh","title":"Configuring SSH","text":"<p>The Ubuntu VM we created is pretty slow and can't run graphical applications easily, so it'll be hard to develop code here. What we will do instead is SSH into the VM we created from regular MacOS so we can develop our linux code while also being in MacOS.  </p> <p>Open the Ubuntu VM and run <code>hostname -I</code> This will output your Ubuntu VM's IP address to SSH into.  </p> <p>Open Visual Studio Code in MacOS.  Install the folowing extensions from the extensions marketplace:  </p> <ol> <li>In VSCode press <code>command + shift + p</code></li> <li>Type Remote-SSH: Open SSH Configuration File</li> <li>Select the one that's in /.ssh/config</li> <li>This file contains all your possible SSH targets, we will add the Ubuntu VM as an SSH target. Type this into your ssh config and the IP address of your VM you got earlier.</li> </ol> <pre><code>Host [Name of SSH, can be anything]\nHostName [IP Address]\nUser [Your user name]\n</code></pre> <p>For example mine could be: </p> <pre><code>Host Ubuntu-UTM-VM\nHostName 192.169.42.0\nUser laksh \n</code></pre> <ol> <li>Press <code>command + shift + p</code> and type Remote-SSH: Connect to Host</li> <li>Select the hostname you just added</li> <li>Congrats! You are now SSH'd into your Ubuntu VM. </li> </ol> <p>Run the steps in Nix next</p>"},{"location":"Installation/#nix","title":"Nix","text":"<p>Nix is a package manger that lets you write out all the packages you want to install in a human readable format. This simplifies development since I can write out a list of dependencies needed to compile. Run the following scripts in your linux terminal: Make the nix_install script runnable</p> <pre><code>chmod +x ./nix_install.sh\n</code></pre> <p>Run the script to install the needed nix dependencies</p> <pre><code>./nix_install.sh\n</code></pre> <p>Enter the nix shell and download dependencies for Embedded-Sharepoint</p> <pre><code>nix develop\n</code></pre> <p>In this nix shell all the dependencies needed for Embedded-Sharepoint should be installed, anytime you want to develop code you will need to run nix develop.</p>"},{"location":"BSP/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct recv_entry_t </li> <li>struct rx_payload_t </li> <li>struct tx_payload_t </li> </ul>"},{"location":"BSP/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir bsp <ul> <li>dir Inc <ul> <li>file ADC.h </li> <li>file CAN.h </li> <li>file UART.h </li> </ul> </li> <li>dir Src <ul> <li>file ADC.c </li> <li>file CAN.c </li> <li>file UART.c </li> </ul> </li> </ul> </li> </ul>"},{"location":"BSP/structrecv__entry__t/","title":"Struct recv_entry_t","text":"<p>ClassList &gt; recv_entry_t</p>"},{"location":"BSP/structrecv__entry__t/#public-attributes","title":"Public Attributes","text":"Type Name StaticQueue_t buffer bool circular uint16_t id QueueHandle_t queue uint16_t size uint8_t * storage"},{"location":"BSP/structrecv__entry__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BSP/structrecv__entry__t/#variable-buffer","title":"variable buffer","text":"<pre><code>StaticQueue_t recv_entry_t::buffer;\n</code></pre>"},{"location":"BSP/structrecv__entry__t/#variable-circular","title":"variable circular","text":"<pre><code>bool recv_entry_t::circular;\n</code></pre>"},{"location":"BSP/structrecv__entry__t/#variable-id","title":"variable id","text":"<pre><code>uint16_t recv_entry_t::id;\n</code></pre>"},{"location":"BSP/structrecv__entry__t/#variable-queue","title":"variable queue","text":"<pre><code>QueueHandle_t recv_entry_t::queue;\n</code></pre>"},{"location":"BSP/structrecv__entry__t/#variable-size","title":"variable size","text":"<pre><code>uint16_t recv_entry_t::size;\n</code></pre>"},{"location":"BSP/structrecv__entry__t/#variable-storage","title":"variable storage","text":"<pre><code>uint8_t* recv_entry_t::storage;\n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Src/CAN.c</code></p>"},{"location":"BSP/structrx__payload__t/","title":"Struct rx_payload_t","text":"<p>ClassList &gt; rx_payload_t</p>"},{"location":"BSP/structrx__payload__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t data CAN_RxHeaderTypeDef header"},{"location":"BSP/structrx__payload__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BSP/structrx__payload__t/#variable-data","title":"variable data","text":"<pre><code>uint8_t rx_payload_t::data;\n</code></pre>"},{"location":"BSP/structrx__payload__t/#variable-header","title":"variable header","text":"<pre><code>CAN_RxHeaderTypeDef rx_payload_t::header;\n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Src/CAN.c</code></p>"},{"location":"BSP/structtx__payload__t/","title":"Struct tx_payload_t","text":"<p>ClassList &gt; tx_payload_t</p>"},{"location":"BSP/structtx__payload__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t data CAN_TxHeaderTypeDef header"},{"location":"BSP/structtx__payload__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BSP/structtx__payload__t/#variable-data","title":"variable data","text":"<pre><code>uint8_t tx_payload_t::data;\n</code></pre>"},{"location":"BSP/structtx__payload__t/#variable-header","title":"variable header","text":"<pre><code>CAN_TxHeaderTypeDef tx_payload_t::header;\n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Src/CAN.c</code></p>"},{"location":"BSP/dir_3c5459f7c179b79c90e2565474bb2856/","title":"Dir bsp","text":"<p>FileList &gt; bsp</p>"},{"location":"BSP/dir_3c5459f7c179b79c90e2565474bb2856/#directories","title":"Directories","text":"Type Name dir Inc dir Src <p>The documentation for this class was generated from the following file <code>bsp/</code></p>"},{"location":"BSP/dir_f9758a777e5683291000913d5e959461/","title":"Dir bsp/Inc","text":"<p>FileList &gt; bsp &gt; Inc</p>"},{"location":"BSP/dir_f9758a777e5683291000913d5e959461/#files","title":"Files","text":"Type Name file ADC.h file CAN.h file UART.h <p>The documentation for this class was generated from the following file <code>bsp/Inc/</code></p>"},{"location":"BSP/_a_d_c_8h/","title":"File ADC.h","text":"<p>FileList &gt; bsp &gt; Inc &gt; ADC.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"stm32xx_hal.h\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"queue.h\"</code></li> <li><code>#include \"semphr.h\"</code></li> </ul>"},{"location":"BSP/_a_d_c_8h/#public-types","title":"Public Types","text":"Type Name enum adc_status_t File that shows how to initialize and read from ADCs using static queues and FreeRTOS tasks."},{"location":"BSP/_a_d_c_8h/#public-functions","title":"Public Functions","text":"Type Name adc_status_t adc_deinit (ADC_HandleTypeDef * h)  adc_status_t adc_init (ADC_InitTypeDef init, ADC_HandleTypeDef * hadc)  adc_status_t adc_read (uint32_t channel, uint32_t samplingTime, ADC_HandleTypeDef * h, QueueHandle_t * q)"},{"location":"BSP/_a_d_c_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"BSP/_a_d_c_8h/#enum-adc_status_t","title":"enum adc_status_t","text":"<p>File that shows how to initialize and read from ADCs using static queues and FreeRTOS tasks. </p> <pre><code>enum adc_status_t {\n    ADC_OK,\n    ADC_INIT_FAIL,\n    ADC_DEINIT_FAIL,\n    ADC_CHANNEL_CONFIG_FAIL,\n    ADC_INTERRUPT_BUSY,\n    ADC_INTERRUPT_TIMEOUT,\n    ADC_INTERRUPT_ERROR,\n    ADC_QUEUE_FULL\n};\n</code></pre>"},{"location":"BSP/_a_d_c_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/_a_d_c_8h/#function-adc_deinit","title":"function adc_deinit","text":"<pre><code>adc_status_t adc_deinit (\n    ADC_HandleTypeDef * h\n) \n</code></pre> <p>channel uint32_t channel to read samplingTime uint32_t ADC sampling time blocking bool whether the process is blocking </p>"},{"location":"BSP/_a_d_c_8h/#function-adc_init","title":"function adc_init","text":"<pre><code>adc_status_t adc_init (\n    ADC_InitTypeDef init,\n    ADC_HandleTypeDef * hadc\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8h/#function-adc_read","title":"function adc_read","text":"<pre><code>adc_status_t adc_read (\n    uint32_t channel,\n    uint32_t samplingTime,\n    ADC_HandleTypeDef * h,\n    QueueHandle_t * q\n) \n</code></pre> <p>init ADC_InitTypeDef bitNum uint8_t number of bits in ADC Vcc double rxQueue QueueHandle_t pointer to user-provided Queue handle </p> <p>The documentation for this class was generated from the following file <code>bsp/Inc/ADC.h</code></p>"},{"location":"BSP/_a_d_c_8h_source/","title":"File ADC.h","text":"<p>File List &gt; bsp &gt; Inc &gt; ADC.h</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#ifndef _ADC_H\n#define _ADC_H\n\n#include \"stm32xx_hal.h\"\n\n#include \"FreeRTOS.h\"\n#include \"queue.h\"\n#include \"semphr.h\"\n\ntypedef enum {\n    ADC_OK,\n    ADC_INIT_FAIL,\n    ADC_DEINIT_FAIL,\n    ADC_CHANNEL_CONFIG_FAIL,\n    ADC_INTERRUPT_BUSY,\n    ADC_INTERRUPT_TIMEOUT,\n    ADC_INTERRUPT_ERROR,\n    ADC_QUEUE_FULL,\n\n} adc_status_t;\n\n#ifdef ADC1\nextern ADC_HandleTypeDef* hadc1;\n#endif /* ADC1 */\n#ifdef ADC2\nextern ADC_HandleTypeDef* hadc2;\n#endif /* ADC2 */\n#ifdef ADC3\nextern ADC_HandleTypeDef* hadc3;\n#endif /* ADC3 */\n\nadc_status_t adc_init(ADC_InitTypeDef init, ADC_HandleTypeDef* hadc);\n\n\nadc_status_t adc_read(uint32_t channel, uint32_t samplingTime, ADC_HandleTypeDef *h, QueueHandle_t *q); \n\nadc_status_t adc_deinit(ADC_HandleTypeDef *h);\n\n#endif\n</code></pre>"},{"location":"BSP/_c_a_n_8h/","title":"File CAN.h","text":"<p>FileList &gt; bsp &gt; Inc &gt; CAN.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"stm32xx_hal.h\"</code></li> </ul>"},{"location":"BSP/_c_a_n_8h/#public-types","title":"Public Types","text":"Type Name enum can_status_t"},{"location":"BSP/_c_a_n_8h/#public-functions","title":"Public Functions","text":"Type Name can_status_t can_deinit (CAN_HandleTypeDef * handle)  can_status_t can_init (CAN_HandleTypeDef * handle, CAN_FilterTypeDef * filter)  can_status_t can_recv (CAN_HandleTypeDef * handle, uint16_t id, CAN_RxHeaderTypeDef * header, uint8_t data, TickType_t delay_ticks)  can_status_t can_send (CAN_HandleTypeDef * handle, const CAN_TxHeaderTypeDef * header, const uint8_t data, TickType_t delay_ticks)  can_status_t can_start (CAN_HandleTypeDef * handle)  can_status_t can_stop (CAN_HandleTypeDef * handle)"},{"location":"BSP/_c_a_n_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"BSP/_c_a_n_8h/#enum-can_status_t","title":"enum can_status_t","text":"<pre><code>enum can_status_t {\n    CAN_ERR,\n    CAN_OK,\n    CAN_SENT,\n    CAN_RECV,\n    CAN_EMPTY\n};\n</code></pre>"},{"location":"BSP/_c_a_n_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/_c_a_n_8h/#function-can_deinit","title":"function can_deinit","text":"<pre><code>can_status_t can_deinit (\n    CAN_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8h/#function-can_init","title":"function can_init","text":"<pre><code>can_status_t can_init (\n    CAN_HandleTypeDef * handle,\n    CAN_FilterTypeDef * filter\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8h/#function-can_recv","title":"function can_recv","text":"<pre><code>can_status_t can_recv (\n    CAN_HandleTypeDef * handle,\n    uint16_t id,\n    CAN_RxHeaderTypeDef * header,\n    uint8_t data,\n    TickType_t delay_ticks\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8h/#function-can_send","title":"function can_send","text":"<pre><code>can_status_t can_send (\n    CAN_HandleTypeDef * handle,\n    const CAN_TxHeaderTypeDef * header,\n    const uint8_t data,\n    TickType_t delay_ticks\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8h/#function-can_start","title":"function can_start","text":"<pre><code>can_status_t can_start (\n    CAN_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8h/#function-can_stop","title":"function can_stop","text":"<pre><code>can_status_t can_stop (\n    CAN_HandleTypeDef * handle\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Inc/CAN.h</code></p>"},{"location":"BSP/_c_a_n_8h_source/","title":"File CAN.h","text":"<p>File List &gt; bsp &gt; Inc &gt; CAN.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef CAN_H\n#define CAN_H\n\n#include \"stm32xx_hal.h\"\n\n#if !defined(CAN1)\n  #error \"[CONFIG] CAN not enabled on this chip.\"\n#endif /* CAN1 */\n\n/* Function Descriptions:\n * Init initializes the CAN peripheral given the configuration\n (does not start the CAN peripheral)\n * DeInit deinitlaizes the CAN peripheral meaning the configuration is\n reset (default values)\n * Start starts the CAN peripheral meaning it is able to interrupt\n and act on messages\n * Stop stops the CAN peripheral meaning the configuration is unchanged\n but the peripheral cannot interrupt or act on messages\n * Send readies the message to be sent when the CAN peripheral has\n a chance to send it (puts it into a queue)\n * Recv reads a message (reads from a queue depending on ID)\n *\n * How to Use This Driver:\n * Init to initialize the CAN peripheral\n * Start to activate the CAN peripheral\n * Send, Recv, Stop, Start\n * DeInit to deinitialize\n * Init ...\n *\n * Notes for usage:\n * CAN2 is usually a slave CAN, meaning that it shares\n transistors with CAN1, meaning for CAN2 to work, CAN1\n must be initialized. Thus, make sure CAN1 is initialized\n before CAN2 is initialized.\n * CAN2 usually shares the filter banks with CAN1, since it\n is a slave CAN. Thus, consider the filter configs you pass\n to the can_init function, when initializing CAN1 and CAN2.\n * CAN3 is usually a master CAN, meaning you don't have to \n worry about sharing.\n * This driver uses a macro to define which entries a CAN\n interface should recieve on. Look at can1_recv_entries.h\n for an example. Make sure these entries line up with the\n filter config.\n */\n\n// return code for can driver\ntypedef enum {\n    CAN_ERR,   // unsuccessful operation\n    CAN_OK,\n    CAN_SENT,  // successful send\n    CAN_RECV,  // successful recieve\n    CAN_EMPTY, // recieved nothing with no errors\n} can_status_t;\n\n// can handlers\n#ifdef CAN1\nextern CAN_HandleTypeDef* hcan1;\n#endif /* CAN1 */\n\n#ifdef CAN2\nextern CAN_HandleTypeDef* hcan2;\n#endif /* CAN2 */\n\n#ifdef CAN3\nextern CAN_HandleTypeDef* hcan3;\n#endif /* CAN3 */\n\ncan_status_t can_init(CAN_HandleTypeDef* handle, CAN_FilterTypeDef* filter);\ncan_status_t can_deinit(CAN_HandleTypeDef* handle);\ncan_status_t can_start(CAN_HandleTypeDef* handle);\ncan_status_t can_stop(CAN_HandleTypeDef* handle);\ncan_status_t can_send(CAN_HandleTypeDef* handle, const CAN_TxHeaderTypeDef* header, const uint8_t data[], TickType_t delay_ticks);\ncan_status_t can_recv(CAN_HandleTypeDef* handle, uint16_t id, CAN_RxHeaderTypeDef* header, uint8_t data[], TickType_t delay_ticks);\n\n#endif /* CAN_H */\n</code></pre>"},{"location":"BSP/_u_a_r_t_8h/","title":"File UART.h","text":"<p>FileList &gt; bsp &gt; Inc &gt; UART.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"stm32xx_hal.h\"</code></li> </ul>"},{"location":"BSP/_u_a_r_t_8h/#public-types","title":"Public Types","text":"Type Name enum uart_status_t"},{"location":"BSP/_u_a_r_t_8h/#public-functions","title":"Public Functions","text":"Type Name uart_status_t uart_deinit (UART_HandleTypeDef * handle) Deinitializes the UART peripheral. uart_status_t uart_init (UART_HandleTypeDef * handle) Initializes the UART peripheral. uart_status_t uart_recv (UART_HandleTypeDef * handle, uint8_t * data, uint8_t length, TickType_t delay_ticks) Reads data from the user-provided RX queue. uart_status_t uart_send (UART_HandleTypeDef * handle, const uint8_t * data, uint8_t length, TickType_t delay_ticks) Transmits data over UART. If transmission is in progress, data will be queued in internal TX queue."},{"location":"BSP/_u_a_r_t_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"BSP/_u_a_r_t_8h/#enum-uart_status_t","title":"enum uart_status_t","text":"<pre><code>enum uart_status_t {\n    UART_ERR,\n    UART_OK,\n    UART_SENT,\n    UART_RECV,\n    UART_EMPTY\n};\n</code></pre>"},{"location":"BSP/_u_a_r_t_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/_u_a_r_t_8h/#function-uart_deinit","title":"function uart_deinit","text":"<p>Deinitializes the UART peripheral. </p> <pre><code>uart_status_t uart_deinit (\n    UART_HandleTypeDef * handle\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>handle</code> pointer to the UART handle </li> </ul> <p>Returns:</p> <p>uart_status_t </p>"},{"location":"BSP/_u_a_r_t_8h/#function-uart_init","title":"function uart_init","text":"<p>Initializes the UART peripheral. </p> <pre><code>uart_status_t uart_init (\n    UART_HandleTypeDef * handle\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>handle</code> pointer to the UART handle </li> </ul> <p>Returns:</p> <p>uart_status_t </p>"},{"location":"BSP/_u_a_r_t_8h/#function-uart_recv","title":"function uart_recv","text":"<p>Reads data from the user-provided RX queue. </p> <pre><code>uart_status_t uart_recv (\n    UART_HandleTypeDef * handle,\n    uint8_t * data,\n    uint8_t length,\n    TickType_t delay_ticks\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>huart</code> pointer to the UART handle </li> <li><code>data</code> pointer to the data buffer that will be read into </li> <li><code>length</code> of the buffer that will be read </li> <li><code>delay_ticks</code> number of ticks to wait for data to be received </li> </ul> <p>Returns:</p> <p>uart_status_t </p>"},{"location":"BSP/_u_a_r_t_8h/#function-uart_send","title":"function uart_send","text":"<p>Transmits data over UART. If transmission is in progress, data will be queued in internal TX queue. </p> <pre><code>uart_status_t uart_send (\n    UART_HandleTypeDef * handle,\n    const uint8_t * data,\n    uint8_t length,\n    TickType_t delay_ticks\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>data</code> pointer to the data buffer that will be written/transmitted </li> <li><code>length</code> of the buffer that will be written/transmitted </li> <li><code>delay_ticks</code> number of ticks to wait for data to be transmitted </li> </ul> <p>Returns:</p> <p>uart_status_t </p> <p>The documentation for this class was generated from the following file <code>bsp/Inc/UART.h</code></p>"},{"location":"BSP/_u_a_r_t_8h_source/","title":"File UART.h","text":"<p>File List &gt; bsp &gt; Inc &gt; UART.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef UART_H_\n#define UART_H_\n\n#include \"stm32xx_hal.h\"\n\n#if !defined(UART4) &amp;&amp; !defined(USART1)\n  #error \"[CONFIG] UART not enabled on this chip.\"\n#endif /* UART4 */\n\n/* Function Descriptions:\n * Init initializes the UART peripheral given the configuration\n * DeInit deinitializes the UART peripheral meaning the configuration is reset\n * Send queues data to be transmitted when the UART peripheral is available\n * Recv reads length bytes of received data from the RX queue\n *\n * How to Use This Driver:\n * 1. uart_init to initialize the UART peripheral\n * 2. uart_send/uart_recv operations\n * 3. uart_deinit to deinitialize\n * \n * - The function HAL_UART_MspGPIOInit and HAL_UART_MspGPIODeInit must be overriden with the user's implementation of initializing/deinitializing the GPIO pins for the selected peripheral. This includes initializing the GPIO Clk and claling HAL_GPIO_Init on the correct GPIO_InitTypeDef structure.\n * - For now, a UART peripheral needs to be contained to one task as only one receive queue exists for each.\n *\n */\n\n// Return codes for UART operations\ntypedef enum {\n    UART_ERR,\n    UART_OK,\n    UART_SENT,\n    UART_RECV,\n    UART_EMPTY,\n} uart_status_t;\n\n// uart handlers\n#ifdef UART4\nextern UART_HandleTypeDef* huart4;\n#endif /* UART4 */\n\n#ifdef UART5\nextern UART_HandleTypeDef* huart5;\n#endif /* UART5 */\n\n#ifdef USART1\nextern UART_HandleTypeDef* husart1;\n#endif /* USART1 */\n\n#ifdef USART2\nextern UART_HandleTypeDef* husart2;\n#endif /* USART2 */\n\n#ifdef USART3\nextern UART_HandleTypeDef* husart3;\n#endif /* USART3 */\n\n// Function prototypes with consistent parameters and return types\nuart_status_t uart_init(UART_HandleTypeDef* handle); // Create queue at compile time, User passes in the size of the queue they want\nuart_status_t uart_deinit(UART_HandleTypeDef* handle);\nuart_status_t uart_send(UART_HandleTypeDef* handle, const uint8_t* data, uint8_t length, TickType_t delay_ticks);\nuart_status_t uart_recv(UART_HandleTypeDef* handle, uint8_t* data, uint8_t length, TickType_t delay_ticks);\n\n#endif /* UART_H_ */\n</code></pre>"},{"location":"BSP/dir_160128b01eb7e6b2a554f83ab5d45f5a/","title":"Dir bsp/Src","text":"<p>FileList &gt; bsp &gt; Src</p>"},{"location":"BSP/dir_160128b01eb7e6b2a554f83ab5d45f5a/#files","title":"Files","text":"Type Name file ADC.c file CAN.c file UART.c <p>The documentation for this class was generated from the following file <code>bsp/Src/</code></p>"},{"location":"BSP/_a_d_c_8c/","title":"File ADC.c","text":"<p>FileList &gt; bsp &gt; Src &gt; ADC.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ADC.h\"</code></li> </ul>"},{"location":"BSP/_a_d_c_8c/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t adc_err_code   = <code>0</code>"},{"location":"BSP/_a_d_c_8c/#public-functions","title":"Public Functions","text":"Type Name void HAL_ADC_ConvCpltCallback (ADC_HandleTypeDef * h)  void HAL_ADC_ErrorCallback (ADC_HandleTypeDef * h)  void HAL_ADC_MspDeInit (ADC_HandleTypeDef * h)  __weak void HAL_ADC_MspGPIOInit ()  void HAL_ADC_MspInit (ADC_HandleTypeDef * h)  adc_status_t adc_deinit (ADC_HandleTypeDef * h)  adc_status_t adc_init (ADC_InitTypeDef init, ADC_HandleTypeDef * h)  adc_status_t adc_read (uint32_t channel, uint32_t samplingTime, ADC_HandleTypeDef * h, QueueHandle_t * q)"},{"location":"BSP/_a_d_c_8c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BSP/_a_d_c_8c/#variable-adc_err_code","title":"variable adc_err_code","text":"<pre><code>uint32_t adc_err_code;\n</code></pre>"},{"location":"BSP/_a_d_c_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/_a_d_c_8c/#function-hal_adc_convcpltcallback","title":"function HAL_ADC_ConvCpltCallback","text":"<pre><code>void HAL_ADC_ConvCpltCallback (\n    ADC_HandleTypeDef * h\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-hal_adc_errorcallback","title":"function HAL_ADC_ErrorCallback","text":"<pre><code>void HAL_ADC_ErrorCallback (\n    ADC_HandleTypeDef * h\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-hal_adc_mspdeinit","title":"function HAL_ADC_MspDeInit","text":"<pre><code>void HAL_ADC_MspDeInit (\n    ADC_HandleTypeDef * h\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-hal_adc_mspgpioinit","title":"function HAL_ADC_MspGPIOInit","text":"<pre><code>__weak void HAL_ADC_MspGPIOInit () \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-hal_adc_mspinit","title":"function HAL_ADC_MspInit","text":"<pre><code>void HAL_ADC_MspInit (\n    ADC_HandleTypeDef * h\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-adc_deinit","title":"function adc_deinit","text":"<pre><code>adc_status_t adc_deinit (\n    ADC_HandleTypeDef * h\n) \n</code></pre> <p>channel uint32_t channel to read samplingTime uint32_t ADC sampling time blocking bool whether the process is blocking </p>"},{"location":"BSP/_a_d_c_8c/#function-adc_init","title":"function adc_init","text":"<pre><code>adc_status_t adc_init (\n    ADC_InitTypeDef init,\n    ADC_HandleTypeDef * h\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-adc_read","title":"function adc_read","text":"<pre><code>adc_status_t adc_read (\n    uint32_t channel,\n    uint32_t samplingTime,\n    ADC_HandleTypeDef * h,\n    QueueHandle_t * q\n) \n</code></pre> <p>init ADC_InitTypeDef bitNum uint8_t number of bits in ADC Vcc double rxQueue QueueHandle_t pointer to user-provided Queue handle </p> <p>The documentation for this class was generated from the following file <code>bsp/Src/ADC.c</code></p>"},{"location":"BSP/_a_d_c_8c_source/","title":"File ADC.c","text":"<p>File List &gt; bsp &gt; Src &gt; ADC.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"ADC.h\"\n\n// Define Queue Handles\n#ifdef ADC1\nstatic ADC_HandleTypeDef hadc1_ = {.Instance = ADC1};\nADC_HandleTypeDef* hadc1 = &amp;hadc1_;\nQueueHandle_t* adc1_q;\n#endif\n\n#ifdef ADC2\nstatic ADC_HandleTypeDef hadc2_ = {.Instance = ADC2};\nADC_HandleTypeDef* hadc2 = &amp;hadc2_;\nQueueHandle_t* adc2_q;\n#endif\n\n#ifdef ADC3\nstatic ADC_HandleTypeDef hadc3_ = {.Instance = ADC3};\nADC_HandleTypeDef* hadc3 = &amp;hadc3_;\nQueueHandle_t* adc3_q;\n#endif\n\n#ifdef STM32F4xx\n#ifndef ADC_PRIO\n#define ADC_PRIO 5\n#endif\n#endif\n\n#ifdef STM32L4xx\n#ifndef ADC1_PRIO\n#define ADC1_PRIO 5\n#endif\n\n#ifndef ADC2_PRIO\n#define ADC2_PRIO 5\n#endif\n\n#ifndef ADC3_PRIO\n#define ADC3_PRIO 5\n#endif\n#endif\n\n// Hardware ADC error code\nuint32_t adc_err_code = 0;\n\nadc_status_t adc_init(ADC_InitTypeDef init, ADC_HandleTypeDef* h) {\n    // Initalize ADC\n    h-&gt;Init = init;\n    if (HAL_ADC_Init(h) != HAL_OK) return ADC_INIT_FAIL;\n\n    return ADC_OK;\n}\n\nadc_status_t adc_deinit(ADC_HandleTypeDef *h) {\n    // Deinit ADC at specific handle\n    if (HAL_ADC_DeInit(h) != HAL_OK) return ADC_DEINIT_FAIL;\n\n    return ADC_OK;\n} \n\n\nadc_status_t adc_read(uint32_t channel, uint32_t samplingTime, ADC_HandleTypeDef *h, QueueHandle_t *q) {\n    ADC_ChannelConfTypeDef sConfig = {\n        .Channel = channel,\n        .Rank = 1,\n        .SamplingTime = samplingTime\n    }; \n\n    // Queue Arbitration for later\n    #ifdef ADC1\n    if (h-&gt;Instance == ADC1) adc1_q = q;\n    #endif\n    #ifdef ADC2\n    if (h-&gt;Instance == ADC2) adc2_q = q;\n    #endif\n    #ifdef ADC3\n    if (h-&gt;Instance == ADC3) adc3_q = q;\n    #endif\n\n    // Check Queue Full\n    if (uxQueueSpacesAvailable(*q) == 0) {\n        return ADC_QUEUE_FULL;\n    }\n    // Configure Channel\n    if (HAL_ADC_ConfigChannel(h, &amp;sConfig) != HAL_OK) {\n        return ADC_CHANNEL_CONFIG_FAIL;\n    }\n    // Trigger Interrupt\n    HAL_StatusTypeDef adc_it_stat = HAL_ADC_Start_IT(h);\n\n    // Handling\n    switch (adc_it_stat) {\n        case HAL_BUSY:\n            return ADC_INTERRUPT_BUSY;\n            break;\n        case HAL_TIMEOUT:\n            return ADC_INTERRUPT_TIMEOUT;\n            break;\n        case HAL_ERROR:\n            return ADC_INTERRUPT_ERROR;\n            break;\n        default: break;\n    }\n\n    return ADC_OK; \n}\n\n\nvoid HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *h) {\n    /*\n    Interrupt triggers this callback when the conversion is complete\n    */ \n    BaseType_t higherPriorityTaskWoken = pdFALSE;\n    QueueHandle_t* q = NULL; // Queue will never be null by the call [placeholder]\n    int rawVal;\n\n    if (h-&gt;Instance == ADC1) q = adc1_q;\n    #ifdef ADC2\n    if (h-&gt;Instance == ADC2) q = adc2_q;\n    #endif\n    #ifdef ADC3\n    if (h-&gt;Instance == ADC3) q = adc3_q;\n    #endif\n\n    rawVal = HAL_ADC_GetValue(h);\n    xQueueSendFromISR(*q, &amp;rawVal, &amp;higherPriorityTaskWoken);\n\n    portYIELD_FROM_ISR(higherPriorityTaskWoken);\n}\n\n__weak void HAL_ADC_MspGPIOInit() {\n    // GPIO --- Instanstiate PA3\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    GPIO_InitTypeDef input =  {\n        .Pin = GPIO_PIN_3,\n        .Mode = GPIO_MODE_ANALOG,\n        .Pull = GPIO_NOPULL,\n    };\n\n    HAL_GPIO_Init(GPIOA, &amp;input);\n}\n\n#if defined(STM32L4xx)\nstatic inline void HAL_ADC_MspL4Init(ADC_HandleTypeDef *h) {\n    HAL_ADC_MspGPIOInit();\n\n    // L4 Clock\n    __HAL_RCC_ADC_CLK_ENABLE();\n\n    // L4 w/ one ADC\n    #if !defined(ADC2) &amp;&amp; !defined(ADC3)\n    HAL_NVIC_SetPriority(ADC1_IRQn, ADC1_PRIO, 0);\n    HAL_NVIC_EnableIRQ(ADC1_IRQn);\n\n    // L4 w/ more than one ADC\n    #elif defined(ADC2)\n    HAL_NVIC_SetPriority(ADC1_2_IRQn, ADC2_PRIO, 0);\n    HAL_NVIC_EnableIRQ(ADC1_2_IRQn);\n\n    // L4 w/ more than one ADC\n    #elif defined(ADC3)\n    HAL_NVIC_SetPriority(ADC3_IRQn, ADC3_PRIO, 0);\n    HAL_NVIC_EnableIRQ(ADC3_IRQn);\n\n    #endif\n}\n#endif\n\n#if defined(STM32F4xx)\nstatic inline void HAL_ADC_MspF4Init(ADC_HandleTypeDef *h) {\n    // GPIO Init\n    HAL_ADC_MspGPIOInit();\n\n    // F4 Clock\n    if (h-&gt;Instance == ADC1) __HAL_RCC_ADC1_CLK_ENABLE();\n\n    #ifdef ADC2\n    if (h-&gt;Instance == ADC2) __HAL_RCC_ADC2_CLK_ENABLE();\n    #endif\n\n    #ifdef ADC3\n    if (h-&gt;Instance == ADC3)__HAL_RCC_ADC3_CLK_ENABLE();\n    #endif\n\n    HAL_NVIC_SetPriority(ADC_IRQn, ADC_PRIO, 0);\n    HAL_NVIC_EnableIRQ(ADC_IRQn);\n}\n#endif\n\n#if defined(STM32L4xx)\nstatic inline void HAL_ADC_MspL4DeInit(ADC_HandleTypeDef *h) {\n    // GPIO Init\n\n\n    // L4 Clock\n    __HAL_RCC_ADC_CLK_DISABLE();\n\n    // L4 w/ one ADC\n    #if !defined(ADC2) &amp;&amp; !defined(ADC3)\n    HAL_NVIC_DisableIRQ(ADC1_IRQn);\n\n    // L4 w/ more than one ADC\n    #elif defined(ADC2)\n    HAL_NVIC_DisableIRQ(ADC1_2_IRQn);\n\n    // L4 w/ more than one ADC\n    #elif defined(ADC3)\n    HAL_NVIC_DisableIRQ(ADC3_IRQn);\n\n    #endif\n}\n#endif\n\n#if defined(STM32F4xx)\nstatic inline void HAL_ADC_MspF4DeInit(ADC_HandleTypeDef *h) {\n    if (h-&gt;Instance == ADC1) __HAL_RCC_ADC1_CLK_DISABLE();\n\n    #ifdef ADC2\n    if (h-&gt;Instance == ADC2) __HAL_RCC_ADC2_CLK_DISABLE();\n    #endif\n\n    #ifdef ADC3\n    if (h-&gt;Instance == ADC3)__HAL_RCC_ADC3_CLK_DISABLE();\n    #endif\n\n    HAL_NVIC_DisableIRQ(ADC_IRQn);\n}\n#endif\n\nvoid HAL_ADC_MspInit(ADC_HandleTypeDef *h) {\n    // L4\n    #ifdef STM32L4xx\n    HAL_ADC_MspL4Init(h);\n    #endif\n\n    // F4\n    #ifdef STM32F4xx\n    HAL_ADC_MspF4Init(h);\n    #endif\n}\n\nvoid HAL_ADC_MspDeInit(ADC_HandleTypeDef *h) {\n    // L4\n    #ifdef STM32L4xx\n    HAL_ADC_MspL4DeInit(h);\n    #endif\n\n    // F4\n    #ifdef STM32F4xx\n    HAL_ADC_MspF4DeInit(h);\n    #endif\n}\n\n#if defined(STM32L4xx)\n#ifdef ADC1_2_IRQHandler\nvoid ADC1_2_IRQHandler() {\n    if (ADC_FLAG_EOC &amp; ADC1-&gt;ISR) {\n        HAL_ADC_IRQHandler(hadc1);\n    }\n    #ifdef ADC2\n    else if (ADC_FLAG_EOC &amp; ADC2-&gt;ISR) {\n        HAL_ADC_IRQHandler(hadc2);\n    }\n    #endif\n}\n#endif\n\n#ifdef ADC1_IRQHandler\nvoid ADC1_IRQHandler() {\n    // L4 IRQ Handler\n\n    if (ADC_FLAG_EOC &amp; ADC1-&gt;ISR) {\n        HAL_ADC_IRQHandler(hadc1);\n    }\n}\n#endif\n\n#ifdef ADC3\nvoid ADC3_IRQHandler() {\n    if (ADC_FLAG_EOC &amp; ADC3-&gt;ISR) {\n        HAL_ADC_IRQHandler(hadc3);\n    }\n}\n#endif\n#endif\n\n#if defined(STM32F4xx)\nvoid ADC_IRQHandler() {\n    // F4 IRQ Handler \n\n    if (ADC_FLAG_EOC &amp; ADC1-&gt;SR) {\n        HAL_ADC_IRQHandler(hadc1);\n    }\n    #ifdef ADC2\n    else if (ADC_FLAG_EOC &amp; ADC2-&gt;SR) {\n        HAL_ADC_IRQHandler(hadc2);\n    }\n    #endif\n    #ifdef ADC3\n    if (ADC_FLAG_EOC &amp; ADC3-&gt;SR) {\n        HAL_ADC_IRQHandler(hadc3);\n    }\n    #endif\n}\n#endif\n\nvoid HAL_ADC_ErrorCallback(ADC_HandleTypeDef *h) {\n    adc_err_code = HAL_ADC_GetError(h);\n\n    // retry \n    HAL_ADC_Stop_IT(h);\n    HAL_ADC_Start_IT(h);\n}\n</code></pre>"},{"location":"BSP/_c_a_n_8c/","title":"File CAN.c","text":"<p>FileList &gt; bsp &gt; Src &gt; CAN.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CAN.h\"</code></li> <li><code>#include \"queue_ex.h\"</code></li> </ul>"},{"location":"BSP/_c_a_n_8c/#classes","title":"Classes","text":"Type Name struct recv_entry_t struct rx_payload_t struct tx_payload_t"},{"location":"BSP/_c_a_n_8c/#public-functions","title":"Public Functions","text":"Type Name void HAL_CAN_MspDeInit (CAN_HandleTypeDef * hcan)  void HAL_CAN_MspInit (CAN_HandleTypeDef * hcan)  void HAL_CAN_RxFifo0MsgPendingCallback (CAN_HandleTypeDef * hcan)  void HAL_CAN_TxMailbox0CompleteCallback (CAN_HandleTypeDef * hcan)  void HAL_CAN_TxMailbox1CompleteCallback (CAN_HandleTypeDef * hcan)  void HAL_CAN_TxMailbox2CompleteCallback (CAN_HandleTypeDef * hcan)  can_status_t can_deinit (CAN_HandleTypeDef * handle)  can_status_t can_init (CAN_HandleTypeDef * handle, CAN_FilterTypeDef * filter)  can_status_t can_recv (CAN_HandleTypeDef * handle, uint16_t id, CAN_RxHeaderTypeDef * header, uint8_t data, TickType_t delay_ticks)  can_status_t can_send (CAN_HandleTypeDef * handle, const CAN_TxHeaderTypeDef * header, const uint8_t data, TickType_t delay_ticks)  can_status_t can_start (CAN_HandleTypeDef * handle)  can_status_t can_stop (CAN_HandleTypeDef * handle)"},{"location":"BSP/_c_a_n_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name void HAL_CAN_MspF4Init (CAN_HandleTypeDef * hcan)  void HAL_CAN_MspL4Init (CAN_HandleTypeDef * hcan)  void transmit (CAN_HandleTypeDef * handle)"},{"location":"BSP/_c_a_n_8c/#macros","title":"Macros","text":"Type Name define DATA_SIZE <code>(8)</code>"},{"location":"BSP/_c_a_n_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/_c_a_n_8c/#function-hal_can_mspdeinit","title":"function HAL_CAN_MspDeInit","text":"<pre><code>void HAL_CAN_MspDeInit (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_mspinit","title":"function HAL_CAN_MspInit","text":"<pre><code>void HAL_CAN_MspInit (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_rxfifo0msgpendingcallback","title":"function HAL_CAN_RxFifo0MsgPendingCallback","text":"<pre><code>void HAL_CAN_RxFifo0MsgPendingCallback (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_txmailbox0completecallback","title":"function HAL_CAN_TxMailbox0CompleteCallback","text":"<pre><code>void HAL_CAN_TxMailbox0CompleteCallback (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_txmailbox1completecallback","title":"function HAL_CAN_TxMailbox1CompleteCallback","text":"<pre><code>void HAL_CAN_TxMailbox1CompleteCallback (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_txmailbox2completecallback","title":"function HAL_CAN_TxMailbox2CompleteCallback","text":"<pre><code>void HAL_CAN_TxMailbox2CompleteCallback (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_deinit","title":"function can_deinit","text":"<pre><code>can_status_t can_deinit (\n    CAN_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_init","title":"function can_init","text":"<pre><code>can_status_t can_init (\n    CAN_HandleTypeDef * handle,\n    CAN_FilterTypeDef * filter\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_recv","title":"function can_recv","text":"<pre><code>can_status_t can_recv (\n    CAN_HandleTypeDef * handle,\n    uint16_t id,\n    CAN_RxHeaderTypeDef * header,\n    uint8_t data,\n    TickType_t delay_ticks\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_send","title":"function can_send","text":"<pre><code>can_status_t can_send (\n    CAN_HandleTypeDef * handle,\n    const CAN_TxHeaderTypeDef * header,\n    const uint8_t data,\n    TickType_t delay_ticks\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_start","title":"function can_start","text":"<pre><code>can_status_t can_start (\n    CAN_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_stop","title":"function can_stop","text":"<pre><code>can_status_t can_stop (\n    CAN_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"BSP/_c_a_n_8c/#function-hal_can_mspf4init","title":"function HAL_CAN_MspF4Init","text":"<pre><code>static inline void HAL_CAN_MspF4Init (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_mspl4init","title":"function HAL_CAN_MspL4Init","text":"<pre><code>static inline void HAL_CAN_MspL4Init (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-transmit","title":"function transmit","text":"<pre><code>static void transmit (\n    CAN_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"BSP/_c_a_n_8c/#define-data_size","title":"define DATA_SIZE","text":"<pre><code>#define DATA_SIZE `(8)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Src/CAN.c</code></p>"},{"location":"BSP/_c_a_n_8c_source/","title":"File CAN.c","text":"<p>File List &gt; bsp &gt; Src &gt; CAN.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"CAN.h\"\n#include \"queue_ex.h\"\n\n// 8 for now unless extended payload is supported\n#define DATA_SIZE (8)\n\n// entries in queues\ntypedef struct {\n  CAN_TxHeaderTypeDef header;\n  uint8_t data[DATA_SIZE];\n} tx_payload_t;\n\ntypedef struct {\n  CAN_RxHeaderTypeDef header;\n  uint8_t data[DATA_SIZE];\n} rx_payload_t;\n\n// metadata for recieve queues\ntypedef struct {\n  uint16_t id;\n  uint16_t size;\n  QueueHandle_t queue;\n  uint8_t* storage;\n  bool circular;\n  StaticQueue_t buffer;\n} recv_entry_t;\n\n#ifdef CAN1\n// fallback can1 send queue size\n#ifndef CAN1_SEND_QUEUE_SIZE\n#define CAN1_SEND_QUEUE_SIZE (10)\n#endif\n\n// can1 handle\nstatic CAN_HandleTypeDef hcan1_ = {.Instance = CAN1};\nCAN_HandleTypeDef* hcan1 = &amp;hcan1_;\n\n// can1 send queue\nstatic QueueHandle_t can1_send_queue = NULL;\nstatic StaticQueue_t can1_send_queue_buffer;\nstatic uint8_t\n    can1_send_queue_storage[CAN1_SEND_QUEUE_SIZE * sizeof(tx_payload_t)];\n\n#if __has_include(\"can1_recv_entries.h\")\n// create can1 recv queue storage\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_) \\\n  static uint8_t can1_recv_queue_storage_##ID_[SIZE_ * sizeof(rx_payload_t)];\n\n#include \"can1_recv_entries.h\"\n\n#undef CAN_RECV_ENTRY\n\n// create can1 recv queue array\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_)      \\\n  {.id = (ID_),                         \\\n   .size = (SIZE_),                     \\\n   .queue = NULL,                       \\\n   .storage = can1_recv_queue_storage_##ID_, \\\n   .circular = (CIRCULAR_), \\\n   .buffer = {{0}}},\n\nstatic recv_entry_t can1_recv_entries[] = {\n#include \"can1_recv_entries.h\"\n};\n#undef CAN_RECV_ENTRY\n\n// calculate amount of can1 recv entries\nstatic const uint32_t can1_recv_entry_count =\n    sizeof(can1_recv_entries) / sizeof(can1_recv_entries[0]);\n\n#else /* can1_recv_entries.h */\n// create can1 recv queue array\nstatic recv_entry_t can1_recv_entries[] = {};\n// calculate amount of can1 recv entries\nstatic const uint32_t can1_recv_entry_count = 0;\n#endif /* can1_recv_entries.h */\n#endif /* CAN1 */\n\n#ifdef CAN2\n// fallback can2 send queue size\n#ifndef CAN2_SEND_QUEUE_SIZE\n#define CAN2_SEND_QUEUE_SIZE (10)\n#endif\n\n// can2 handle\nstatic CAN_HandleTypeDef hcan2_ = {.Instance = CAN2};\nCAN_HandleTypeDef* hcan2 = &amp;hcan2_;\n\n// can2 send queue\nstatic QueueHandle_t can2_send_queue = NULL;\nstatic StaticQueue_t can2_send_queue_buffer;\nstatic uint8_t\n    can2_send_queue_storage[CAN2_SEND_QUEUE_SIZE * sizeof(tx_payload_t)];\n\n#if __has_include(\"can2_recv_entries.h\")\n// create can2 recv queue storage\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_) \\\n  static uint8_t can2_recv_queue_storage_##ID_[SIZE_ * sizeof(rx_payload_t)];\n\n#include \"can2_recv_entries.h\"\n\n#undef CAN_RECV_ENTRY\n\n// create can2 recv queue array\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_)      \\\n  {.id = (ID_),                         \\\n   .size = (SIZE_),                     \\\n   .queue = NULL,                       \\\n   .storage = can2_recv_queue_storage_##ID_, \\\n   .circular = (CIRCULAR_), \\\n   .buffer = {{0}}},\n\nstatic recv_entry_t can2_recv_entries[] = {\n#include \"can2_recv_entries.h\"\n};\n#undef CAN_RECV_ENTRY\n\n// calculate amount of can2 recv entries\nstatic const uint32_t can2_recv_entry_count =\n    sizeof(can2_recv_entries) / sizeof(can2_recv_entries[0]);\n\n#else /* can2_recv_entries.h */\n// create can2 recv queue array\nstatic recv_entry_t can2_recv_entries[] = {};\n// calculate amount of can2 recv entries\nstatic const uint32_t can2_recv_entry_count = 0;\n#endif /* can2_recv_entries.h */\n#endif /* CAN2 */\n\n#ifdef CAN3\n// fallback can3 send queue size\n#ifndef CAN3_SEND_QUEUE_SIZE\n#define CAN3_SEND_QUEUE_SIZE (10)\n#endif\n\n// can3 handle\nstatic CAN_HandleTypeDef hcan3_ = {.Instance = CAN3};\nCAN_HandleTypeDef* hcan3 = &amp;hcan3_;\n\n// can3 send queue\nstatic QueueHandle_t can3_send_queue = NULL;\nstatic StaticQueue_t can3_send_queue_buffer;\nstatic uint8_t\n    can3_send_queue_storage[CAN3_SEND_QUEUE_SIZE * sizeof(tx_payload_t)];\n\n#if __has_include(\"can3_recv_entries.h\")\n// create recv queue storage\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_) \\\n  static uint8_t recv_queue_storage_##ID_[SIZE_ * sizeof(rx_payload_t)];\n\n#include \"can3_recv_entries.h\"\n\n#undef CAN_RECV_ENTRY\n\n// create can3 recv queue array\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_)      \\\n  {.id = (ID_),                         \\\n   .size = (SIZE_),                     \\\n   .queue = NULL,                       \\\n   .storage = recv_queue_storage_##ID_, \\\n   .circular = (CIRCULAR_), \\\n   .buffer = {{0}}},\n\nstatic recv_entry_t can3_recv_entries[] = {\n#include \"can3_recv_entries.h\"\n};\n#undef CAN_RECV_ENTRY\n\n// calculate amount of can3 recv entries\nstatic const uint32_t can3_recv_entry_count =\n    sizeof(can3_recv_entries) / sizeof(can3_recv_entries[0]);\n\n#else /* can3_recv_entries.h */\n// create can3 recv queue array\nstatic recv_entry_t can3_recv_entries[] = {};\n// calculate amount of can3 recv entries\nstatic const uint32_t can3_recv_entry_count = 0;\n#endif /* can3_recv_entries.h */\n#endif /* CAN3 */\n\nstatic inline void HAL_CAN_MspF4Init(CAN_HandleTypeDef* hcan){\n  GPIO_InitTypeDef init = {0};\n\n  // CAN1\n  if (hcan-&gt;Instance == CAN1) {\n    // enable clocks\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    /* enable gpio\n    PA11 -&gt; CAN1_RX\n    PA12 -&gt; CAN1_TX\n    */\n    init.Pin = GPIO_PIN_11;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_PULLUP;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN1;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n\n    init.Pin = GPIO_PIN_12;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_NOPULL;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN1;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n  }\n\n  // CAN2\n  #ifdef CAN2\n  else if (hcan-&gt;Instance == CAN2) {\n    // enable clocks\n    __HAL_RCC_GPIOB_CLK_ENABLE();\n\n    /* enable gpio\n    PB12 -&gt; CAN2_RX\n    PB13 -&gt; CAN2_TX\n    */\n    init.Pin = GPIO_PIN_12;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_PULLUP;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN2;\n    HAL_GPIO_Init(GPIOB, &amp;init);\n\n    init.Pin = GPIO_PIN_13;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_NOPULL;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN2;\n    HAL_GPIO_Init(GPIOB, &amp;init);\n  }\n  #endif /* CAN2 */\n\n  // CAN3\n  #ifdef CAN3\n  else if (hcan-&gt;Instance == CAN3) {\n    // enable clocks\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    /* enable gpio\n    PA8  -&gt; CAN3_RX\n    PA15 -&gt; CAN3_TX\n    */\n    init.Pin = GPIO_PIN_8;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_PULLUP;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF11_CAN3;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n\n    init.Pin = GPIO_PIN_15;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_NOPULL;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF11_CAN3;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n  }\n  #endif /* CAN3 */\n}\n\n// CAN MSP deinit\nvoid HAL_CAN_MspDeInit(CAN_HandleTypeDef* hcan) {\n  // CAN1\n  if (hcan-&gt;Instance == CAN1) {\n    // disable clocks\n    __HAL_RCC_CAN1_CLK_DISABLE();\n\n    /* disable gpio\n    PA11 -&gt; CAN1_RX\n    PA12 -&gt; CAN1_TX\n    */\n    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_11);\n    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_12);\n\n    // disable interrupts\n    HAL_NVIC_DisableIRQ(CAN1_TX_IRQn);\n    HAL_NVIC_DisableIRQ(CAN1_RX0_IRQn);\n  }\n\n  // CAN2\n  #ifdef CAN2\n  else if (hcan-&gt;Instance == CAN2) {\n    // disable clocks\n    __HAL_RCC_CAN2_CLK_DISABLE();\n\n    /* disable gpio\n    PB12 -&gt; CAN2_RX\n    PB13 -&gt; CAN2_TX\n    */\n    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_12);\n    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_13);\n\n    // disable interrupts\n    HAL_NVIC_DisableIRQ(CAN2_TX_IRQn);\n    HAL_NVIC_DisableIRQ(CAN2_RX0_IRQn);\n  }\n  #endif /* CAN2 */\n\n  // CAN3\n  #ifdef CAN3\n  else if (hcan-&gt;Instance == CAN3) {\n    // disable clocks\n    __HAL_RCC_CAN3_CLK_DISABLE();\n\n    /* disable gpio\n    PA8  -&gt; CAN3_RX\n    PB15 -&gt; CAN3_TX\n    */\n    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_8);\n    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_15);\n\n    // disable interrupts\n    HAL_NVIC_DisableIRQ(CAN3_TX_IRQn);\n    HAL_NVIC_DisableIRQ(CAN3_RX0_IRQn);\n  }\n  #endif /* CAN3 */\n}\n\nstatic inline void HAL_CAN_MspL4Init(CAN_HandleTypeDef* hcan){\n  GPIO_InitTypeDef init = {0};\n  // CAN1\n  if (hcan-&gt;Instance == CAN1) {\n    // enable clocks\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    /* enable gpio\n    PA11 -&gt; CAN1_RX\n    PA12 -&gt; CAN1_TX\n    */\n    init.Pin = GPIO_PIN_11;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_PULLUP;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN1;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n\n    init.Pin = GPIO_PIN_12;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_NOPULL;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN1;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n  }\n}\n\n// CAN MSP init\nvoid HAL_CAN_MspInit(CAN_HandleTypeDef* hcan) {\n  IRQn_Type txIRQ = 0;\n  IRQn_Type rxIRQ = 0;\n  if (hcan-&gt;Instance == CAN1) {\n    __HAL_RCC_CAN1_CLK_ENABLE();\n    txIRQ = CAN1_TX_IRQn;\n    rxIRQ = CAN1_RX0_IRQn;\n  }\n  #ifdef CAN2\n  else if(hcan-&gt;Instance == CAN2){\n    __HAL_RCC_CAN2_CLK_ENABLE();\n    txIRQ = CAN2_TX_IRQn;\n    rxIRQ = CAN2_RX0_IRQn;\n  }\n  #endif\n  #ifdef CAN3\n  else if(hcan-&gt;Instance == CAN3){\n    __HAL_RCC_CAN3_CLK_ENABLE();\n    txIRQ = CAN3_TX_IRQn;\n    rxIRQ = CAN3_RX0_IRQn;\n  }\n  #endif\n\n  // configure GPIO pins for CAN\n  #if defined(STM32F4xx)\n  HAL_CAN_MspF4Init(hcan);\n  #elif defined(STM32L4xx)\n  HAL_CAN_MspL4Init(hcan);\n  #endif\n\n  // enable can interrupts\n  if(txIRQ !=0 &amp;&amp; rxIRQ !=0){\n    HAL_NVIC_SetPriority(txIRQ, 5, 0);\n    HAL_NVIC_EnableIRQ(txIRQ);\n    HAL_NVIC_SetPriority(rxIRQ, 5, 0);\n    HAL_NVIC_EnableIRQ(rxIRQ);\n  }\n}\n\ncan_status_t can_init(CAN_HandleTypeDef* handle, CAN_FilterTypeDef* filter) {\n  // CAN1\n  if (handle-&gt;Instance == CAN1) {\n    // init queues\n    can1_send_queue =\n        xQueueCreateStatic(CAN1_SEND_QUEUE_SIZE, sizeof(tx_payload_t),\n                           can1_send_queue_storage, &amp;can1_send_queue_buffer);\n    for (int i = 0; i &lt; can1_recv_entry_count; i++) {\n      can1_recv_entries[i].queue = xQueueCreateStatic(\n          can1_recv_entries[i].size, sizeof(rx_payload_t),\n          can1_recv_entries[i].storage, &amp;can1_recv_entries[i].buffer);\n    }\n  }\n\n  // CAN2\n  #ifdef CAN2\n  else if (handle-&gt;Instance == CAN2) {\n    // init queues\n    can2_send_queue =\n        xQueueCreateStatic(CAN2_SEND_QUEUE_SIZE, sizeof(tx_payload_t),\n                           can2_send_queue_storage, &amp;can2_send_queue_buffer);\n    for (int i = 0; i &lt; can2_recv_entry_count; i++) {\n      can2_recv_entries[i].queue = xQueueCreateStatic(\n          can2_recv_entries[i].size, sizeof(rx_payload_t),\n          can2_recv_entries[i].storage, &amp;can2_recv_entries[i].buffer);\n    }\n  }\n  #endif /* CAN2 */\n\n  // CAN3\n  #ifdef CAN3\n  else if (handle-&gt;Instance == CAN3) {\n    // init queues\n    can3_send_queue =\n        xQueueCreateStatic(CAN3_SEND_QUEUE_SIZE, sizeof(tx_payload_t),\n                           can3_send_queue_storage, &amp;can3_send_queue_buffer);\n    for (int i = 0; i &lt; can3_recv_entry_count; i++) {\n      can3_recv_entries[i].queue = xQueueCreateStatic(\n          can3_recv_entries[i].size, sizeof(rx_payload_t),\n          can3_recv_entries[i].storage, &amp;can3_recv_entries[i].buffer);\n    }\n  }\n  #endif /* CAN3 */\n\n  else {\n    return CAN_ERR;\n  }\n\n  // init HAL\n  if (HAL_CAN_Init(handle) != HAL_OK) {\n    return CAN_ERR;\n  }\n\n  // init filter\n  if (HAL_CAN_ConfigFilter(handle, filter) != HAL_OK) {\n    return CAN_ERR;\n  }\n\n  // enable interrupts\n  if (HAL_CAN_ActivateNotification(handle, CAN_IT_TX_MAILBOX_EMPTY) != HAL_OK) {\n    return CAN_ERR;\n  }\n  if (HAL_CAN_ActivateNotification(handle, CAN_IT_RX_FIFO0_MSG_PENDING) !=\n      HAL_OK) {\n    return CAN_ERR;\n  }\n\n  return CAN_OK;\n}\n\ncan_status_t can_deinit(CAN_HandleTypeDef* handle) {\n  // deinit HAL\n  if (HAL_CAN_DeInit(handle) != HAL_OK) {\n    return CAN_ERR;\n  }\n\n  // disable interrupts\n  if (HAL_CAN_DeactivateNotification(handle, CAN_IT_TX_MAILBOX_EMPTY) != HAL_OK) {\n    return CAN_ERR;\n  }\n  if (HAL_CAN_DeactivateNotification(handle, CAN_IT_RX_FIFO0_MSG_PENDING) !=\n      HAL_OK) {\n    return CAN_ERR;\n  }\n\n  return CAN_OK;\n}\n\ncan_status_t can_start(CAN_HandleTypeDef* handle) {\n  if (HAL_CAN_Start(handle) != HAL_OK) {\n    return CAN_ERR;\n  }\n\n  return CAN_OK;\n}\n\ncan_status_t can_stop(CAN_HandleTypeDef* handle) {\n  if (HAL_CAN_Stop(handle) != HAL_OK) {\n    return CAN_ERR;\n  }\n\n  return CAN_OK;\n}\n\ncan_status_t can_recv(CAN_HandleTypeDef* handle, uint16_t id,\n                      CAN_RxHeaderTypeDef* header, uint8_t data[],\n                      TickType_t delay_ticks) {\n  // recieve from queue matching id\n  rx_payload_t payload = {0};\n  bool valid_id = false;\n  // CAN1\n  if (handle-&gt;Instance == CAN1) {\n    for (int i = 0; i &lt; can1_recv_entry_count; i++) {\n      if (can1_recv_entries[i].id == id) {\n        valid_id = true;\n\n        // if delay_ticks == portMAX_DELAY thread blocks, \n        // other values of delay_ticks are delays\n        if (xQueueReceive(can1_recv_entries[i].queue, &amp;payload, delay_ticks) ==\n            errQUEUE_EMPTY) {\n          return CAN_EMPTY;\n        }\n\n        break;\n      }\n    }\n  }\n\n  // CAN2\n  #ifdef CAN2\n  else if (handle-&gt;Instance == CAN2) {\n    for (int i = 0; i &lt; can2_recv_entry_count; i++) {\n      if (can2_recv_entries[i].id == id) {\n        valid_id = true;\n\n        // if delay_ticks == portMAX_DELAY thread blocks, \n        // other values of delay_ticks are delays\n        if (xQueueReceive(can2_recv_entries[i].queue, &amp;payload, delay_ticks) ==\n            errQUEUE_EMPTY) {\n          return CAN_EMPTY;\n        }\n\n        break;\n      }\n    }\n  }\n  #endif /* CAN2 */\n\n  // CAN3\n  #ifdef CAN3\n  else if (handle-&gt;Instance == CAN3) {\n    for (int i = 0; i &lt; can3_recv_entry_count; i++) {\n      if (can3_recv_entries[i].id == id) {\n        valid_id = true;\n\n        // if delay_ticks == portMAX_DELAY thread blocks, \n        // other values of delay_ticks are delays\n        if (xQueueReceive(can3_recv_entries[i].queue, &amp;payload, delay_ticks) ==\n            errQUEUE_EMPTY) {\n          return CAN_EMPTY;\n        }\n\n        break;\n      }\n    }\n  }\n  #endif /* CAN3 */\n\n  else {\n    return CAN_ERR;\n  }\n\n  // decode payload if it is valid and message recieved\n  if (valid_id) {\n    *header = payload.header;\n    for (int i = 0; i &lt; DATA_SIZE; i++) {\n      data[i] = payload.data[i];\n    }\n\n    return CAN_RECV;\n\n  } else {\n    return CAN_ERR;\n  }\n}\n\ncan_status_t can_send(CAN_HandleTypeDef* handle,\n                      const CAN_TxHeaderTypeDef* header, const uint8_t data[],\n                      TickType_t delay_ticks) {\n\n  // disable interrupts (do not want race conditions\n  // on shared resource (mailbox) between threads and\n  // interrupt routines (TxComplete))\n  portENTER_CRITICAL();\n\n  // if transmit is inactive, put payload into mailbox\n  if (HAL_CAN_GetTxMailboxesFreeLevel(handle) &gt;= 1) {\n    uint32_t mailbox;\n    if (HAL_CAN_AddTxMessage(handle, header, data, &amp;mailbox) != HAL_OK) {\n      // disable interrupts\n      portEXIT_CRITICAL();\n\n      return CAN_ERR;\n    }\n\n    // disable interrupts\n    portEXIT_CRITICAL();\n  }\n  // otherwise, put into send queue\n  else {\n    // disable interrupts\n    portEXIT_CRITICAL();\n\n    tx_payload_t payload = {0};\n    payload.header = *header;\n    for (int i = 0; i &lt; DATA_SIZE; i++) {\n      payload.data[i] = data[i];\n    }\n\n    // CAN1\n    if (handle-&gt;Instance == CAN1) {\n      if (xQueueSend(can1_send_queue, &amp;payload, delay_ticks) != pdTRUE) {\n        return CAN_ERR;\n      }\n    }\n\n    // CAN2\n    #ifdef CAN2\n    else if (handle-&gt;Instance == CAN2) {\n      if (xQueueSend(can2_send_queue, &amp;payload, delay_ticks) != pdTRUE) {\n        return CAN_ERR;\n      }\n    }\n    #endif /* CAN2 */\n\n    // CAN3\n    #ifdef CAN3\n    else if (handle-&gt;Instance == CAN3) {\n      if (xQueueSend(can3_send_queue, &amp;payload, delay_ticks) != pdTRUE) {\n        return CAN_ERR;\n      }\n    }\n    #endif /* CAN3 */\n  }\n\n  return CAN_SENT;\n}\n\nstatic void transmit(CAN_HandleTypeDef* handle) {\n  tx_payload_t payload = {0};\n  BaseType_t higherPriorityTaskWoken = pdFALSE;\n\n  // receive data from send queue\n  bool success = false;\n  // CAN1\n  if (handle-&gt;Instance == CAN1) {\n    if (xQueueReceiveFromISR(can1_send_queue, &amp;payload,\n                             &amp;higherPriorityTaskWoken) == pdTRUE) {\n      success = true;\n    }\n  }\n\n  // CAN2\n  #ifdef CAN2\n  else if (handle-&gt;Instance == CAN2) {\n    if (xQueueReceiveFromISR(can2_send_queue, &amp;payload,\n                             &amp;higherPriorityTaskWoken) == pdTRUE) {\n      success = true;\n    }\n  }\n  #endif /* CAN2 */\n\n  // CAN3\n  #ifdef CAN3\n  else if (handle-&gt;Instance == CAN3) {\n    if (xQueueReceiveFromISR(can3_send_queue, &amp;payload,\n                             &amp;higherPriorityTaskWoken) == pdTRUE) {\n      success = true;\n    }\n  }\n  #endif /* CAN3 */\n\n  // add payload to mailbox\n  if (success) {\n    uint32_t mailbox;\n    if (HAL_CAN_AddTxMessage(handle, &amp;payload.header, payload.data, &amp;mailbox) != HAL_OK) {\n      // Handle transmission error (optional: log or retry mechanism)\n      // treated as lost packet for now\n    }\n  }\n\n  portYIELD_FROM_ISR(higherPriorityTaskWoken);\n}\n\nvoid HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef* hcan) {\n  transmit(hcan);\n}\n\nvoid HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef* hcan) {\n  transmit(hcan);\n}\n\nvoid HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef* hcan) {\n  transmit(hcan);\n}\n\nvoid HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef* hcan) {\n  rx_payload_t payload = {0};\n  BaseType_t higherPriorityTaskWoken = pdFALSE;\n\n  // recieve messages from queue till empty and put into recieve queues\n  while (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &amp;payload.header,\n                              payload.data) == HAL_OK) {\n    // CAN1\n    if (hcan-&gt;Instance == CAN1) {\n      for (int i = 0; i &lt; can1_recv_entry_count; i++) {\n        if (can1_recv_entries[i].id == payload.header.StdId) {\n          if (can1_recv_entries[i].circular){\n            xQueueSendCircularBufferFromISR(\n              can1_recv_entries[i].queue, \n              &amp;payload, \n              &amp;higherPriorityTaskWoken, \n              sizeof(rx_payload_t)\n            );\n          } else {\n            xQueueSendFromISR(can1_recv_entries[i].queue, &amp;payload,\n                            &amp;higherPriorityTaskWoken);\n          }\n      break;\n        }\n      }\n    }\n\n    // CAN2\n    #ifdef CAN2\n    else if (hcan-&gt;Instance == CAN2) {\n      for (int i = 0; i &lt; can2_recv_entry_count; i++) {\n        if (can2_recv_entries[i].id == payload.header.StdId) {\n          if (can2_recv_entries[i].circular){\n            xQueueSendCircularBufferFromISR(\n              can2_recv_entries[i].queue, \n              &amp;payload, \n              &amp;higherPriorityTaskWoken, \n              sizeof(rx_payload_t)\n            );\n          } else {\n            xQueueSendFromISR(can2_recv_entries[i].queue, &amp;payload,\n                            &amp;higherPriorityTaskWoken);\n          }\n      break;\n        }\n      }\n    }\n    #endif /* CAN2 */\n\n    // CAN3\n    #ifdef CAN3\n    if (hcan-&gt;Instance == CAN3) {\n      for (int i = 0; i &lt; can3_recv_entry_count; i++) {\n        if (can3_recv_entries[i].id == payload.header.StdId) {\n          if (can3_recv_entries[i].circular){\n            xQueueSendCircularBufferFromISR(\n              can3_recv_entries[i].queue, \n              &amp;payload, \n              &amp;higherPriorityTaskWoken, \n              sizeof(rx_payload_t)\n            );\n          } else {\n            xQueueSendFromISR(can3_recv_entries[i].queue, &amp;payload,\n                            &amp;higherPriorityTaskWoken);\n          }\n      break;\n        }\n      }\n    }\n    #endif /* CAN3 */\n  }\n\n  portYIELD_FROM_ISR(higherPriorityTaskWoken);\n}\n\n// CAN1\n#ifdef CAN1\nvoid CAN1_TX_IRQHandler(void) { HAL_CAN_IRQHandler(hcan1); }\nvoid CAN1_RX0_IRQHandler(void) { HAL_CAN_IRQHandler(hcan1); }\n#endif /* CAN1 */\n\n// CAN2\n#ifdef CAN2\nvoid CAN2_TX_IRQHandler(void) { HAL_CAN_IRQHandler(hcan2); }\nvoid CAN2_RX0_IRQHandler(void) { HAL_CAN_IRQHandler(hcan2); }\n#endif /* CAN2 */\n\n// CAN3\n#ifdef CAN3\nvoid CAN3_TX_IRQHandler(void) { HAL_CAN_IRQHandler(hcan3); }\nvoid CAN3_RX0_IRQHandler(void) { HAL_CAN_IRQHandler(hcan3); }\n#endif /* CAN3 */\n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/","title":"File UART.c","text":"<p>FileList &gt; bsp &gt; Src &gt; UART.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"UART.h\"</code></li> <li><code>#include &lt;string.h&gt;</code></li> </ul>"},{"location":"BSP/_u_a_r_t_8c/#classes","title":"Classes","text":"Type Name struct rx_payload_t struct tx_payload_t"},{"location":"BSP/_u_a_r_t_8c/#public-functions","title":"Public Functions","text":"Type Name void HAL_UART_MspDeInit (UART_HandleTypeDef * huart)  __weak void HAL_UART_MspGPIODeInit (UART_HandleTypeDef * huart)  __weak void HAL_UART_MspGPIOInit (UART_HandleTypeDef * huart)  void HAL_UART_MspInit (UART_HandleTypeDef * huart)  void HAL_UART_RxCpltCallback (UART_HandleTypeDef * huart)  void HAL_UART_TxCpltCallback (UART_HandleTypeDef * huart)  uart_status_t uart_deinit (UART_HandleTypeDef * handle) Deinitializes the UART peripheral. uart_status_t uart_init (UART_HandleTypeDef * handle) Initializes the UART peripheral. uart_status_t uart_recv (UART_HandleTypeDef * handle, uint8_t * data, uint8_t length, TickType_t delay_ticks) Reads data from the user-provided RX queue. uart_status_t uart_send (UART_HandleTypeDef * handle, const uint8_t * data, uint8_t length, TickType_t delay_ticks) Transmits data over UART. If transmission is in progress, data will be queued in internal TX queue."},{"location":"BSP/_u_a_r_t_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name bool is_uart_initialized (UART_HandleTypeDef * handle)"},{"location":"BSP/_u_a_r_t_8c/#macros","title":"Macros","text":"Type Name define DATA_SIZE <code>(1)</code> define UART_NVIC_PREEMPT_PRIO <code>(5)</code>"},{"location":"BSP/_u_a_r_t_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_mspdeinit","title":"function HAL_UART_MspDeInit","text":"<pre><code>void HAL_UART_MspDeInit (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_mspgpiodeinit","title":"function HAL_UART_MspGPIODeInit","text":"<pre><code>__weak void HAL_UART_MspGPIODeInit (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_mspgpioinit","title":"function HAL_UART_MspGPIOInit","text":"<pre><code>__weak void HAL_UART_MspGPIOInit (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_mspinit","title":"function HAL_UART_MspInit","text":"<pre><code>void HAL_UART_MspInit (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_rxcpltcallback","title":"function HAL_UART_RxCpltCallback","text":"<pre><code>void HAL_UART_RxCpltCallback (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_txcpltcallback","title":"function HAL_UART_TxCpltCallback","text":"<pre><code>void HAL_UART_TxCpltCallback (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-uart_deinit","title":"function uart_deinit","text":"<p>Deinitializes the UART peripheral. </p> <pre><code>uart_status_t uart_deinit (\n    UART_HandleTypeDef * handle\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>handle</code> pointer to the UART handle </li> </ul> <p>Returns:</p> <p>uart_status_t </p>"},{"location":"BSP/_u_a_r_t_8c/#function-uart_init","title":"function uart_init","text":"<p>Initializes the UART peripheral. </p> <pre><code>uart_status_t uart_init (\n    UART_HandleTypeDef * handle\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>handle</code> pointer to the UART handle </li> </ul> <p>Returns:</p> <p>uart_status_t </p>"},{"location":"BSP/_u_a_r_t_8c/#function-uart_recv","title":"function uart_recv","text":"<p>Reads data from the user-provided RX queue. </p> <pre><code>uart_status_t uart_recv (\n    UART_HandleTypeDef * handle,\n    uint8_t * data,\n    uint8_t length,\n    TickType_t delay_ticks\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>huart</code> pointer to the UART handle </li> <li><code>data</code> pointer to the data buffer that will be read into </li> <li><code>length</code> of the buffer that will be read </li> <li><code>delay_ticks</code> number of ticks to wait for data to be received </li> </ul> <p>Returns:</p> <p>uart_status_t </p>"},{"location":"BSP/_u_a_r_t_8c/#function-uart_send","title":"function uart_send","text":"<p>Transmits data over UART. If transmission is in progress, data will be queued in internal TX queue. </p> <pre><code>uart_status_t uart_send (\n    UART_HandleTypeDef * handle,\n    const uint8_t * data,\n    uint8_t length,\n    TickType_t delay_ticks\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>data</code> pointer to the data buffer that will be written/transmitted </li> <li><code>length</code> of the buffer that will be written/transmitted </li> <li><code>delay_ticks</code> number of ticks to wait for data to be transmitted </li> </ul> <p>Returns:</p> <p>uart_status_t </p>"},{"location":"BSP/_u_a_r_t_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"BSP/_u_a_r_t_8c/#function-is_uart_initialized","title":"function is_uart_initialized","text":"<pre><code>static bool is_uart_initialized (\n    UART_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"BSP/_u_a_r_t_8c/#define-data_size","title":"define DATA_SIZE","text":"<pre><code>#define DATA_SIZE `(1)`\n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#define-uart_nvic_preempt_prio","title":"define UART_NVIC_PREEMPT_PRIO","text":"<pre><code>#define UART_NVIC_PREEMPT_PRIO `(5)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Src/UART.c</code></p>"},{"location":"BSP/_u_a_r_t_8c_source/","title":"File UART.c","text":"<p>File List &gt; bsp &gt; Src &gt; UART.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"UART.h\"\n#include &lt;string.h&gt;\n\n// Define the size of the data to be transmitted\n// Currently not used, as we send uint8_t directly\n// may need to be configured for support for packets less more than 8 bits\n#ifndef DATA_SIZE\n#define DATA_SIZE (1) // fallback to 1 byte\n#endif\n\n// Define the preemption priority for the interrupt\n#ifndef UART_NVIC_PREEMPT_PRIO\n#define UART_NVIC_PREEMPT_PRIO (5)\n#endif\n\ntypedef struct {\n    uint8_t data[DATA_SIZE]; // data to be transmitted, 1 byte\n} tx_payload_t;\n\ntypedef struct {\n    uint8_t data[DATA_SIZE]; // data received, 1 byte\n} rx_payload_t;\n\n#ifdef UART4\n// fallback UART4 TX queue size\n#ifndef UART4_TX_QUEUE_SIZE\n#define UART4_TX_QUEUE_SIZE (10)\n#endif\n\n// fallback UART4 RX queue size\n#ifndef UART4_RX_QUEUE_SIZE\n#define UART4_RX_QUEUE_SIZE (10)\n#endif\n\n//UART4 handle\nstatic UART_HandleTypeDef huart4_ = {.Instance = UART4};\nUART_HandleTypeDef* huart4 = &amp;huart4_;\n\n// UART4 TX queue\nstatic QueueHandle_t uart4_tx_queue = NULL;\nstatic StaticQueue_t uart4_tx_queue_buffer;\nstatic uint8_t uart4_tx_queue_storage[UART4_TX_QUEUE_SIZE * sizeof(tx_payload_t)]; \n\n\n// UART4 RX queue\nstatic QueueHandle_t uart4_rx_queue = NULL;\nstatic StaticQueue_t uart4_rx_queue_buffer;\nstatic uint8_t uart4_rx_queue_storage[UART4_RX_QUEUE_SIZE * sizeof(rx_payload_t)];  // Will be allocated based on queue_size in uart_init\n\n// UART4 RX buffer\n// An intermediate buffer of DATA_SIZE bytes to store received data before it is copied to the queue\nstatic rx_payload_t uart4_rx_buffer;\n\n#endif /* UART4 */\n\n#ifdef UART5\n// fallback UART5 TX queue size\n#ifndef UART5_TX_QUEUE_SIZE\n#define UART5_TX_QUEUE_SIZE (10)\n#endif\n\n// fallback UART5 RX queue size\n#ifndef UART5_RX_QUEUE_SIZE\n#define UART5_RX_QUEUE_SIZE (10)\n#endif\n\n// UART5 handle\nstatic UART_HandleTypeDef huart5_ = {.Instance = UART5};\nUART_HandleTypeDef* huart5 = &amp;huart5_;\n\n// UART5 TX queue\nstatic QueueHandle_t uart5_tx_queue = NULL;\nstatic StaticQueue_t uart5_tx_queue_buffer;\nstatic uint8_t uart5_tx_queue_storage[UART5_TX_QUEUE_SIZE * sizeof(tx_payload_t)];\n\n// UART5 RX queue\nstatic QueueHandle_t uart5_rx_queue = NULL;\nstatic StaticQueue_t uart5_rx_queue_buffer;\nstatic uint8_t uart5_rx_queue_storage[UART5_RX_QUEUE_SIZE * sizeof(rx_payload_t)];  // Will be allocated based on queue_size\n\n// UART5 RX buffer\n// An intermediate buffer of DATA_SIZE bytes to store received data before it is copied to the queue\nstatic rx_payload_t uart5_rx_buffer;\n\n#endif /* UART5 */\n\n#ifdef USART1\n// fallback USART1 TX queue size\n#ifndef USART1_TX_QUEUE_SIZE\n#define USART1_TX_QUEUE_SIZE (10)\n#endif\n\n// fallback USART1 RX queue size\n#ifndef USART1_RX_QUEUE_SIZE\n#define USART1_RX_QUEUE_SIZE (10)\n#endif\n\n//USART1 handle\nstatic UART_HandleTypeDef husart1_ = {.Instance = USART1};\nUART_HandleTypeDef* husart1 = &amp;husart1_;\n\n// USART1 TX queue\nstatic QueueHandle_t usart1_tx_queue = NULL;\nstatic StaticQueue_t usart1_tx_queue_buffer;\nstatic uint8_t usart1_tx_queue_storage[USART1_TX_QUEUE_SIZE * sizeof(tx_payload_t)]; \n\n\n// USART1 RX queue\nstatic QueueHandle_t usart1_rx_queue = NULL;\nstatic StaticQueue_t usart1_rx_queue_buffer;\nstatic uint8_t usart1_rx_queue_storage[USART1_RX_QUEUE_SIZE * sizeof(rx_payload_t)];  // Will be allocated based on queue_size in uart_init\n\n// USART1 RX buffer\n// An intermediate buffer of DATA_SIZE bytes to store received data before it is copied to the queue\nstatic rx_payload_t usart1_rx_buffer;\n\n#endif /* USART1 */\n\n#ifdef USART2\n// fallback USART2 TX queue size\n#ifndef USART2_TX_QUEUE_SIZE\n#define USART2_TX_QUEUE_SIZE (10)\n#endif\n\n// fallback USART2 RX queue size\n#ifndef USART2_RX_QUEUE_SIZE\n#define USART2_RX_QUEUE_SIZE (10)\n#endif\n\n//USART2 handle\nstatic UART_HandleTypeDef husart2_ = {.Instance = USART2};\nUART_HandleTypeDef* husart2 = &amp;husart2_;\n\n// USART2 TX queue\nstatic QueueHandle_t usart2_tx_queue = NULL;\nstatic StaticQueue_t usart2_tx_queue_buffer;\nstatic uint8_t usart2_tx_queue_storage[USART2_TX_QUEUE_SIZE * sizeof(tx_payload_t)]; \n\n\n// USART2 RX queue\nstatic QueueHandle_t usart2_rx_queue = NULL;\nstatic StaticQueue_t usart2_rx_queue_buffer;\nstatic uint8_t usart2_rx_queue_storage[USART2_RX_QUEUE_SIZE * sizeof(rx_payload_t)];  // Will be allocated based on queue_size in uart_init\n\n// USART2 RX buffer\n// An intermediate buffer of DATA_SIZE bytes to store received data before it is copied to the queue\nstatic rx_payload_t usart2_rx_buffer;\n\n#endif /* USART2 */\n\n#ifdef USART3\n// fallback USART3 TX queue size\n#ifndef USART3_TX_QUEUE_SIZE\n#define USART3_TX_QUEUE_SIZE (10)\n#endif\n\n// fallback USART3 RX queue size\n#ifndef USART3_RX_QUEUE_SIZE\n#define USART3_RX_QUEUE_SIZE (10)\n#endif\n\n//USART3 handle\nstatic UART_HandleTypeDef husart3_ = {.Instance = USART3};\nUART_HandleTypeDef* husart3 = &amp;husart3_;\n\n// USART3 TX queue\nstatic QueueHandle_t usart3_tx_queue = NULL;\nstatic StaticQueue_t usart3_tx_queue_buffer;\nstatic uint8_t usart3_tx_queue_storage[USART3_TX_QUEUE_SIZE * sizeof(tx_payload_t)]; \n\n\n// USART3 RX queue\nstatic QueueHandle_t usart3_rx_queue = NULL;\nstatic StaticQueue_t usart3_rx_queue_buffer;\nstatic uint8_t usart3_rx_queue_storage[USART3_RX_QUEUE_SIZE * sizeof(rx_payload_t)];  // Will be allocated based on queue_size in uart_init\n\n// USART3 RX buffer\n// An intermediate buffer of DATA_SIZE bytes to store received data before it is copied to the queue\nstatic rx_payload_t usart3_rx_buffer;\n\n#endif /* USART3 */\n\nstatic bool is_uart_initialized(UART_HandleTypeDef* handle) {\n    // Check if the UART is in a valid state\n    // HAL_UART_STATE_RESET indicates the UART is not initialized\n    return (handle-&gt;gState != HAL_UART_STATE_RESET);\n}\n\n// Redefine me!\n__weak void HAL_UART_MspGPIOInit(UART_HandleTypeDef *huart){ \n    GPIO_InitTypeDef init = {0};\n    // Same sets of pins for L4/F4\n    #ifdef UART4\n    if(huart-&gt;Instance == UART4) {\n        //enable port A clock\n        __HAL_RCC_GPIOA_CLK_ENABLE();\n\n        /* enable port A UART4 gpio\n        PA0 -&gt; UART4_TX\n        PA1 -&gt; UART4_RX    \n        */\n        init.Pin = GPIO_PIN_0|GPIO_PIN_1;\n        init.Mode = GPIO_MODE_AF_PP;\n        init.Pull = GPIO_NOPULL;\n        init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n        init.Alternate = GPIO_AF8_UART4;\n        HAL_GPIO_Init(GPIOA, &amp;init);\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if (huart-&gt;Instance == UART5) {\n        __HAL_RCC_GPIOC_CLK_ENABLE();\n\n    __HAL_RCC_GPIOD_CLK_ENABLE();\n\n        /* enable UART5 gpio   \n        PC12 -&gt; UART5_TX\n        PD2 -&gt; UART5_RX\n        */\n        init.Pin = GPIO_PIN_12;\n        init.Mode = GPIO_MODE_AF_PP;\n        init.Pull = GPIO_NOPULL;\n        init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n        init.Alternate = GPIO_AF8_UART5;\n        HAL_GPIO_Init(GPIOC, &amp;init);\n\n        init.Pin = GPIO_PIN_2;\n\n    HAL_GPIO_Init(GPIOD, &amp;init);\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(huart-&gt;Instance == USART1) {\n        //enable port A clock\n        __HAL_RCC_GPIOA_CLK_ENABLE();\n\n        /* enable port A USART1 gpio\n        PA9 -&gt; USART1_TX\n        PA10 -&gt; USART1_RX    \n        */\n        init.Pin = GPIO_PIN_9|GPIO_PIN_10;\n        init.Mode = GPIO_MODE_AF_PP;\n        init.Pull = GPIO_NOPULL;\n        init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n        init.Alternate = GPIO_AF7_USART1;\n        HAL_GPIO_Init(GPIOA, &amp;init);\n    }\n    #endif /* USART1 */\n\n    #if defined(USART2) &amp;&amp; defined(GPIOD)\n    if(huart-&gt;Instance == USART2) {\n        //enable port D clock\n        __HAL_RCC_GPIOD_CLK_ENABLE();\n\n        /* enable port D USART2 gpio\n        PD5 -&gt; USART2_TX\n        PD6 -&gt; USART2_RX    \n        */\n        init.Pin = GPIO_PIN_5|GPIO_PIN_6;\n        init.Mode = GPIO_MODE_AF_PP;\n        init.Pull = GPIO_NOPULL;\n        init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n        init.Alternate = GPIO_AF7_USART2;\n        HAL_GPIO_Init(GPIOD, &amp;init);\n    }\n    #endif /* USART2 &amp;&amp; GPIOD*/\n\n    #ifdef USART3\n    if(huart-&gt;Instance == USART3) {\n        //enable port C clock\n        __HAL_RCC_GPIOC_CLK_ENABLE();\n\n        /* enable port C USART3 gpio\n        PC10 -&gt; USART3_TX\n        PC11 -&gt; USART3_RX    \n        */\n        init.Pin = GPIO_PIN_10|GPIO_PIN_11;\n        init.Mode = GPIO_MODE_AF_PP;\n        init.Pull = GPIO_NOPULL;\n        init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n        init.Alternate = GPIO_AF7_USART3;\n        HAL_GPIO_Init(GPIOC, &amp;init);\n    }\n    #endif /* USART3 */    \n}\n\nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart) {\n    IRQn_Type uart_IRQ = NonMaskableInt_IRQn; // IRQn_Type for UART interrupts\n\n    #ifdef UART4\n    if (huart-&gt;Instance == UART4) {\n        __HAL_RCC_UART4_CLK_ENABLE(); // enable UART4 clock\n        uart_IRQ = UART4_IRQn;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if (huart-&gt;Instance == UART5) {\n        __HAL_RCC_UART5_CLK_ENABLE(); // enable UART5 clock\n        uart_IRQ = UART5_IRQn;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if (huart-&gt;Instance == USART1) {\n        __HAL_RCC_USART1_CLK_ENABLE(); // enable USART1 clock\n        uart_IRQ = USART1_IRQn;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if (huart-&gt;Instance == USART2) {\n        __HAL_RCC_USART2_CLK_ENABLE(); // enable USART2 clock\n        uart_IRQ = USART2_IRQn;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if (huart-&gt;Instance == USART3) {\n        __HAL_RCC_USART3_CLK_ENABLE(); // enable USART3 clock\n        uart_IRQ = USART3_IRQn;\n    }\n    #endif /* USART3 */\n\n    // configure GPIO pins for UART\n    HAL_UART_MspGPIOInit(huart); \n\n    // enable uart interrupts\n    HAL_NVIC_SetPriority(uart_IRQ, UART_NVIC_PREEMPT_PRIO, 0);\n    HAL_NVIC_EnableIRQ(uart_IRQ); \n}\n\n// Redefine me!\n__weak void HAL_UART_MspGPIODeInit(UART_HandleTypeDef *huart){ \n}\n\nvoid HAL_UART_MspDeInit(UART_HandleTypeDef *huart) {\n    // UART4\n    #ifdef UART4\n    if (huart-&gt;Instance == UART4) {\n        //disable clocks\n        __HAL_RCC_UART4_CLK_DISABLE();\n\n        // disable interrupts\n        HAL_NVIC_DisableIRQ(UART4_IRQn);\n    }\n    #endif /* UART4 */\n\n    // UART5\n    #ifdef UART5\n    if (huart-&gt;Instance == UART5) {\n        // disable clocks\n        __HAL_RCC_UART5_CLK_DISABLE();\n\n        // disable interrupts\n        HAL_NVIC_DisableIRQ(UART5_IRQn);        //disable interrupts\n    }\n    #endif /* UART5 */\n\n    // USART1\n    #ifdef USART1\n    if (huart-&gt;Instance == USART1) {\n        // disable clocks\n        __HAL_RCC_USART1_CLK_DISABLE();\n\n        // disable interrupts\n        HAL_NVIC_DisableIRQ(USART1_IRQn);        //disable interrupts\n    }\n    #endif /* USART1 */\n\n    // USART2\n    #ifdef USART2\n    if (huart-&gt;Instance == USART2) {\n        // disable clocks\n        __HAL_RCC_USART2_CLK_DISABLE();\n\n        // disable interrupts\n        HAL_NVIC_DisableIRQ(USART2_IRQn);        //disable interrupts\n    }\n    #endif /* USART2 */\n\n    // USART3\n    #ifdef USART3\n    if (huart-&gt;Instance == USART3) {\n        // disable clocks\n        __HAL_RCC_USART3_CLK_DISABLE();\n\n        // disable interrupts\n        HAL_NVIC_DisableIRQ(USART3_IRQn);        //disable interrupts\n    }\n    #endif /* USART3 */\n\n    HAL_UART_MspGPIODeInit(huart);\n}\n\nuart_status_t uart_init(UART_HandleTypeDef* handle) {\n    uint8_t *rx_buffer = NULL;\n\n    #ifdef UART4\n    if (handle-&gt;Instance == UART4) {\n        // Create TX queue\n        uart4_tx_queue = xQueueCreateStatic(UART4_TX_QUEUE_SIZE, \n                                            sizeof(tx_payload_t), \n                                            uart4_tx_queue_storage, \n                                            &amp;uart4_tx_queue_buffer);\n\n\n        // Create RX queue\n        uart4_rx_queue = xQueueCreateStatic(UART4_RX_QUEUE_SIZE,\n                                            sizeof(rx_payload_t),\n                                            uart4_rx_queue_storage,\n                                            &amp;uart4_rx_queue_buffer);\n\n        rx_buffer = uart4_rx_buffer.data;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if(handle-&gt;Instance == UART5) {\n\n        // Allocate static storage for TX queue\n        uart5_tx_queue = xQueueCreateStatic(UART5_TX_QUEUE_SIZE, \n                                          sizeof(tx_payload_t), \n                                          uart5_tx_queue_storage, \n                                          &amp;uart5_tx_queue_buffer);\n\n        // Create RX queue\n        uart5_rx_queue = xQueueCreateStatic(UART5_RX_QUEUE_SIZE,\n                                          sizeof(rx_payload_t),\n                                          uart5_rx_queue_storage,\n                                          &amp;uart5_rx_queue_buffer);\n\n        rx_buffer = uart5_rx_buffer.data;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(handle-&gt;Instance == USART1) {\n\n        // Allocate static storage for TX queue\n        usart1_tx_queue = xQueueCreateStatic(USART1_TX_QUEUE_SIZE, \n                                          sizeof(tx_payload_t), \n                                          usart1_tx_queue_storage, \n                                          &amp;usart1_tx_queue_buffer);\n\n        // Create RX queue\n        usart1_rx_queue = xQueueCreateStatic(USART1_RX_QUEUE_SIZE,\n                                          sizeof(rx_payload_t),\n                                          usart1_rx_queue_storage,\n                                          &amp;usart1_rx_queue_buffer);\n\n        rx_buffer = usart1_rx_buffer.data;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if(handle-&gt;Instance == USART2) {\n\n        // Allocate static storage for TX queue\n        usart2_tx_queue = xQueueCreateStatic(USART2_TX_QUEUE_SIZE, \n                                          sizeof(tx_payload_t), \n                                          usart2_tx_queue_storage, \n                                          &amp;usart2_tx_queue_buffer);\n\n        // Create RX queue\n        usart2_rx_queue = xQueueCreateStatic(USART2_RX_QUEUE_SIZE,\n                                          sizeof(rx_payload_t),\n                                          usart2_rx_queue_storage,\n                                          &amp;usart2_rx_queue_buffer);\n\n        rx_buffer = usart2_rx_buffer.data;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if(handle-&gt;Instance == USART3) {\n\n        // Allocate static storage for TX queue\n        usart3_tx_queue = xQueueCreateStatic(USART3_TX_QUEUE_SIZE, \n                                          sizeof(tx_payload_t), \n                                          usart3_tx_queue_storage, \n                                          &amp;usart3_tx_queue_buffer);\n\n        // Create RX queue\n        usart3_rx_queue = xQueueCreateStatic(USART3_RX_QUEUE_SIZE,\n                                          sizeof(rx_payload_t),\n                                          usart3_rx_queue_storage,\n                                          &amp;usart3_rx_queue_buffer);\n\n        rx_buffer = usart3_rx_buffer.data;\n    }\n    #endif /* USART3 */\n\n    // init HAL\n    if (HAL_UART_Init(handle) != HAL_OK ||\n    !IS_UART_INSTANCE(handle-&gt;Instance) ||\n    !IS_USART_INSTANCE(handle-&gt;Instance)){\n    return UART_ERR;\n    }\n\n    // Start reception\n    if (HAL_UART_Receive_IT(handle, rx_buffer, DATA_SIZE) != HAL_OK) {\n        return UART_ERR;\n    }\n\n    return UART_OK;\n}\n\n\nuart_status_t uart_deinit(UART_HandleTypeDef* handle) {\n    // Stop any ongoing transfers first\n    HAL_UART_Abort(handle);\n\n    // Deinitialize HAL\n    if (HAL_UART_DeInit(handle) != HAL_OK) {\n        return UART_ERR; \n    }\n\n    // Deinitialize Handler\n    #ifdef UART4\n    if (handle-&gt;Instance == UART4) {\n    uart4_tx_queue = NULL;\n    uart4_rx_queue = NULL;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if (handle-&gt;Instance == UART5) {\n    uart5_tx_queue = NULL;\n    uart5_rx_queue = NULL;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if (handle-&gt;Instance == USART1) {\n    usart1_tx_queue = NULL;\n    usart1_rx_queue = NULL;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if (handle-&gt;Instance == USART2) {\n    usart2_tx_queue = NULL;\n    usart2_rx_queue = NULL;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if (handle-&gt;Instance == USART3) {\n    usart3_tx_queue = NULL;\n    usart3_rx_queue = NULL;\n    }\n    #endif /* USART3 */\n\n    return UART_OK;\n}\n\n\n#ifdef UART4\n// static buffer for UART4 TX\nstatic uint8_t uart4_tx_buffer[UART4_TX_QUEUE_SIZE];\n#endif /* UART4 */\n\n#ifdef UART5\n// static buffer for UART5 TX\nstatic uint8_t uart5_tx_buffer[UART5_TX_QUEUE_SIZE]; // make buffer size same as queue size \n#endif /* UART5 */\n\n#ifdef USART1\n// static buffer for USART1 TX\nstatic uint8_t usart1_tx_buffer[USART1_TX_QUEUE_SIZE];\n#endif /* USART1 */\n\n#ifdef USART2\n// static buffer for USART2 TX\nstatic uint8_t usart2_tx_buffer[USART2_TX_QUEUE_SIZE]; // make buffer size same as queue size \n#endif /* USART2 */\n\n#ifdef USART3\n// static buffer for USART3 TX\nstatic uint8_t usart3_tx_buffer[USART3_TX_QUEUE_SIZE]; // make buffer size same as queue size \n#endif /* USART3 */\n\nuart_status_t uart_send(UART_HandleTypeDef* handle, const uint8_t* data, uint8_t length, TickType_t delay_ticks) {\n    if (length == 0 || !is_uart_initialized(handle)) { // check if UART is initialized and data length is not 0\n        return UART_ERR;\n    }\n\n    QueueHandle_t* tx_queue = NULL;\n    uint8_t* tx_buffer = NULL;\n\n    #ifdef UART4\n    if(handle-&gt;Instance == UART4) {\n        tx_buffer = uart4_tx_buffer; // for direct transmission\n        tx_queue = &amp;uart4_tx_queue;  // for queuing\n    }\n    #endif /* UART4*/\n\n    #ifdef UART5\n    if(handle-&gt;Instance == UART5) {\n        tx_buffer = uart5_tx_buffer;\n        tx_queue = &amp;uart5_tx_queue;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(handle-&gt;Instance == USART1) {\n        tx_buffer = usart1_tx_buffer; // for direct transmission\n        tx_queue = &amp;usart1_tx_queue;  // for queuing\n    }\n    #endif /* USART1*/\n\n    #ifdef USART2\n    if(handle-&gt;Instance == USART2) {\n        tx_buffer = usart2_tx_buffer;\n        tx_queue = &amp;usart2_tx_queue;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if(handle-&gt;Instance == USART3) {\n        tx_buffer = usart3_tx_buffer;\n        tx_queue = &amp;usart3_tx_queue;\n    }\n    #endif /* USART3 */\n\n\n    uart_status_t status = UART_SENT;\n\n    // Try direct transmission if possible\n    portENTER_CRITICAL();\n    if ((HAL_UART_GetState(handle) &amp; HAL_UART_STATE_BUSY_TX) != HAL_UART_STATE_BUSY_TX &amp;&amp;\n        tx_queue != NULL &amp;&amp; uxQueueMessagesWaiting (*tx_queue) == 0 ) { // check if UART is ready and queue is empty\n        // Copy data to static buffer\n        memcpy(tx_buffer, data, length);\n        if (HAL_UART_Transmit_IT(handle, tx_buffer, length) != HAL_OK) {\n            status = UART_ERR;\n        }\n        portEXIT_CRITICAL();\n        goto exit;\n    }\n    portEXIT_CRITICAL();\n\n    // Send data in chunks based on DATA_SIZE\n    for (uint8_t i = 0; i &lt; length; i+=DATA_SIZE) {\n    tx_payload_t payload;\n\n    // Ensure we only copy DATA_SIZE bytes at a time\n    uint8_t chunk_size = (length - i &lt; DATA_SIZE) ? (length - i) : DATA_SIZE;\n    // EX: i=4, length=6, DataSize=4, then chunk_size = 2, instead of usual 4 since we've reached end of length\n\n    // Copy the appropriate number of bytes to the payload data\n     memcpy(payload.data, &amp;data[i], chunk_size); // Usually chunk_size = DATA_SIZE until end of data length\n\n     // If data size is smaller than DATA_SIZE, fill the rest of the payload\n     if (chunk_size &lt; DATA_SIZE) {\n         memset(&amp;payload.data[chunk_size], 0, DATA_SIZE - chunk_size); // Fill the rest with 0 (or other padding if needed)\n     }\n\n    // Enqueue the payload to be transmitted\n    if (xQueueSend(*tx_queue, &amp;payload, delay_ticks) != pdTRUE) {\n        return UART_ERR;\n    } //delay_ticks: 0 = no wait, portMAX_DELAY = wait until space is available\n    }\n\nexit:\n    return status;\n}\n\nuart_status_t uart_recv(UART_HandleTypeDef* handle, uint8_t* data, uint8_t length, TickType_t delay_ticks) {\n    if (!data || length == 0 || !is_uart_initialized(handle)) { // check if data is not null, length is not 0 and UART is initialized\n        return UART_ERR;\n    }\n\n    QueueHandle_t rx_queue = NULL;\n    #ifdef UART4\n    if(handle-&gt;Instance == UART4) {\n        rx_queue = uart4_rx_queue;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if(handle-&gt;Instance == UART5) {\n        rx_queue = uart5_rx_queue;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(handle-&gt;Instance == USART1) {\n        rx_queue = usart1_rx_queue;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if(handle-&gt;Instance == USART2) {\n        rx_queue = usart2_rx_queue;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if(handle-&gt;Instance == USART3) {\n        rx_queue = usart3_rx_queue;\n    }\n    #endif /* USART3 */\n\n    uart_status_t status = UART_RECV;\n    rx_payload_t receivedPayload;\n    uint8_t bytes_received = 0;\n\n    // Receive all requested bytes\n    while (bytes_received &lt; length) {\n        if (xQueueReceive(rx_queue, &amp;receivedPayload, delay_ticks) == errQUEUE_EMPTY) {\n            return UART_EMPTY;  // Queue empty, no more data to receive\n        }\n\n        // Calculate how many bytes to copy from the payload based on DATA_SIZE\n        uint8_t copy_length = (length - bytes_received) &gt;= DATA_SIZE ? DATA_SIZE : (length - bytes_received);\n\n        // Copy the data from the payload to the user's data buffer\n        for (uint8_t i = 0; i &lt; copy_length; i++) {\n            data[bytes_received + i] = receivedPayload.data[i];\n        }\n\n        // Update the number of bytes received\n        bytes_received += copy_length;\n    }\n\n    return status;\n}\n\n// Transmit Callback occurs after a transmission if complete (depending on how huart is configure)\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {\n    BaseType_t higherPriorityTaskWoken = pdFALSE;\n    uint8_t tx_buffer[32];  // Buffer for collecting bytes to send\n    uint8_t count = 0;\n\n    QueueHandle_t *tx_queue = NULL;\n\n    #ifdef UART4\n    if(huart-&gt;Instance == UART4) {\n        tx_queue = &amp;uart4_tx_queue;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if(huart-&gt;Instance == UART5) {\n        tx_queue = &amp;uart5_tx_queue;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(huart-&gt;Instance == USART1) {\n        tx_queue = &amp;usart1_tx_queue;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if(huart-&gt;Instance == USART2) {\n        tx_queue = &amp;usart2_tx_queue;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if(huart-&gt;Instance == USART3) {\n        tx_queue = &amp;usart3_tx_queue;\n    }\n    #endif /* USART3 */\n\n    // Pull as many bytes as we can fit in the buffer\n    tx_payload_t payload;\n    while(count + DATA_SIZE &lt;= sizeof(tx_buffer) &amp;&amp; xQueueReceiveFromISR(*tx_queue, &amp;payload, &amp;higherPriorityTaskWoken) == pdTRUE) {\n        // Safely copy the data from the payload into the tx_buffer\n        memcpy(&amp;tx_buffer[count], payload.data, DATA_SIZE);\n        count += DATA_SIZE;\n    }\n\n    if(tx_queue == NULL) {\n        return; // No valid uart tx queue found\n    }\n\n    // Get as many bytes as we can from queue (up to buffer size)\n    while(count &lt; sizeof(tx_buffer) &amp;&amp; \n        xQueueReceiveFromISR(*tx_queue, &amp;tx_buffer[count], &amp;higherPriorityTaskWoken) == pdTRUE) {\n        count++;\n    }\n\n    //  If we got any bytes, transmit them\n    if(count &gt; 0) {\n      HAL_UART_Transmit_IT(huart, tx_buffer, count);\n    }\n\n    // Yield to a higher priority task if needed\n    portYIELD_FROM_ISR(higherPriorityTaskWoken);\n}\n\n// Receive Callback occurs after a receive is complete\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {\n    QueueHandle_t *rx_queue = NULL;\n    uint8_t *rx_buffer = NULL;\n\n    #ifdef UART4\n    if(huart-&gt;Instance == UART4) {\n        rx_queue = &amp;uart4_rx_queue;\n        rx_buffer = uart4_rx_buffer.data;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if(huart-&gt;Instance == UART5) {\n        rx_queue = &amp;uart5_rx_queue;\n        rx_buffer = uart5_rx_buffer.data;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(huart-&gt;Instance == USART1) {\n        rx_queue = &amp;usart1_rx_queue;\n        rx_buffer = usart1_rx_buffer.data;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if(huart-&gt;Instance == USART2) {\n        rx_queue = &amp;usart2_rx_queue;\n        rx_buffer = usart2_rx_buffer.data;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if(huart-&gt;Instance == USART3) {\n        rx_queue = &amp;usart3_rx_queue;\n        rx_buffer = usart3_rx_buffer.data;\n    }\n    #endif /* USART3 */\n\n    rx_payload_t receivedData;\n    for (int i = 0; i &lt; DATA_SIZE; i++) {\n        receivedData.data[i] = rx_buffer[i]; //uartN_rx_buffer.data\n    rx_buffer[i] = 0x00; // clear rx buffer element\n    }\n\n    BaseType_t higherPriorityTaskWoken = pdFALSE;\n\n    xQueueSendFromISR(*rx_queue, &amp;receivedData, &amp;higherPriorityTaskWoken); // Send data from &amp;receivedData(pRxBuffPtr) to rx_queue\n\n    // Trigger the next interrupt\n    HAL_UART_Receive_IT(huart, rx_buffer, DATA_SIZE);// pRxBufferPtr is a pointer to the buffer that will store the received data\n\n    portYIELD_FROM_ISR(higherPriorityTaskWoken);\n}\n\n#ifdef UART4\nvoid UART4_IRQHandler(void) {\n    HAL_UART_IRQHandler(huart4);\n}\n#endif /* UART4 */\n\n#ifdef UART5\nvoid UART5_IRQHandler(void) {\n    HAL_UART_IRQHandler(huart5);\n}\n#endif /* UART5 */\n\n#ifdef USART1\nvoid USART1_IRQHandler(void) {\n    HAL_UART_IRQHandler(husart1);\n}\n#endif /* USART1 */\n\n#ifdef USART2\nvoid USART2_IRQHandler(void) {\n    HAL_UART_IRQHandler(husart2);\n}\n#endif /* USART2 */\n\n#ifdef USART3\nvoid USART3_IRQHandler(void) {\n    HAL_UART_IRQHandler(husart3);\n}\n#endif /* USART3 */\n</code></pre>"},{"location":"BSP/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"BSP/classes/","title":"Class Index","text":""},{"location":"BSP/classes/#r","title":"r","text":"<ul> <li>recv_entry_t</li> <li>rx_payload_t</li> </ul>"},{"location":"BSP/classes/#t","title":"t","text":"<ul> <li>tx_payload_t</li> </ul>"},{"location":"BSP/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>struct recv_entry_t </li> <li>struct rx_payload_t </li> <li>struct tx_payload_t </li> </ul>"},{"location":"BSP/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"BSP/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"BSP/class_members/","title":"Class Members","text":""},{"location":"BSP/class_members/#b","title":"b","text":"<ul> <li>buffer (recv_entry_t)</li> </ul>"},{"location":"BSP/class_members/#c","title":"c","text":"<ul> <li>circular (recv_entry_t)</li> </ul>"},{"location":"BSP/class_members/#d","title":"d","text":"<ul> <li>data (rx_payload_t, tx_payload_t)</li> </ul>"},{"location":"BSP/class_members/#h","title":"h","text":"<ul> <li>header (rx_payload_t, tx_payload_t)</li> </ul>"},{"location":"BSP/class_members/#i","title":"i","text":"<ul> <li>id (recv_entry_t)</li> </ul>"},{"location":"BSP/class_members/#q","title":"q","text":"<ul> <li>queue (recv_entry_t)</li> </ul>"},{"location":"BSP/class_members/#s","title":"s","text":"<ul> <li>size (recv_entry_t)</li> <li>storage (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"BSP/class_member_variables/","title":"Class Member Variables","text":""},{"location":"BSP/class_member_variables/#b","title":"b","text":"<ul> <li>buffer (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_variables/#c","title":"c","text":"<ul> <li>circular (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_variables/#d","title":"d","text":"<ul> <li>data (rx_payload_t, tx_payload_t)</li> </ul>"},{"location":"BSP/class_member_variables/#h","title":"h","text":"<ul> <li>header (rx_payload_t, tx_payload_t)</li> </ul>"},{"location":"BSP/class_member_variables/#i","title":"i","text":"<ul> <li>id (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_variables/#q","title":"q","text":"<ul> <li>queue (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_variables/#s","title":"s","text":"<ul> <li>size (recv_entry_t)</li> <li>storage (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"BSP/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"BSP/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"BSP/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"BSP/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"BSP/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"BSP/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"BSP/functions/","title":"Functions","text":""},{"location":"BSP/functions/#a","title":"a","text":"<ul> <li>adc_deinit (ADC.h, ADC.c)</li> <li>adc_init (ADC.h, ADC.c)</li> <li>adc_read (ADC.h, ADC.c)</li> </ul>"},{"location":"BSP/functions/#c","title":"c","text":"<ul> <li>can_deinit (CAN.h, CAN.c)</li> <li>can_init (CAN.h, CAN.c)</li> <li>can_recv (CAN.h, CAN.c)</li> <li>can_send (CAN.h, CAN.c)</li> <li>can_start (CAN.h, CAN.c)</li> <li>can_stop (CAN.h, CAN.c)</li> </ul>"},{"location":"BSP/functions/#h","title":"h","text":"<ul> <li>HAL_ADC_ConvCpltCallback (ADC.c)</li> <li>HAL_ADC_ErrorCallback (ADC.c)</li> <li>HAL_ADC_MspDeInit (ADC.c)</li> <li>HAL_ADC_MspGPIOInit (ADC.c)</li> <li>HAL_ADC_MspInit (ADC.c)</li> <li>HAL_CAN_MspDeInit (CAN.c)</li> <li>HAL_CAN_MspF4Init (CAN.c)</li> <li>HAL_CAN_MspInit (CAN.c)</li> <li>HAL_CAN_MspL4Init (CAN.c)</li> <li>HAL_CAN_RxFifo0MsgPendingCallback (CAN.c)</li> <li>HAL_CAN_TxMailbox0CompleteCallback (CAN.c)</li> <li>HAL_CAN_TxMailbox1CompleteCallback (CAN.c)</li> <li>HAL_CAN_TxMailbox2CompleteCallback (CAN.c)</li> <li>HAL_UART_MspDeInit (UART.c)</li> <li>HAL_UART_MspGPIODeInit (UART.c)</li> <li>HAL_UART_MspGPIOInit (UART.c)</li> <li>HAL_UART_MspInit (UART.c)</li> <li>HAL_UART_RxCpltCallback (UART.c)</li> <li>HAL_UART_TxCpltCallback (UART.c)</li> </ul>"},{"location":"BSP/functions/#i","title":"i","text":"<ul> <li>is_uart_initialized (UART.c)</li> </ul>"},{"location":"BSP/functions/#t","title":"t","text":"<ul> <li>transmit (CAN.c)</li> </ul>"},{"location":"BSP/functions/#u","title":"u","text":"<ul> <li>uart_deinit (UART.h, UART.c)</li> <li>uart_init (UART.h, UART.c)</li> <li>uart_recv (UART.h, UART.c)</li> <li>uart_send (UART.h, UART.c)</li> </ul>"},{"location":"BSP/macros/","title":"Macros","text":""},{"location":"BSP/macros/#d","title":"d","text":"<ul> <li>DATA_SIZE (CAN.c, UART.c)</li> </ul>"},{"location":"BSP/macros/#u","title":"u","text":"<ul> <li>UART_NVIC_PREEMPT_PRIO (UART.c)</li> </ul>"},{"location":"BSP/variables/","title":"Variables","text":""},{"location":"BSP/variables/#a","title":"a","text":"<ul> <li>adc_status_t (ADC.h)</li> <li>adc_err_code (ADC.c)</li> </ul>"},{"location":"BSP/variables/#c","title":"c","text":"<ul> <li>can_status_t (CAN.h)</li> </ul>"},{"location":"BSP/variables/#u","title":"u","text":"<ul> <li>uart_status_t (UART.h)</li> </ul>"},{"location":"BSP/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Common/annotated/","title":"Class List","text":"<p>No classes, structs, unions or interfaces found.</p>"},{"location":"Common/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir common <ul> <li>dir Inc <ul> <li>file FreeRTOSConfig.h </li> <li>file queue_ex.h </li> <li>file stm32f4xx_hal_conf.h </li> <li>file stm32l4xx_hal_conf.h HAL configuration template file. This file should be copied to the application folder and renamed to stm32l4xx_hal_conf.h . </li> <li>file stm32xx_hal.h </li> </ul> </li> <li>dir Src <ul> <li>file freertos.c </li> <li>file syscalls.c Minimal System calls file. </li> <li>file sysmem.c System Memory calls file. </li> </ul> </li> </ul> </li> </ul>"},{"location":"Common/dir_bdd9a5d540de89e9fe90efdfc6973a4f/","title":"Dir common","text":"<p>FileList &gt; common</p>"},{"location":"Common/dir_bdd9a5d540de89e9fe90efdfc6973a4f/#directories","title":"Directories","text":"Type Name dir Inc dir Src <p>The documentation for this class was generated from the following file <code>common/</code></p>"},{"location":"Common/dir_4152f073bf32bf79124b676c9fe2adc1/","title":"Dir common/Inc","text":"<p>FileList &gt; common &gt; Inc</p>"},{"location":"Common/dir_4152f073bf32bf79124b676c9fe2adc1/#files","title":"Files","text":"Type Name file FreeRTOSConfig.h file queue_ex.h file stm32f4xx_hal_conf.h file stm32l4xx_hal_conf.h HAL configuration template file. This file should be copied to the application folder and renamed to stm32l4xx_hal_conf.h . file stm32xx_hal.h <p>The documentation for this class was generated from the following file <code>common/Inc/</code></p>"},{"location":"Common/_free_r_t_o_s_config_8h/","title":"File FreeRTOSConfig.h","text":"<p>FileList &gt; common &gt; Inc &gt; FreeRTOSConfig.h</p> <p>Go to the source code of this file</p>"},{"location":"Common/_free_r_t_o_s_config_8h/#macros","title":"Macros","text":"Type Name define INCLUDE_uxTaskPriorityGet <code>1</code> define INCLUDE_vTaskCleanUpResources <code>0</code> define INCLUDE_vTaskDelay <code>1</code> define INCLUDE_vTaskDelayUntil <code>1</code> define INCLUDE_vTaskDelete <code>1</code> define INCLUDE_vTaskPrioritySet <code>1</code> define INCLUDE_vTaskSuspend <code>1</code> define INCLUDE_xTaskGetSchedulerState <code>1</code> define configASSERT (x) <code>if ((x) == 0) {taskDISABLE\\_INTERRUPTS(); for( ;; );}</code> define configCPU_CLOCK_HZ <code>( SystemCoreClock )</code> define configENABLE_FPU <code>1</code> define configENABLE_MPU <code>0</code> define configKERNEL_INTERRUPT_PRIORITY <code>( configLIBRARY\\_LOWEST\\_INTERRUPT\\_PRIORITY &amp;lt;&amp;lt; (8 - configPRIO\\_BITS) )</code> define configLIBRARY_LOWEST_INTERRUPT_PRIORITY <code>15</code> define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY <code>5</code> define configMAX_CO_ROUTINE_PRIORITIES <code>( 2 )</code> define configMAX_PRIORITIES <code>( 7 )</code> define configMAX_SYSCALL_INTERRUPT_PRIORITY <code>( configLIBRARY\\_MAX\\_SYSCALL\\_INTERRUPT\\_PRIORITY &amp;lt;&amp;lt; (8 - configPRIO\\_BITS) )</code> define configMAX_TASK_NAME_LEN <code>( 16 )</code> define configMESSAGE_BUFFER_LENGTH_TYPE <code>size\\_t</code> define configMINIMAL_STACK_SIZE <code>((uint16\\_t)128)</code> define configPRIO_BITS <code>4</code> define configQUEUE_REGISTRY_SIZE <code>8</code> define configSUPPORT_DYNAMIC_ALLOCATION <code>0</code> define configSUPPORT_STATIC_ALLOCATION <code>1</code> define configTICK_RATE_HZ <code>((TickType\\_t)1000)</code> define configTIMER_QUEUE_LENGTH <code>10</code> define configTIMER_TASK_PRIORITY <code>( 2 )</code> define configTIMER_TASK_STACK_DEPTH <code>256</code> define configUSE_16_BIT_TICKS <code>0</code> define configUSE_COUNTING_SEMAPHORES <code>1</code> define configUSE_CO_ROUTINES <code>0</code> define configUSE_IDLE_HOOK <code>0</code> define configUSE_MUTEXES <code>1</code> define configUSE_PORT_OPTIMISED_TASK_SELECTION <code>1</code> define configUSE_PREEMPTION <code>1</code> define configUSE_RECURSIVE_MUTEXES <code>1</code> define configUSE_TICK_HOOK <code>0</code> define configUSE_TIMERS <code>1</code> define vPortSVCHandler <code>SVC\\_Handler</code> define xPortPendSVHandler <code>PendSV\\_Handler</code> define xPortSysTickHandler <code>SysTick\\_Handler</code>"},{"location":"Common/_free_r_t_o_s_config_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Common/_free_r_t_o_s_config_8h/#define-include_uxtaskpriorityget","title":"define INCLUDE_uxTaskPriorityGet","text":"<pre><code>#define INCLUDE_uxTaskPriorityGet `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-include_vtaskcleanupresources","title":"define INCLUDE_vTaskCleanUpResources","text":"<pre><code>#define INCLUDE_vTaskCleanUpResources `0`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-include_vtaskdelay","title":"define INCLUDE_vTaskDelay","text":"<pre><code>#define INCLUDE_vTaskDelay `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-include_vtaskdelayuntil","title":"define INCLUDE_vTaskDelayUntil","text":"<pre><code>#define INCLUDE_vTaskDelayUntil `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-include_vtaskdelete","title":"define INCLUDE_vTaskDelete","text":"<pre><code>#define INCLUDE_vTaskDelete `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-include_vtaskpriorityset","title":"define INCLUDE_vTaskPrioritySet","text":"<pre><code>#define INCLUDE_vTaskPrioritySet `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-include_vtasksuspend","title":"define INCLUDE_vTaskSuspend","text":"<pre><code>#define INCLUDE_vTaskSuspend `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-include_xtaskgetschedulerstate","title":"define INCLUDE_xTaskGetSchedulerState","text":"<pre><code>#define INCLUDE_xTaskGetSchedulerState `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configassert","title":"define configASSERT","text":"<pre><code>#define configASSERT (\n    x\n) `if ((x) == 0) {taskDISABLE_INTERRUPTS(); for( ;; );}`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configcpu_clock_hz","title":"define configCPU_CLOCK_HZ","text":"<pre><code>#define configCPU_CLOCK_HZ `( SystemCoreClock )`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configenable_fpu","title":"define configENABLE_FPU","text":"<pre><code>#define configENABLE_FPU `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configenable_mpu","title":"define configENABLE_MPU","text":"<pre><code>#define configENABLE_MPU `0`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configkernel_interrupt_priority","title":"define configKERNEL_INTERRUPT_PRIORITY","text":"<pre><code>#define configKERNEL_INTERRUPT_PRIORITY `( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configlibrary_lowest_interrupt_priority","title":"define configLIBRARY_LOWEST_INTERRUPT_PRIORITY","text":"<pre><code>#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY `15`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configlibrary_max_syscall_interrupt_priority","title":"define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY","text":"<pre><code>#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY `5`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configmax_co_routine_priorities","title":"define configMAX_CO_ROUTINE_PRIORITIES","text":"<pre><code>#define configMAX_CO_ROUTINE_PRIORITIES `( 2 )`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configmax_priorities","title":"define configMAX_PRIORITIES","text":"<pre><code>#define configMAX_PRIORITIES `( 7 )`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configmax_syscall_interrupt_priority","title":"define configMAX_SYSCALL_INTERRUPT_PRIORITY","text":"<pre><code>#define configMAX_SYSCALL_INTERRUPT_PRIORITY `( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configmax_task_name_len","title":"define configMAX_TASK_NAME_LEN","text":"<pre><code>#define configMAX_TASK_NAME_LEN `( 16 )`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configmessage_buffer_length_type","title":"define configMESSAGE_BUFFER_LENGTH_TYPE","text":"<pre><code>#define configMESSAGE_BUFFER_LENGTH_TYPE `size_t`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configminimal_stack_size","title":"define configMINIMAL_STACK_SIZE","text":"<pre><code>#define configMINIMAL_STACK_SIZE `((uint16_t)128)`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configprio_bits","title":"define configPRIO_BITS","text":"<pre><code>#define configPRIO_BITS `4`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configqueue_registry_size","title":"define configQUEUE_REGISTRY_SIZE","text":"<pre><code>#define configQUEUE_REGISTRY_SIZE `8`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configsupport_dynamic_allocation","title":"define configSUPPORT_DYNAMIC_ALLOCATION","text":"<pre><code>#define configSUPPORT_DYNAMIC_ALLOCATION `0`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configsupport_static_allocation","title":"define configSUPPORT_STATIC_ALLOCATION","text":"<pre><code>#define configSUPPORT_STATIC_ALLOCATION `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configtick_rate_hz","title":"define configTICK_RATE_HZ","text":"<pre><code>#define configTICK_RATE_HZ `((TickType_t)1000)`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configtimer_queue_length","title":"define configTIMER_QUEUE_LENGTH","text":"<pre><code>#define configTIMER_QUEUE_LENGTH `10`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configtimer_task_priority","title":"define configTIMER_TASK_PRIORITY","text":"<pre><code>#define configTIMER_TASK_PRIORITY `( 2 )`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configtimer_task_stack_depth","title":"define configTIMER_TASK_STACK_DEPTH","text":"<pre><code>#define configTIMER_TASK_STACK_DEPTH `256`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configuse_16_bit_ticks","title":"define configUSE_16_BIT_TICKS","text":"<pre><code>#define configUSE_16_BIT_TICKS `0`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configuse_counting_semaphores","title":"define configUSE_COUNTING_SEMAPHORES","text":"<pre><code>#define configUSE_COUNTING_SEMAPHORES `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configuse_co_routines","title":"define configUSE_CO_ROUTINES","text":"<pre><code>#define configUSE_CO_ROUTINES `0`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configuse_idle_hook","title":"define configUSE_IDLE_HOOK","text":"<pre><code>#define configUSE_IDLE_HOOK `0`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configuse_mutexes","title":"define configUSE_MUTEXES","text":"<pre><code>#define configUSE_MUTEXES `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configuse_port_optimised_task_selection","title":"define configUSE_PORT_OPTIMISED_TASK_SELECTION","text":"<pre><code>#define configUSE_PORT_OPTIMISED_TASK_SELECTION `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configuse_preemption","title":"define configUSE_PREEMPTION","text":"<pre><code>#define configUSE_PREEMPTION `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configuse_recursive_mutexes","title":"define configUSE_RECURSIVE_MUTEXES","text":"<pre><code>#define configUSE_RECURSIVE_MUTEXES `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configuse_tick_hook","title":"define configUSE_TICK_HOOK","text":"<pre><code>#define configUSE_TICK_HOOK `0`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-configuse_timers","title":"define configUSE_TIMERS","text":"<pre><code>#define configUSE_TIMERS `1`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-vportsvchandler","title":"define vPortSVCHandler","text":"<pre><code>#define vPortSVCHandler `SVC_Handler`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-xportpendsvhandler","title":"define xPortPendSVHandler","text":"<pre><code>#define xPortPendSVHandler `PendSV_Handler`\n</code></pre>"},{"location":"Common/_free_r_t_o_s_config_8h/#define-xportsystickhandler","title":"define xPortSysTickHandler","text":"<pre><code>#define xPortSysTickHandler `SysTick_Handler`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/Inc/FreeRTOSConfig.h</code></p>"},{"location":"Common/_free_r_t_o_s_config_8h_source/","title":"File FreeRTOSConfig.h","text":"<p>File List &gt; common &gt; Inc &gt; FreeRTOSConfig.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * FreeRTOS Kernel V10.3.1\n * Portion Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\n * Portion Copyright (C) 2019 StMicroelectronics, Inc.  All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * http://www.FreeRTOS.org\n * http://aws.amazon.com/freertos\n *\n * 1 tab == 4 spaces!\n */\n\n#ifndef FREERTOS_CONFIG_H\n#define FREERTOS_CONFIG_H\n\n/*-----------------------------------------------------------\n * Application specific definitions.\n *\n * These definitions should be adjusted for your particular hardware and\n * application requirements.\n *\n * These parameters and more are described within the 'configuration' section of the\n * FreeRTOS API documentation available on the FreeRTOS.org web site.\n *\n * See http://www.freertos.org/a00110.html\n *----------------------------------------------------------*/\n\n/* Section where include file can be added */\n\n/* Ensure definitions are only used by the compiler, and not by the assembler. */\n#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)\n  #include &lt;stdint.h&gt;\n  extern uint32_t SystemCoreClock;\n#endif\n#define configENABLE_FPU                         1\n#define configENABLE_MPU                         0\n\n#define configUSE_PREEMPTION                     1\n#define configSUPPORT_STATIC_ALLOCATION          1\n#define configSUPPORT_DYNAMIC_ALLOCATION         0\n#define configUSE_IDLE_HOOK                      0\n#define configUSE_TICK_HOOK                      0\n#define configCPU_CLOCK_HZ                       ( SystemCoreClock )\n#define configTICK_RATE_HZ                       ((TickType_t)1000)\n#define configMAX_PRIORITIES                     ( 7 )\n#define configMINIMAL_STACK_SIZE                 ((uint16_t)128)\n#define configMAX_TASK_NAME_LEN                  ( 16 )\n#define configUSE_16_BIT_TICKS                   0\n#define configUSE_MUTEXES                        1\n#define configQUEUE_REGISTRY_SIZE                8\n#define configUSE_RECURSIVE_MUTEXES              1\n#define configUSE_COUNTING_SEMAPHORES            1\n#define configUSE_PORT_OPTIMISED_TASK_SELECTION  1\n/* Defaults to size_t for backward compatibility, but can be changed\n   if lengths will always be less than the number of bytes in a size_t. */\n#define configMESSAGE_BUFFER_LENGTH_TYPE         size_t\n\n/* Co-routine definitions. */\n#define configUSE_CO_ROUTINES                    0\n#define configMAX_CO_ROUTINE_PRIORITIES          ( 2 )\n\n/* Software timer definitions. */\n#define configUSE_TIMERS                         1\n#define configTIMER_TASK_PRIORITY                ( 2 )\n#define configTIMER_QUEUE_LENGTH                 10\n#define configTIMER_TASK_STACK_DEPTH             256\n\n/* Set the following definitions to 1 to include the API function, or zero\nto exclude the API function. */\n#define INCLUDE_vTaskPrioritySet             1\n#define INCLUDE_uxTaskPriorityGet            1\n#define INCLUDE_vTaskDelete                  1\n#define INCLUDE_vTaskCleanUpResources        0\n#define INCLUDE_vTaskSuspend                 1\n#define INCLUDE_vTaskDelayUntil              1\n#define INCLUDE_vTaskDelay                   1\n#define INCLUDE_xTaskGetSchedulerState       1\n\n/* Cortex-M specific definitions. */\n#ifdef __NVIC_PRIO_BITS\n /* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */\n #define configPRIO_BITS         __NVIC_PRIO_BITS\n#else\n #define configPRIO_BITS         4\n#endif\n\n/* The lowest interrupt priority that can be used in a call to a \"set priority\"\nfunction. */\n#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY   15\n\n/* The highest interrupt priority that can be used by any interrupt service\nroutine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL\nINTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER\nPRIORITY THAN THIS! (higher priorities are lower numeric values. */\n#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5\n\n/* Interrupt priorities used by the kernel port layer itself.  These are generic\nto all Cortex-M ports, and do not rely on any particular library functions. */\n#define configKERNEL_INTERRUPT_PRIORITY         ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )\n/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!\nSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */\n#define configMAX_SYSCALL_INTERRUPT_PRIORITY    ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )\n\n/* Normal assert() semantics without relying on the provision of an assert.h\nheader file. */\n#define configASSERT( x ) if ((x) == 0) {taskDISABLE_INTERRUPTS(); for( ;; );}\n\n/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS\nstandard names. */\n#define vPortSVCHandler    SVC_Handler\n#define xPortPendSVHandler PendSV_Handler\n\n/* IMPORTANT: This define is commented when used with STM32Cube firmware, when the timebase source is SysTick,\n              to prevent overwriting SysTick_Handler defined within STM32Cube HAL */\n\n#define xPortSysTickHandler SysTick_Handler\n\n/* Section where parameter definitions can be added (for instance, to override default ones in FreeRTOS.h) */\\\n\n#endif /* FREERTOS_CONFIG_H */\n</code></pre>"},{"location":"Common/queue__ex_8h/","title":"File queue_ex.h","text":"<p>FileList &gt; common &gt; Inc &gt; queue_ex.h</p> <p>Go to the source code of this file</p>"},{"location":"Common/queue__ex_8h/#macros","title":"Macros","text":"Type Name define xQueueSendCircularBuffer (xQueue, pvItemToQueue, xTicksToWait, QUEUE_ITEM_SIZE) <code>/* multi line expression */</code> define xQueueSendCircularBufferFromISR (xQueue, pvItemToQueue, pxHigherPriorityTaskWoken, QUEUE_ITEM_SIZE) <code>/* multi line expression */</code>"},{"location":"Common/queue__ex_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Common/queue__ex_8h/#define-xqueuesendcircularbuffer","title":"define xQueueSendCircularBuffer","text":"<pre><code>#define xQueueSendCircularBuffer (\n    xQueue,\n    pvItemToQueue,\n    xTicksToWait,\n    QUEUE_ITEM_SIZE\n) `/* multi line expression */`\n</code></pre>"},{"location":"Common/queue__ex_8h/#define-xqueuesendcircularbufferfromisr","title":"define xQueueSendCircularBufferFromISR","text":"<pre><code>#define xQueueSendCircularBufferFromISR (\n    xQueue,\n    pvItemToQueue,\n    pxHigherPriorityTaskWoken,\n    QUEUE_ITEM_SIZE\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/Inc/queue_ex.h</code></p>"},{"location":"Common/queue__ex_8h_source/","title":"File queue_ex.h","text":"<p>File List &gt; common &gt; Inc &gt; queue_ex.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QUEUE_EX_H\n#define QUEUE_EX_H\n\n#define xQueueSendCircularBuffer( xQueue, pvItemToQueue, xTicksToWait, QUEUE_ITEM_SIZE ) \\\n    do { \\\n        taskENTER_CRITICAL(); \\\n        if (xQueueSend(xQueue, pvItemToQueue, 0) == errQUEUE_FULL) \\\n        { \\\n            uint8_t tempBuffer[QUEUE_ITEM_SIZE]; \\\n            xQueueReceive(xQueue, tempBuffer, 0); \\\n            xQueueSend(xQueue, pvItemToQueue, xTicksToWait); \\\n        } \\\n        taskEXIT_CRITICAL(); \\\n    } while(0)\n\n#define xQueueSendCircularBufferFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken, QUEUE_ITEM_SIZE ) \\\n    do { \\\n        UBaseType_t uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR(); \\\n        if (xQueueSendFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken) == errQUEUE_FULL) { \\\n            uint8_t tempBuffer[QUEUE_ITEM_SIZE];    \\\n            xQueueReceiveFromISR(xQueue, tempBuffer, NULL); \\\n            xQueueSendFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken);    \\\n        }   \\\n        taskEXIT_CRITICAL_FROM_ISR(uxSavedInterruptStatus); \\\n    } while(0)\n\n#endif\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/","title":"File stm32f4xx_hal_conf.h","text":"<p>FileList &gt; common &gt; Inc &gt; stm32f4xx_hal_conf.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"stm32f4xx_hal_rcc.h\"</code></li> <li><code>#include \"stm32f4xx_hal_gpio.h\"</code></li> <li><code>#include \"stm32f4xx_hal_exti.h\"</code></li> <li><code>#include \"stm32f4xx_hal_dma.h\"</code></li> <li><code>#include \"stm32f4xx_hal_cortex.h\"</code></li> <li><code>#include \"stm32f4xx_hal_adc.h\"</code></li> <li><code>#include \"stm32f4xx_hal_can.h\"</code></li> <li><code>#include \"stm32f4xx_hal_dac.h\"</code></li> <li><code>#include \"stm32f4xx_hal_flash.h\"</code></li> <li><code>#include \"stm32f4xx_hal_i2c.h\"</code></li> <li><code>#include \"stm32f4xx_hal_i2s.h\"</code></li> <li><code>#include \"stm32f4xx_hal_iwdg.h\"</code></li> <li><code>#include \"stm32f4xx_hal_pwr.h\"</code></li> <li><code>#include \"stm32f4xx_hal_rng.h\"</code></li> <li><code>#include \"stm32f4xx_hal_rtc.h\"</code></li> <li><code>#include \"stm32f4xx_hal_sd.h\"</code></li> <li><code>#include \"stm32f4xx_hal_spi.h\"</code></li> <li><code>#include \"stm32f4xx_hal_tim.h\"</code></li> <li><code>#include \"stm32f4xx_hal_uart.h\"</code></li> <li><code>#include \"stm32f4xx_hal_usart.h\"</code></li> <li><code>#include \"stm32f4xx_hal_wwdg.h\"</code></li> </ul>"},{"location":"Common/stm32f4xx__hal__conf_8h/#macros","title":"Macros","text":"Type Name define DATA_CACHE_ENABLE <code>1U</code> define DP83848_PHY_ADDRESS define ETH_RXBUFNB <code>4U       /\\* 4 Rx buffers of size ETH\\_RX\\_BUF\\_SIZE  \\*/</code> define ETH_RX_BUF_SIZE <code>ETH\\_MAX\\_PACKET\\_SIZE /\\* buffer size for receive               \\*/</code> define ETH_TXBUFNB <code>4U       /\\* 4 Tx buffers of size ETH\\_TX\\_BUF\\_SIZE  \\*/</code> define ETH_TX_BUF_SIZE <code>ETH\\_MAX\\_PACKET\\_SIZE /\\* buffer size for transmit              \\*/</code> define EXTERNAL_CLOCK_VALUE <code>12288000U</code>External clock source for I2S peripheral This value is used by the I2S HAL module to compute the I2S clock source frequency, this source is inserted directly through I2S_CKIN pad. define HAL_ADC_MODULE_ENABLED define HAL_CAN_MODULE_ENABLED define HAL_CORTEX_MODULE_ENABLED define HAL_DAC_MODULE_ENABLED define HAL_DMA_MODULE_ENABLED define HAL_EXTI_MODULE_ENABLED define HAL_FLASH_MODULE_ENABLED define HAL_GPIO_MODULE_ENABLED define HAL_I2C_MODULE_ENABLED define HAL_I2S_MODULE_ENABLED define HAL_IWDG_MODULE_ENABLED define HAL_MODULE_ENABLED This is the list of modules to be used in the HAL driver. define HAL_PWR_MODULE_ENABLED define HAL_RCC_MODULE_ENABLED define HAL_RNG_MODULE_ENABLED define HAL_RTC_MODULE_ENABLED define HAL_SD_MODULE_ENABLED define HAL_SPI_MODULE_ENABLED define HAL_TIM_MODULE_ENABLED define HAL_UART_MODULE_ENABLED define HAL_USART_MODULE_ENABLED define HAL_WWDG_MODULE_ENABLED define HSE_STARTUP_TIMEOUT <code>100U</code> define HSE_VALUE <code>25000000U</code>Adjust the value of External High Speed oscillator (HSE) used in your application. This value is used by the RCC HAL module to compute the system frequency (when HSE is used as system clock source, directly or through the PLL). define HSI_VALUE <code>((uint32\\_t)16000000U)</code>Internal High Speed oscillator (HSI) value. This value is used by the RCC HAL module to compute the system frequency (when HSI is used as system clock source, directly or through the PLL). define INSTRUCTION_CACHE_ENABLE <code>1U</code> define LSE_STARTUP_TIMEOUT <code>5000U</code> define LSE_VALUE <code>32768U</code>External Low Speed oscillator (LSE) value. define LSI_VALUE <code>32000U</code>Internal Low Speed oscillator (LSI) value. define MAC_ADDR0 <code>2U</code>Uncomment the line below to expanse the \"assert_param\" macro in the HAL drivers code. define MAC_ADDR1 <code>0U</code> define MAC_ADDR2 <code>0U</code> define MAC_ADDR3 <code>0U</code> define MAC_ADDR4 <code>0U</code> define MAC_ADDR5 <code>0U</code> define PHY_AUTONEGOTIATION <code>((uint16\\_t)0x1000U)</code> define PHY_AUTONEGO_COMPLETE <code>((uint16\\_t)0x0020U)</code> define PHY_BCR <code>((uint16\\_t)0x0000U)</code> define PHY_BSR <code>((uint16\\_t)0x0001U)</code> define PHY_CONFIG_DELAY <code>0x00000FFFU</code> define PHY_DUPLEX_STATUS <code>((uint16\\_t))</code> define PHY_FULLDUPLEX_100M <code>((uint16\\_t)0x2100U)</code> define PHY_FULLDUPLEX_10M <code>((uint16\\_t)0x0100U)</code> define PHY_HALFDUPLEX_100M <code>((uint16\\_t)0x2000U)</code> define PHY_HALFDUPLEX_10M <code>((uint16\\_t)0x0000U)</code> define PHY_ISOLATE <code>((uint16\\_t)0x0400U)</code> define PHY_JABBER_DETECTION <code>((uint16\\_t)0x0002U)</code> define PHY_LINKED_STATUS <code>((uint16\\_t)0x0004U)</code> define PHY_LOOPBACK <code>((uint16\\_t)0x4000U)</code> define PHY_POWERDOWN <code>((uint16\\_t)0x0800U)</code> define PHY_READ_TO <code>0x0000FFFFU</code> define PHY_RESET <code>((uint16\\_t)0x8000U)</code> define PHY_RESET_DELAY <code>0x000000FFU</code> define PHY_RESTART_AUTONEGOTIATION <code>((uint16\\_t)0x0200U)</code> define PHY_SPEED_STATUS <code>((uint16\\_t))</code> define PHY_SR <code>((uint16\\_t))</code> define PHY_WRITE_TO <code>0x0000FFFFU</code> define PREFETCH_ENABLE <code>1U</code> define TICK_INT_PRIORITY <code>15U</code> define USE_HAL_ADC_REGISTER_CALLBACKS <code>0U /\\* ADC register callback disabled       \\*/</code> define USE_HAL_CAN_REGISTER_CALLBACKS <code>0U /\\* CAN register callback disabled       \\*/</code> define USE_HAL_CEC_REGISTER_CALLBACKS <code>0U /\\* CEC register callback disabled       \\*/</code> define USE_HAL_CRYP_REGISTER_CALLBACKS <code>0U /\\* CRYP register callback disabled      \\*/</code> define USE_HAL_DAC_REGISTER_CALLBACKS <code>0U /\\* DAC register callback disabled       \\*/</code> define USE_HAL_DCMI_REGISTER_CALLBACKS <code>0U /\\* DCMI register callback disabled      \\*/</code> define USE_HAL_DFSDM_REGISTER_CALLBACKS <code>0U /\\* DFSDM register callback disabled     \\*/</code> define USE_HAL_DMA2D_REGISTER_CALLBACKS <code>0U /\\* DMA2D register callback disabled     \\*/</code> define USE_HAL_DSI_REGISTER_CALLBACKS <code>0U /\\* DSI register callback disabled       \\*/</code> define USE_HAL_ETH_REGISTER_CALLBACKS <code>0U /\\* ETH register callback disabled       \\*/</code> define USE_HAL_FMPI2C_REGISTER_CALLBACKS <code>0U /\\* FMPI2C register callback disabled    \\*/</code> define USE_HAL_FMPSMBUS_REGISTER_CALLBACKS <code>0U /\\* FMPSMBUS register callback disabled  \\*/</code> define USE_HAL_HASH_REGISTER_CALLBACKS <code>0U /\\* HASH register callback disabled      \\*/</code> define USE_HAL_HCD_REGISTER_CALLBACKS <code>0U /\\* HCD register callback disabled       \\*/</code> define USE_HAL_I2C_REGISTER_CALLBACKS <code>0U /\\* I2C register callback disabled       \\*/</code> define USE_HAL_I2S_REGISTER_CALLBACKS <code>0U /\\* I2S register callback disabled       \\*/</code> define USE_HAL_IRDA_REGISTER_CALLBACKS <code>0U /\\* IRDA register callback disabled      \\*/</code> define USE_HAL_LPTIM_REGISTER_CALLBACKS <code>0U /\\* LPTIM register callback disabled     \\*/</code> define USE_HAL_LTDC_REGISTER_CALLBACKS <code>0U /\\* LTDC register callback disabled      \\*/</code> define USE_HAL_MMC_REGISTER_CALLBACKS <code>0U /\\* MMC register callback disabled       \\*/</code> define USE_HAL_NAND_REGISTER_CALLBACKS <code>0U /\\* NAND register callback disabled      \\*/</code> define USE_HAL_NOR_REGISTER_CALLBACKS <code>0U /\\* NOR register callback disabled       \\*/</code> define USE_HAL_PCCARD_REGISTER_CALLBACKS <code>0U /\\* PCCARD register callback disabled    \\*/</code> define USE_HAL_PCD_REGISTER_CALLBACKS <code>0U /\\* PCD register callback disabled       \\*/</code> define USE_HAL_QSPI_REGISTER_CALLBACKS <code>0U /\\* QSPI register callback disabled      \\*/</code> define USE_HAL_RNG_REGISTER_CALLBACKS <code>0U /\\* RNG register callback disabled       \\*/</code> define USE_HAL_RTC_REGISTER_CALLBACKS <code>0U /\\* RTC register callback disabled       \\*/</code> define USE_HAL_SAI_REGISTER_CALLBACKS <code>0U /\\* SAI register callback disabled       \\*/</code> define USE_HAL_SDRAM_REGISTER_CALLBACKS <code>0U /\\* SDRAM register callback disabled     \\*/</code> define USE_HAL_SD_REGISTER_CALLBACKS <code>0U /\\* SD register callback disabled        \\*/</code> define USE_HAL_SMARTCARD_REGISTER_CALLBACKS <code>0U /\\* SMARTCARD register callback disabled \\*/</code> define USE_HAL_SMBUS_REGISTER_CALLBACKS <code>0U /\\* SMBUS register callback disabled     \\*/</code> define USE_HAL_SPDIFRX_REGISTER_CALLBACKS <code>0U /\\* SPDIFRX register callback disabled   \\*/</code> define USE_HAL_SPI_REGISTER_CALLBACKS <code>0U /\\* SPI register callback disabled       \\*/</code> define USE_HAL_SRAM_REGISTER_CALLBACKS <code>0U /\\* SRAM register callback disabled      \\*/</code> define USE_HAL_TIM_REGISTER_CALLBACKS <code>0U /\\* TIM register callback disabled       \\*/</code> define USE_HAL_UART_REGISTER_CALLBACKS <code>0U /\\* UART register callback disabled      \\*/</code> define USE_HAL_USART_REGISTER_CALLBACKS <code>0U /\\* USART register callback disabled     \\*/</code> define USE_HAL_WWDG_REGISTER_CALLBACKS <code>0U /\\* WWDG register callback disabled      \\*/</code> define USE_RTOS <code>0U</code> define USE_SPI_CRC <code>0U</code> define VDD_VALUE <code>3300U</code>This is the HAL system configuration section. define assert_param (expr) <code>((void)0U)</code>Include module's header file."},{"location":"Common/stm32f4xx__hal__conf_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Common/stm32f4xx__hal__conf_8h/#define-data_cache_enable","title":"define DATA_CACHE_ENABLE","text":"<pre><code>#define DATA_CACHE_ENABLE `1U`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-dp83848_phy_address","title":"define DP83848_PHY_ADDRESS","text":"<pre><code>#define DP83848_PHY_ADDRESS \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-eth_rxbufnb","title":"define ETH_RXBUFNB","text":"<pre><code>#define ETH_RXBUFNB `4U       /* 4 Rx buffers of size ETH_RX_BUF_SIZE  */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-eth_rx_buf_size","title":"define ETH_RX_BUF_SIZE","text":"<pre><code>#define ETH_RX_BUF_SIZE `ETH_MAX_PACKET_SIZE /* buffer size for receive               */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-eth_txbufnb","title":"define ETH_TXBUFNB","text":"<pre><code>#define ETH_TXBUFNB `4U       /* 4 Tx buffers of size ETH_TX_BUF_SIZE  */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-eth_tx_buf_size","title":"define ETH_TX_BUF_SIZE","text":"<pre><code>#define ETH_TX_BUF_SIZE `ETH_MAX_PACKET_SIZE /* buffer size for transmit              */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-external_clock_value","title":"define EXTERNAL_CLOCK_VALUE","text":"<p>External clock source for I2S peripheral This value is used by the I2S HAL module to compute the I2S clock source frequency, this source is inserted directly through I2S_CKIN pad. </p> <pre><code>#define EXTERNAL_CLOCK_VALUE `12288000U`\n</code></pre> <p>Value of the External audio frequency in Hz </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_adc_module_enabled","title":"define HAL_ADC_MODULE_ENABLED","text":"<pre><code>#define HAL_ADC_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_can_module_enabled","title":"define HAL_CAN_MODULE_ENABLED","text":"<pre><code>#define HAL_CAN_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_cortex_module_enabled","title":"define HAL_CORTEX_MODULE_ENABLED","text":"<pre><code>#define HAL_CORTEX_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_dac_module_enabled","title":"define HAL_DAC_MODULE_ENABLED","text":"<pre><code>#define HAL_DAC_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_dma_module_enabled","title":"define HAL_DMA_MODULE_ENABLED","text":"<pre><code>#define HAL_DMA_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_exti_module_enabled","title":"define HAL_EXTI_MODULE_ENABLED","text":"<pre><code>#define HAL_EXTI_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_flash_module_enabled","title":"define HAL_FLASH_MODULE_ENABLED","text":"<pre><code>#define HAL_FLASH_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_gpio_module_enabled","title":"define HAL_GPIO_MODULE_ENABLED","text":"<pre><code>#define HAL_GPIO_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_i2c_module_enabled","title":"define HAL_I2C_MODULE_ENABLED","text":"<pre><code>#define HAL_I2C_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_i2s_module_enabled","title":"define HAL_I2S_MODULE_ENABLED","text":"<pre><code>#define HAL_I2S_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_iwdg_module_enabled","title":"define HAL_IWDG_MODULE_ENABLED","text":"<pre><code>#define HAL_IWDG_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_module_enabled","title":"define HAL_MODULE_ENABLED","text":"<p>This is the list of modules to be used in the HAL driver. </p> <pre><code>#define HAL_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_pwr_module_enabled","title":"define HAL_PWR_MODULE_ENABLED","text":"<pre><code>#define HAL_PWR_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_rcc_module_enabled","title":"define HAL_RCC_MODULE_ENABLED","text":"<pre><code>#define HAL_RCC_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_rng_module_enabled","title":"define HAL_RNG_MODULE_ENABLED","text":"<pre><code>#define HAL_RNG_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_rtc_module_enabled","title":"define HAL_RTC_MODULE_ENABLED","text":"<pre><code>#define HAL_RTC_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_sd_module_enabled","title":"define HAL_SD_MODULE_ENABLED","text":"<pre><code>#define HAL_SD_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_spi_module_enabled","title":"define HAL_SPI_MODULE_ENABLED","text":"<pre><code>#define HAL_SPI_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_tim_module_enabled","title":"define HAL_TIM_MODULE_ENABLED","text":"<pre><code>#define HAL_TIM_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_uart_module_enabled","title":"define HAL_UART_MODULE_ENABLED","text":"<pre><code>#define HAL_UART_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_usart_module_enabled","title":"define HAL_USART_MODULE_ENABLED","text":"<pre><code>#define HAL_USART_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hal_wwdg_module_enabled","title":"define HAL_WWDG_MODULE_ENABLED","text":"<pre><code>#define HAL_WWDG_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hse_startup_timeout","title":"define HSE_STARTUP_TIMEOUT","text":"<pre><code>#define HSE_STARTUP_TIMEOUT `100U`\n</code></pre> <p>Time out for HSE start up, in ms </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hse_value","title":"define HSE_VALUE","text":"<p>Adjust the value of External High Speed oscillator (HSE) used in your application. This value is used by the RCC HAL module to compute the system frequency (when HSE is used as system clock source, directly or through the PLL). </p> <pre><code>#define HSE_VALUE `25000000U`\n</code></pre> <p>Value of the External oscillator in Hz </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-hsi_value","title":"define HSI_VALUE","text":"<p>Internal High Speed oscillator (HSI) value. This value is used by the RCC HAL module to compute the system frequency (when HSI is used as system clock source, directly or through the PLL). </p> <pre><code>#define HSI_VALUE `((uint32_t)16000000U)`\n</code></pre> <p>Value of the Internal oscillator in Hz </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-instruction_cache_enable","title":"define INSTRUCTION_CACHE_ENABLE","text":"<pre><code>#define INSTRUCTION_CACHE_ENABLE `1U`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-lse_startup_timeout","title":"define LSE_STARTUP_TIMEOUT","text":"<pre><code>#define LSE_STARTUP_TIMEOUT `5000U`\n</code></pre> <p>Time out for LSE start up, in ms </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-lse_value","title":"define LSE_VALUE","text":"<p>External Low Speed oscillator (LSE) value. </p> <pre><code>#define LSE_VALUE `32768U`\n</code></pre> <p>&lt; Value of the Internal Low Speed oscillator in Hz The real value may vary depending on the variations in voltage and temperature. Value of the External Low Speed oscillator in Hz </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-lsi_value","title":"define LSI_VALUE","text":"<p>Internal Low Speed oscillator (LSI) value. </p> <pre><code>#define LSI_VALUE `32000U`\n</code></pre> <p>LSI Typical Value in Hz </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-mac_addr0","title":"define MAC_ADDR0","text":"<p>Uncomment the line below to expanse the \"assert_param\" macro in the HAL drivers code. </p> <pre><code>#define MAC_ADDR0 `2U`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-mac_addr1","title":"define MAC_ADDR1","text":"<pre><code>#define MAC_ADDR1 `0U`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-mac_addr2","title":"define MAC_ADDR2","text":"<pre><code>#define MAC_ADDR2 `0U`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-mac_addr3","title":"define MAC_ADDR3","text":"<pre><code>#define MAC_ADDR3 `0U`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-mac_addr4","title":"define MAC_ADDR4","text":"<pre><code>#define MAC_ADDR4 `0U`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-mac_addr5","title":"define MAC_ADDR5","text":"<pre><code>#define MAC_ADDR5 `0U`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_autonegotiation","title":"define PHY_AUTONEGOTIATION","text":"<pre><code>#define PHY_AUTONEGOTIATION `((uint16_t)0x1000U)`\n</code></pre> <p>Enable auto-negotiation function </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_autonego_complete","title":"define PHY_AUTONEGO_COMPLETE","text":"<pre><code>#define PHY_AUTONEGO_COMPLETE `((uint16_t)0x0020U)`\n</code></pre> <p>Auto-Negotiation process completed </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_bcr","title":"define PHY_BCR","text":"<pre><code>#define PHY_BCR `((uint16_t)0x0000U)`\n</code></pre> <p>Transceiver Basic Control Register </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_bsr","title":"define PHY_BSR","text":"<pre><code>#define PHY_BSR `((uint16_t)0x0001U)`\n</code></pre> <p>Transceiver Basic Status Register </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_config_delay","title":"define PHY_CONFIG_DELAY","text":"<pre><code>#define PHY_CONFIG_DELAY `0x00000FFFU`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_duplex_status","title":"define PHY_DUPLEX_STATUS","text":"<pre><code>#define PHY_DUPLEX_STATUS `((uint16_t))`\n</code></pre> <p>PHY Duplex mask </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_fullduplex_100m","title":"define PHY_FULLDUPLEX_100M","text":"<pre><code>#define PHY_FULLDUPLEX_100M `((uint16_t)0x2100U)`\n</code></pre> <p>Set the full-duplex mode at 100 Mb/s </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_fullduplex_10m","title":"define PHY_FULLDUPLEX_10M","text":"<pre><code>#define PHY_FULLDUPLEX_10M `((uint16_t)0x0100U)`\n</code></pre> <p>Set the full-duplex mode at 10 Mb/s </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_halfduplex_100m","title":"define PHY_HALFDUPLEX_100M","text":"<pre><code>#define PHY_HALFDUPLEX_100M `((uint16_t)0x2000U)`\n</code></pre> <p>Set the half-duplex mode at 100 Mb/s </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_halfduplex_10m","title":"define PHY_HALFDUPLEX_10M","text":"<pre><code>#define PHY_HALFDUPLEX_10M `((uint16_t)0x0000U)`\n</code></pre> <p>Set the half-duplex mode at 10 Mb/s </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_isolate","title":"define PHY_ISOLATE","text":"<pre><code>#define PHY_ISOLATE `((uint16_t)0x0400U)`\n</code></pre> <p>Isolate PHY from MII </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_jabber_detection","title":"define PHY_JABBER_DETECTION","text":"<pre><code>#define PHY_JABBER_DETECTION `((uint16_t)0x0002U)`\n</code></pre> <p>Jabber condition detected </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_linked_status","title":"define PHY_LINKED_STATUS","text":"<pre><code>#define PHY_LINKED_STATUS `((uint16_t)0x0004U)`\n</code></pre> <p>Valid link established </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_loopback","title":"define PHY_LOOPBACK","text":"<pre><code>#define PHY_LOOPBACK `((uint16_t)0x4000U)`\n</code></pre> <p>Select loop-back mode </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_powerdown","title":"define PHY_POWERDOWN","text":"<pre><code>#define PHY_POWERDOWN `((uint16_t)0x0800U)`\n</code></pre> <p>Select the power down mode </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_read_to","title":"define PHY_READ_TO","text":"<pre><code>#define PHY_READ_TO `0x0000FFFFU`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_reset","title":"define PHY_RESET","text":"<pre><code>#define PHY_RESET `((uint16_t)0x8000U)`\n</code></pre> <p>PHY Reset </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_reset_delay","title":"define PHY_RESET_DELAY","text":"<pre><code>#define PHY_RESET_DELAY `0x000000FFU`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_restart_autonegotiation","title":"define PHY_RESTART_AUTONEGOTIATION","text":"<pre><code>#define PHY_RESTART_AUTONEGOTIATION `((uint16_t)0x0200U)`\n</code></pre> <p>Restart auto-negotiation function </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_speed_status","title":"define PHY_SPEED_STATUS","text":"<pre><code>#define PHY_SPEED_STATUS `((uint16_t))`\n</code></pre> <p>PHY Speed mask </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_sr","title":"define PHY_SR","text":"<pre><code>#define PHY_SR `((uint16_t))`\n</code></pre> <p>PHY status register Offset </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-phy_write_to","title":"define PHY_WRITE_TO","text":"<pre><code>#define PHY_WRITE_TO `0x0000FFFFU`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-prefetch_enable","title":"define PREFETCH_ENABLE","text":"<pre><code>#define PREFETCH_ENABLE `1U`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-tick_int_priority","title":"define TICK_INT_PRIORITY","text":"<pre><code>#define TICK_INT_PRIORITY `15U`\n</code></pre> <p>tick interrupt priority </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_adc_register_callbacks","title":"define USE_HAL_ADC_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_ADC_REGISTER_CALLBACKS `0U /* ADC register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_can_register_callbacks","title":"define USE_HAL_CAN_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_CAN_REGISTER_CALLBACKS `0U /* CAN register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_cec_register_callbacks","title":"define USE_HAL_CEC_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_CEC_REGISTER_CALLBACKS `0U /* CEC register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_cryp_register_callbacks","title":"define USE_HAL_CRYP_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_CRYP_REGISTER_CALLBACKS `0U /* CRYP register callback disabled      */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_dac_register_callbacks","title":"define USE_HAL_DAC_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_DAC_REGISTER_CALLBACKS `0U /* DAC register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_dcmi_register_callbacks","title":"define USE_HAL_DCMI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_DCMI_REGISTER_CALLBACKS `0U /* DCMI register callback disabled      */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_dfsdm_register_callbacks","title":"define USE_HAL_DFSDM_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_DFSDM_REGISTER_CALLBACKS `0U /* DFSDM register callback disabled     */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_dma2d_register_callbacks","title":"define USE_HAL_DMA2D_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_DMA2D_REGISTER_CALLBACKS `0U /* DMA2D register callback disabled     */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_dsi_register_callbacks","title":"define USE_HAL_DSI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_DSI_REGISTER_CALLBACKS `0U /* DSI register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_eth_register_callbacks","title":"define USE_HAL_ETH_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_ETH_REGISTER_CALLBACKS `0U /* ETH register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_fmpi2c_register_callbacks","title":"define USE_HAL_FMPI2C_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_FMPI2C_REGISTER_CALLBACKS `0U /* FMPI2C register callback disabled    */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_fmpsmbus_register_callbacks","title":"define USE_HAL_FMPSMBUS_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_FMPSMBUS_REGISTER_CALLBACKS `0U /* FMPSMBUS register callback disabled  */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_hash_register_callbacks","title":"define USE_HAL_HASH_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_HASH_REGISTER_CALLBACKS `0U /* HASH register callback disabled      */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_hcd_register_callbacks","title":"define USE_HAL_HCD_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_HCD_REGISTER_CALLBACKS `0U /* HCD register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_i2c_register_callbacks","title":"define USE_HAL_I2C_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_I2C_REGISTER_CALLBACKS `0U /* I2C register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_i2s_register_callbacks","title":"define USE_HAL_I2S_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_I2S_REGISTER_CALLBACKS `0U /* I2S register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_irda_register_callbacks","title":"define USE_HAL_IRDA_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_IRDA_REGISTER_CALLBACKS `0U /* IRDA register callback disabled      */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_lptim_register_callbacks","title":"define USE_HAL_LPTIM_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_LPTIM_REGISTER_CALLBACKS `0U /* LPTIM register callback disabled     */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_ltdc_register_callbacks","title":"define USE_HAL_LTDC_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_LTDC_REGISTER_CALLBACKS `0U /* LTDC register callback disabled      */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_mmc_register_callbacks","title":"define USE_HAL_MMC_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_MMC_REGISTER_CALLBACKS `0U /* MMC register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_nand_register_callbacks","title":"define USE_HAL_NAND_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_NAND_REGISTER_CALLBACKS `0U /* NAND register callback disabled      */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_nor_register_callbacks","title":"define USE_HAL_NOR_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_NOR_REGISTER_CALLBACKS `0U /* NOR register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_pccard_register_callbacks","title":"define USE_HAL_PCCARD_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_PCCARD_REGISTER_CALLBACKS `0U /* PCCARD register callback disabled    */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_pcd_register_callbacks","title":"define USE_HAL_PCD_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_PCD_REGISTER_CALLBACKS `0U /* PCD register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_qspi_register_callbacks","title":"define USE_HAL_QSPI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_QSPI_REGISTER_CALLBACKS `0U /* QSPI register callback disabled      */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_rng_register_callbacks","title":"define USE_HAL_RNG_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_RNG_REGISTER_CALLBACKS `0U /* RNG register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_rtc_register_callbacks","title":"define USE_HAL_RTC_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_RTC_REGISTER_CALLBACKS `0U /* RTC register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_sai_register_callbacks","title":"define USE_HAL_SAI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SAI_REGISTER_CALLBACKS `0U /* SAI register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_sdram_register_callbacks","title":"define USE_HAL_SDRAM_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SDRAM_REGISTER_CALLBACKS `0U /* SDRAM register callback disabled     */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_sd_register_callbacks","title":"define USE_HAL_SD_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SD_REGISTER_CALLBACKS `0U /* SD register callback disabled        */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_smartcard_register_callbacks","title":"define USE_HAL_SMARTCARD_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SMARTCARD_REGISTER_CALLBACKS `0U /* SMARTCARD register callback disabled */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_smbus_register_callbacks","title":"define USE_HAL_SMBUS_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SMBUS_REGISTER_CALLBACKS `0U /* SMBUS register callback disabled     */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_spdifrx_register_callbacks","title":"define USE_HAL_SPDIFRX_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SPDIFRX_REGISTER_CALLBACKS `0U /* SPDIFRX register callback disabled   */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_spi_register_callbacks","title":"define USE_HAL_SPI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SPI_REGISTER_CALLBACKS `0U /* SPI register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_sram_register_callbacks","title":"define USE_HAL_SRAM_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SRAM_REGISTER_CALLBACKS `0U /* SRAM register callback disabled      */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_tim_register_callbacks","title":"define USE_HAL_TIM_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_TIM_REGISTER_CALLBACKS `0U /* TIM register callback disabled       */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_uart_register_callbacks","title":"define USE_HAL_UART_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_UART_REGISTER_CALLBACKS `0U /* UART register callback disabled      */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_usart_register_callbacks","title":"define USE_HAL_USART_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_USART_REGISTER_CALLBACKS `0U /* USART register callback disabled     */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_hal_wwdg_register_callbacks","title":"define USE_HAL_WWDG_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_WWDG_REGISTER_CALLBACKS `0U /* WWDG register callback disabled      */`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_rtos","title":"define USE_RTOS","text":"<pre><code>#define USE_RTOS `0U`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-use_spi_crc","title":"define USE_SPI_CRC","text":"<pre><code>#define USE_SPI_CRC `0U`\n</code></pre>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-vdd_value","title":"define VDD_VALUE","text":"<p>This is the HAL system configuration section. </p> <pre><code>#define VDD_VALUE `3300U`\n</code></pre> <p>Value of VDD in mv </p>"},{"location":"Common/stm32f4xx__hal__conf_8h/#define-assert_param","title":"define assert_param","text":"<p>Include module's header file. </p> <pre><code>#define assert_param (\n    expr\n) `((void)0U)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/Inc/stm32f4xx_hal_conf.h</code></p>"},{"location":"Common/stm32f4xx__hal__conf_8h_source/","title":"File stm32f4xx_hal_conf.h","text":"<p>File List &gt; common &gt; Inc &gt; stm32f4xx_hal_conf.h</p> <p>Go to the documentation of this file</p> <pre><code>\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef __STM32F4xx_HAL_CONF_H\n#define __STM32F4xx_HAL_CONF_H\n\n#ifdef __cplusplus\n extern \"C\" {\n#endif\n\n/* Exported types ------------------------------------------------------------*/\n/* Exported constants --------------------------------------------------------*/\n\n/* ########################## Module Selection ############################## */\n#define HAL_MODULE_ENABLED\n\n// #define HAL_CRYP_MODULE_ENABLED\n#define HAL_ADC_MODULE_ENABLED\n#define HAL_CAN_MODULE_ENABLED\n// #define HAL_CRC_MODULE_ENABLED\n// #define HAL_CAN_LEGACY_MODULE_ENABLED\n#define HAL_DAC_MODULE_ENABLED\n// #define HAL_DCMI_MODULE_ENABLED\n// #define HAL_DMA2D_MODULE_ENABLED\n// #define HAL_ETH_MODULE_ENABLED\n// #define HAL_ETH_LEGACY_MODULE_ENABLED\n// #define HAL_NAND_MODULE_ENABLED\n// #define HAL_NOR_MODULE_ENABLED\n// #define HAL_PCCARD_MODULE_ENABLED\n// #define HAL_SRAM_MODULE_ENABLED\n// #define HAL_SDRAM_MODULE_ENABLED\n// #define HAL_HASH_MODULE_ENABLED\n#define HAL_I2C_MODULE_ENABLED\n#define HAL_I2S_MODULE_ENABLED\n#define HAL_IWDG_MODULE_ENABLED\n// #define HAL_LTDC_MODULE_ENABLED\n#define HAL_RNG_MODULE_ENABLED\n#define HAL_RTC_MODULE_ENABLED\n// #define HAL_SAI_MODULE_ENABLED\n#define HAL_SD_MODULE_ENABLED\n// #define HAL_MMC_MODULE_ENABLED\n#define HAL_SPI_MODULE_ENABLED\n#define HAL_TIM_MODULE_ENABLED\n#define HAL_UART_MODULE_ENABLED\n#define HAL_USART_MODULE_ENABLED\n// #define HAL_IRDA_MODULE_ENABLED\n// #define HAL_SMARTCARD_MODULE_ENABLED\n// #define HAL_SMBUS_MODULE_ENABLED\n#define HAL_WWDG_MODULE_ENABLED\n// #define HAL_PCD_MODULE_ENABLED\n// #define HAL_HCD_MODULE_ENABLED\n// #define HAL_DSI_MODULE_ENABLED\n// #define HAL_QSPI_MODULE_ENABLED\n// #define HAL_QSPI_MODULE_ENABLED\n// #define HAL_CEC_MODULE_ENABLED\n// #define HAL_FMPI2C_MODULE_ENABLED\n// #define HAL_FMPSMBUS_MODULE_ENABLED\n// #define HAL_SPDIFRX_MODULE_ENABLED\n// #define HAL_DFSDM_MODULE_ENABLED\n// #define HAL_LPTIM_MODULE_ENABLED\n#define HAL_GPIO_MODULE_ENABLED\n#define HAL_EXTI_MODULE_ENABLED\n#define HAL_DMA_MODULE_ENABLED\n#define HAL_RCC_MODULE_ENABLED\n#define HAL_FLASH_MODULE_ENABLED\n#define HAL_PWR_MODULE_ENABLED\n#define HAL_CORTEX_MODULE_ENABLED\n\n/* ########################## HSE/HSI Values adaptation ##################### */\n#if !defined  (HSE_VALUE)\n  #define HSE_VALUE    25000000U \n#endif /* HSE_VALUE */\n\n#if !defined  (HSE_STARTUP_TIMEOUT)\n  #define HSE_STARTUP_TIMEOUT    100U   \n#endif /* HSE_STARTUP_TIMEOUT */\n\n#if !defined  (HSI_VALUE)\n  #define HSI_VALUE    ((uint32_t)16000000U) \n#endif /* HSI_VALUE */\n\n#if !defined  (LSI_VALUE)\n #define LSI_VALUE  32000U       \n#endif /* LSI_VALUE */                      \n#if !defined  (LSE_VALUE)\n #define LSE_VALUE  32768U    \n#endif /* LSE_VALUE */\n\n#if !defined  (LSE_STARTUP_TIMEOUT)\n  #define LSE_STARTUP_TIMEOUT    5000U   \n#endif /* LSE_STARTUP_TIMEOUT */\n\n#if !defined  (EXTERNAL_CLOCK_VALUE)\n  #define EXTERNAL_CLOCK_VALUE    12288000U \n#endif /* EXTERNAL_CLOCK_VALUE */\n\n/* Tip: To avoid modifying this file each time you need to use different HSE,\n   ===  you can define the HSE value in your toolchain compiler preprocessor. */\n\n/* ########################### System Configuration ######################### */\n#define  VDD_VALUE            3300U \n#define  TICK_INT_PRIORITY            15U   \n#define  USE_RTOS                     0U\n#define  PREFETCH_ENABLE              1U\n#define  INSTRUCTION_CACHE_ENABLE     1U\n#define  DATA_CACHE_ENABLE            1U\n\n#define  USE_HAL_ADC_REGISTER_CALLBACKS         0U /* ADC register callback disabled       */\n#define  USE_HAL_CAN_REGISTER_CALLBACKS         0U /* CAN register callback disabled       */\n#define  USE_HAL_CEC_REGISTER_CALLBACKS         0U /* CEC register callback disabled       */\n#define  USE_HAL_CRYP_REGISTER_CALLBACKS        0U /* CRYP register callback disabled      */\n#define  USE_HAL_DAC_REGISTER_CALLBACKS         0U /* DAC register callback disabled       */\n#define  USE_HAL_DCMI_REGISTER_CALLBACKS        0U /* DCMI register callback disabled      */\n#define  USE_HAL_DFSDM_REGISTER_CALLBACKS       0U /* DFSDM register callback disabled     */\n#define  USE_HAL_DMA2D_REGISTER_CALLBACKS       0U /* DMA2D register callback disabled     */\n#define  USE_HAL_DSI_REGISTER_CALLBACKS         0U /* DSI register callback disabled       */\n#define  USE_HAL_ETH_REGISTER_CALLBACKS         0U /* ETH register callback disabled       */\n#define  USE_HAL_HASH_REGISTER_CALLBACKS        0U /* HASH register callback disabled      */\n#define  USE_HAL_HCD_REGISTER_CALLBACKS         0U /* HCD register callback disabled       */\n#define  USE_HAL_I2C_REGISTER_CALLBACKS         0U /* I2C register callback disabled       */\n#define  USE_HAL_FMPI2C_REGISTER_CALLBACKS      0U /* FMPI2C register callback disabled    */\n#define  USE_HAL_FMPSMBUS_REGISTER_CALLBACKS    0U /* FMPSMBUS register callback disabled  */\n#define  USE_HAL_I2S_REGISTER_CALLBACKS         0U /* I2S register callback disabled       */\n#define  USE_HAL_IRDA_REGISTER_CALLBACKS        0U /* IRDA register callback disabled      */\n#define  USE_HAL_LPTIM_REGISTER_CALLBACKS       0U /* LPTIM register callback disabled     */\n#define  USE_HAL_LTDC_REGISTER_CALLBACKS        0U /* LTDC register callback disabled      */\n#define  USE_HAL_MMC_REGISTER_CALLBACKS         0U /* MMC register callback disabled       */\n#define  USE_HAL_NAND_REGISTER_CALLBACKS        0U /* NAND register callback disabled      */\n#define  USE_HAL_NOR_REGISTER_CALLBACKS         0U /* NOR register callback disabled       */\n#define  USE_HAL_PCCARD_REGISTER_CALLBACKS      0U /* PCCARD register callback disabled    */\n#define  USE_HAL_PCD_REGISTER_CALLBACKS         0U /* PCD register callback disabled       */\n#define  USE_HAL_QSPI_REGISTER_CALLBACKS        0U /* QSPI register callback disabled      */\n#define  USE_HAL_RNG_REGISTER_CALLBACKS         0U /* RNG register callback disabled       */\n#define  USE_HAL_RTC_REGISTER_CALLBACKS         0U /* RTC register callback disabled       */\n#define  USE_HAL_SAI_REGISTER_CALLBACKS         0U /* SAI register callback disabled       */\n#define  USE_HAL_SD_REGISTER_CALLBACKS          0U /* SD register callback disabled        */\n#define  USE_HAL_SMARTCARD_REGISTER_CALLBACKS   0U /* SMARTCARD register callback disabled */\n#define  USE_HAL_SDRAM_REGISTER_CALLBACKS       0U /* SDRAM register callback disabled     */\n#define  USE_HAL_SRAM_REGISTER_CALLBACKS        0U /* SRAM register callback disabled      */\n#define  USE_HAL_SPDIFRX_REGISTER_CALLBACKS     0U /* SPDIFRX register callback disabled   */\n#define  USE_HAL_SMBUS_REGISTER_CALLBACKS       0U /* SMBUS register callback disabled     */\n#define  USE_HAL_SPI_REGISTER_CALLBACKS         0U /* SPI register callback disabled       */\n#define  USE_HAL_TIM_REGISTER_CALLBACKS         0U /* TIM register callback disabled       */\n#define  USE_HAL_UART_REGISTER_CALLBACKS        0U /* UART register callback disabled      */\n#define  USE_HAL_USART_REGISTER_CALLBACKS       0U /* USART register callback disabled     */\n#define  USE_HAL_WWDG_REGISTER_CALLBACKS        0U /* WWDG register callback disabled      */\n\n/* ########################## Assert Selection ############################## */\n//  #define USE_FULL_ASSERT    1U\n\n/* ################## Ethernet peripheral configuration ##################### */\n\n/* Section 1 : Ethernet peripheral configuration */\n\n/* MAC ADDRESS: MAC_ADDR0:MAC_ADDR1:MAC_ADDR2:MAC_ADDR3:MAC_ADDR4:MAC_ADDR5 */\n#define MAC_ADDR0   2U\n#define MAC_ADDR1   0U\n#define MAC_ADDR2   0U\n#define MAC_ADDR3   0U\n#define MAC_ADDR4   0U\n#define MAC_ADDR5   0U\n\n/* Definition of the Ethernet driver buffers size and count */\n#define ETH_RX_BUF_SIZE                ETH_MAX_PACKET_SIZE /* buffer size for receive               */\n#define ETH_TX_BUF_SIZE                ETH_MAX_PACKET_SIZE /* buffer size for transmit              */\n#define ETH_RXBUFNB                    4U       /* 4 Rx buffers of size ETH_RX_BUF_SIZE  */\n#define ETH_TXBUFNB                    4U       /* 4 Tx buffers of size ETH_TX_BUF_SIZE  */\n\n/* Section 2: PHY configuration section */\n\n/* DP83848_PHY_ADDRESS Address*/\n#define DP83848_PHY_ADDRESS\n/* PHY Reset delay these values are based on a 1 ms Systick interrupt*/\n#define PHY_RESET_DELAY                 0x000000FFU\n/* PHY Configuration delay */\n#define PHY_CONFIG_DELAY                0x00000FFFU\n\n#define PHY_READ_TO                     0x0000FFFFU\n#define PHY_WRITE_TO                    0x0000FFFFU\n\n/* Section 3: Common PHY Registers */\n\n#define PHY_BCR                         ((uint16_t)0x0000U)    \n#define PHY_BSR                         ((uint16_t)0x0001U)    \n\n#define PHY_RESET                       ((uint16_t)0x8000U)  \n#define PHY_LOOPBACK                    ((uint16_t)0x4000U)  \n#define PHY_FULLDUPLEX_100M             ((uint16_t)0x2100U)  \n#define PHY_HALFDUPLEX_100M             ((uint16_t)0x2000U)  \n#define PHY_FULLDUPLEX_10M              ((uint16_t)0x0100U)  \n#define PHY_HALFDUPLEX_10M              ((uint16_t)0x0000U)  \n#define PHY_AUTONEGOTIATION             ((uint16_t)0x1000U)  \n#define PHY_RESTART_AUTONEGOTIATION     ((uint16_t)0x0200U)  \n#define PHY_POWERDOWN                   ((uint16_t)0x0800U)  \n#define PHY_ISOLATE                     ((uint16_t)0x0400U)  \n\n#define PHY_AUTONEGO_COMPLETE           ((uint16_t)0x0020U)  \n#define PHY_LINKED_STATUS               ((uint16_t)0x0004U)  \n#define PHY_JABBER_DETECTION            ((uint16_t)0x0002U)  \n\n/* Section 4: Extended PHY Registers */\n#define PHY_SR                          ((uint16_t))    \n\n#define PHY_SPEED_STATUS                ((uint16_t))  \n#define PHY_DUPLEX_STATUS               ((uint16_t))  \n\n/* ################## SPI peripheral configuration ########################## */\n\n/* CRC FEATURE: Use to activate CRC feature inside HAL SPI Driver\n* Activated: CRC code is present inside driver\n* Deactivated: CRC code cleaned from driver\n*/\n\n#define USE_SPI_CRC                     0U\n\n/* Includes ------------------------------------------------------------------*/\n\n#ifdef HAL_RCC_MODULE_ENABLED\n  #include \"stm32f4xx_hal_rcc.h\"\n#endif /* HAL_RCC_MODULE_ENABLED */\n\n#ifdef HAL_GPIO_MODULE_ENABLED\n  #include \"stm32f4xx_hal_gpio.h\"\n#endif /* HAL_GPIO_MODULE_ENABLED */\n\n#ifdef HAL_EXTI_MODULE_ENABLED\n  #include \"stm32f4xx_hal_exti.h\"\n#endif /* HAL_EXTI_MODULE_ENABLED */\n\n#ifdef HAL_DMA_MODULE_ENABLED\n  #include \"stm32f4xx_hal_dma.h\"\n#endif /* HAL_DMA_MODULE_ENABLED */\n\n#ifdef HAL_CORTEX_MODULE_ENABLED\n  #include \"stm32f4xx_hal_cortex.h\"\n#endif /* HAL_CORTEX_MODULE_ENABLED */\n\n#ifdef HAL_ADC_MODULE_ENABLED\n  #include \"stm32f4xx_hal_adc.h\"\n#endif /* HAL_ADC_MODULE_ENABLED */\n\n#ifdef HAL_CAN_MODULE_ENABLED\n  #include \"stm32f4xx_hal_can.h\"\n#endif /* HAL_CAN_MODULE_ENABLED */\n\n#ifdef HAL_CAN_LEGACY_MODULE_ENABLED\n  #include \"stm32f4xx_hal_can_legacy.h\"\n#endif /* HAL_CAN_LEGACY_MODULE_ENABLED */\n\n#ifdef HAL_CRC_MODULE_ENABLED\n  #include \"stm32f4xx_hal_crc.h\"\n#endif /* HAL_CRC_MODULE_ENABLED */\n\n#ifdef HAL_CRYP_MODULE_ENABLED\n  #include \"stm32f4xx_hal_cryp.h\"\n#endif /* HAL_CRYP_MODULE_ENABLED */\n\n#ifdef HAL_DMA2D_MODULE_ENABLED\n  #include \"stm32f4xx_hal_dma2d.h\"\n#endif /* HAL_DMA2D_MODULE_ENABLED */\n\n#ifdef HAL_DAC_MODULE_ENABLED\n  #include \"stm32f4xx_hal_dac.h\"\n#endif /* HAL_DAC_MODULE_ENABLED */\n\n#ifdef HAL_DCMI_MODULE_ENABLED\n  #include \"stm32f4xx_hal_dcmi.h\"\n#endif /* HAL_DCMI_MODULE_ENABLED */\n\n#ifdef HAL_ETH_MODULE_ENABLED\n  #include \"stm32f4xx_hal_eth.h\"\n#endif /* HAL_ETH_MODULE_ENABLED */\n\n#ifdef HAL_ETH_LEGACY_MODULE_ENABLED\n  #include \"stm32f4xx_hal_eth_legacy.h\"\n#endif /* HAL_ETH_LEGACY_MODULE_ENABLED */\n\n#ifdef HAL_FLASH_MODULE_ENABLED\n  #include \"stm32f4xx_hal_flash.h\"\n#endif /* HAL_FLASH_MODULE_ENABLED */\n\n#ifdef HAL_SRAM_MODULE_ENABLED\n  #include \"stm32f4xx_hal_sram.h\"\n#endif /* HAL_SRAM_MODULE_ENABLED */\n\n#ifdef HAL_NOR_MODULE_ENABLED\n  #include \"stm32f4xx_hal_nor.h\"\n#endif /* HAL_NOR_MODULE_ENABLED */\n\n#ifdef HAL_NAND_MODULE_ENABLED\n  #include \"stm32f4xx_hal_nand.h\"\n#endif /* HAL_NAND_MODULE_ENABLED */\n\n#ifdef HAL_PCCARD_MODULE_ENABLED\n  #include \"stm32f4xx_hal_pccard.h\"\n#endif /* HAL_PCCARD_MODULE_ENABLED */\n\n#ifdef HAL_SDRAM_MODULE_ENABLED\n  #include \"stm32f4xx_hal_sdram.h\"\n#endif /* HAL_SDRAM_MODULE_ENABLED */\n\n#ifdef HAL_HASH_MODULE_ENABLED\n #include \"stm32f4xx_hal_hash.h\"\n#endif /* HAL_HASH_MODULE_ENABLED */\n\n#ifdef HAL_I2C_MODULE_ENABLED\n #include \"stm32f4xx_hal_i2c.h\"\n#endif /* HAL_I2C_MODULE_ENABLED */\n\n#ifdef HAL_SMBUS_MODULE_ENABLED\n #include \"stm32f4xx_hal_smbus.h\"\n#endif /* HAL_SMBUS_MODULE_ENABLED */\n\n#ifdef HAL_I2S_MODULE_ENABLED\n #include \"stm32f4xx_hal_i2s.h\"\n#endif /* HAL_I2S_MODULE_ENABLED */\n\n#ifdef HAL_IWDG_MODULE_ENABLED\n #include \"stm32f4xx_hal_iwdg.h\"\n#endif /* HAL_IWDG_MODULE_ENABLED */\n\n#ifdef HAL_LTDC_MODULE_ENABLED\n #include \"stm32f4xx_hal_ltdc.h\"\n#endif /* HAL_LTDC_MODULE_ENABLED */\n\n#ifdef HAL_PWR_MODULE_ENABLED\n #include \"stm32f4xx_hal_pwr.h\"\n#endif /* HAL_PWR_MODULE_ENABLED */\n\n#ifdef HAL_RNG_MODULE_ENABLED\n #include \"stm32f4xx_hal_rng.h\"\n#endif /* HAL_RNG_MODULE_ENABLED */\n\n#ifdef HAL_RTC_MODULE_ENABLED\n #include \"stm32f4xx_hal_rtc.h\"\n#endif /* HAL_RTC_MODULE_ENABLED */\n\n#ifdef HAL_SAI_MODULE_ENABLED\n #include \"stm32f4xx_hal_sai.h\"\n#endif /* HAL_SAI_MODULE_ENABLED */\n\n#ifdef HAL_SD_MODULE_ENABLED\n #include \"stm32f4xx_hal_sd.h\"\n#endif /* HAL_SD_MODULE_ENABLED */\n\n#ifdef HAL_SPI_MODULE_ENABLED\n #include \"stm32f4xx_hal_spi.h\"\n#endif /* HAL_SPI_MODULE_ENABLED */\n\n#ifdef HAL_TIM_MODULE_ENABLED\n #include \"stm32f4xx_hal_tim.h\"\n#endif /* HAL_TIM_MODULE_ENABLED */\n\n#ifdef HAL_UART_MODULE_ENABLED\n #include \"stm32f4xx_hal_uart.h\"\n#endif /* HAL_UART_MODULE_ENABLED */\n\n#ifdef HAL_USART_MODULE_ENABLED\n #include \"stm32f4xx_hal_usart.h\"\n#endif /* HAL_USART_MODULE_ENABLED */\n\n#ifdef HAL_IRDA_MODULE_ENABLED\n #include \"stm32f4xx_hal_irda.h\"\n#endif /* HAL_IRDA_MODULE_ENABLED */\n\n#ifdef HAL_SMARTCARD_MODULE_ENABLED\n #include \"stm32f4xx_hal_smartcard.h\"\n#endif /* HAL_SMARTCARD_MODULE_ENABLED */\n\n#ifdef HAL_WWDG_MODULE_ENABLED\n #include \"stm32f4xx_hal_wwdg.h\"\n#endif /* HAL_WWDG_MODULE_ENABLED */\n\n#ifdef HAL_PCD_MODULE_ENABLED\n #include \"stm32f4xx_hal_pcd.h\"\n#endif /* HAL_PCD_MODULE_ENABLED */\n\n#ifdef HAL_HCD_MODULE_ENABLED\n #include \"stm32f4xx_hal_hcd.h\"\n#endif /* HAL_HCD_MODULE_ENABLED */\n\n#ifdef HAL_DSI_MODULE_ENABLED\n #include \"stm32f4xx_hal_dsi.h\"\n#endif /* HAL_DSI_MODULE_ENABLED */\n\n#ifdef HAL_QSPI_MODULE_ENABLED\n #include \"stm32f4xx_hal_qspi.h\"\n#endif /* HAL_QSPI_MODULE_ENABLED */\n\n#ifdef HAL_CEC_MODULE_ENABLED\n #include \"stm32f4xx_hal_cec.h\"\n#endif /* HAL_CEC_MODULE_ENABLED */\n\n#ifdef HAL_FMPI2C_MODULE_ENABLED\n #include \"stm32f4xx_hal_fmpi2c.h\"\n#endif /* HAL_FMPI2C_MODULE_ENABLED */\n\n#ifdef HAL_FMPSMBUS_MODULE_ENABLED\n #include \"stm32f4xx_hal_fmpsmbus.h\"\n#endif /* HAL_FMPSMBUS_MODULE_ENABLED */\n\n#ifdef HAL_SPDIFRX_MODULE_ENABLED\n #include \"stm32f4xx_hal_spdifrx.h\"\n#endif /* HAL_SPDIFRX_MODULE_ENABLED */\n\n#ifdef HAL_DFSDM_MODULE_ENABLED\n #include \"stm32f4xx_hal_dfsdm.h\"\n#endif /* HAL_DFSDM_MODULE_ENABLED */\n\n#ifdef HAL_LPTIM_MODULE_ENABLED\n #include \"stm32f4xx_hal_lptim.h\"\n#endif /* HAL_LPTIM_MODULE_ENABLED */\n\n#ifdef HAL_MMC_MODULE_ENABLED\n #include \"stm32f4xx_hal_mmc.h\"\n#endif /* HAL_MMC_MODULE_ENABLED */\n\n/* Exported macro ------------------------------------------------------------*/\n#ifdef  USE_FULL_ASSERT\n  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__))\n/* Exported functions ------------------------------------------------------- */\n  void assert_failed(uint8_t* file, uint32_t line);\n#else\n  #define assert_param(expr) ((void)0U)\n#endif /* USE_FULL_ASSERT */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __STM32F4xx_HAL_CONF_H */\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/","title":"File stm32l4xx_hal_conf.h","text":"<p>FileList &gt; common &gt; Inc &gt; stm32l4xx_hal_conf.h</p> <p>Go to the source code of this file</p> <p>HAL configuration template file. This file should be copied to the application folder and renamed to stm32l4xx_hal_conf.h .More...</p> <ul> <li><code>#include \"stm32l4xx_hal_rcc.h\"</code></li> <li><code>#include \"stm32l4xx_hal_gpio.h\"</code></li> <li><code>#include \"stm32l4xx_hal_dma.h\"</code></li> <li><code>#include \"stm32l4xx_hal_cortex.h\"</code></li> <li><code>#include \"stm32l4xx_hal_adc.h\"</code></li> <li><code>#include \"stm32l4xx_hal_can.h\"</code></li> <li><code>#include \"stm32l4xx_hal_dac.h\"</code></li> <li><code>#include \"stm32l4xx_hal_exti.h\"</code></li> <li><code>#include \"stm32l4xx_hal_flash.h\"</code></li> <li><code>#include \"stm32l4xx_hal_i2c.h\"</code></li> <li><code>#include \"stm32l4xx_hal_iwdg.h\"</code></li> <li><code>#include \"stm32l4xx_hal_pwr.h\"</code></li> <li><code>#include \"stm32l4xx_hal_rng.h\"</code></li> <li><code>#include \"stm32l4xx_hal_rtc.h\"</code></li> <li><code>#include \"stm32l4xx_hal_sd.h\"</code></li> <li><code>#include \"stm32l4xx_hal_spi.h\"</code></li> <li><code>#include \"stm32l4xx_hal_tim.h\"</code></li> <li><code>#include \"stm32l4xx_hal_uart.h\"</code></li> <li><code>#include \"stm32l4xx_hal_usart.h\"</code></li> <li><code>#include \"stm32l4xx_hal_wwdg.h\"</code></li> </ul>"},{"location":"Common/stm32l4xx__hal__conf_8h/#macros","title":"Macros","text":"Type Name define DATA_CACHE_ENABLE <code>1U</code> define EXTERNAL_SAI1_CLOCK_VALUE <code>2097000U</code>External clock source for SAI1 peripheral This value is used by the RCC HAL module to compute the SAI1 &amp; SAI2 clock source frequency. define EXTERNAL_SAI2_CLOCK_VALUE <code>2097000U</code>External clock source for SAI2 peripheral This value is used by the RCC HAL module to compute the SAI1 &amp; SAI2 clock source frequency. define HAL_ADC_MODULE_ENABLED define HAL_CAN_MODULE_ENABLED define HAL_CORTEX_MODULE_ENABLED define HAL_DAC_MODULE_ENABLED define HAL_DMA_MODULE_ENABLED define HAL_EXTI_MODULE_ENABLED define HAL_EXTI_MODULE_ENABLED define HAL_FLASH_MODULE_ENABLED define HAL_GPIO_MODULE_ENABLED define HAL_I2C_MODULE_ENABLED define HAL_I2S_MODULE_ENABLED define HAL_IWDG_MODULE_ENABLED define HAL_MODULE_ENABLED This is the list of modules to be used in the HAL driver. define HAL_PWR_MODULE_ENABLED define HAL_RCC_MODULE_ENABLED define HAL_RNG_MODULE_ENABLED define HAL_RTC_MODULE_ENABLED define HAL_SD_MODULE_ENABLED define HAL_SPI_MODULE_ENABLED define HAL_TIM_MODULE_ENABLED define HAL_UART_MODULE_ENABLED define HAL_USART_MODULE_ENABLED define HAL_WWDG_MODULE_ENABLED define HSE_STARTUP_TIMEOUT <code>((uint32\\_t)100U)</code> define HSE_VALUE <code>((uint32\\_t)8000000U)</code>Adjust the value of External High Speed oscillator (HSE) used in your application. This value is used by the RCC HAL module to compute the system frequency (when HSE is used as system clock source, directly or through the PLL). define HSI48_VALUE <code>((uint32\\_t)48000000U)</code>Internal High Speed oscillator (HSI48) value for USB FS, SDMMC and RNG. This internal oscillator is mainly dedicated to provide a high precision clock to the USB peripheral by means of a special Clock Recovery System (CRS) circuitry. When the CRS is not used, the HSI48 RC oscillator runs on it default frequency which is subject to manufacturing process variations. define HSI_VALUE <code>((uint32\\_t)16000000U)</code>Internal High Speed oscillator (HSI) value. This value is used by the RCC HAL module to compute the system frequency (when HSI is used as system clock source, directly or through the PLL). define INSTRUCTION_CACHE_ENABLE <code>1U</code> define LSE_STARTUP_TIMEOUT <code>5000U</code> define LSE_VALUE <code>32768U</code>External Low Speed oscillator (LSE) value. This value is used by the UART, RTC HAL module to compute the system frequency. define LSI_VALUE <code>32000U</code>Internal Low Speed oscillator (LSI) value. define MSI_VALUE <code>((uint32\\_t)4000000U)</code>Internal Multiple Speed oscillator (MSI) default value. This value is the default MSI range value after Reset. define PREFETCH_ENABLE <code>0U</code> define TICK_INT_PRIORITY <code>15U</code> define USE_HAL_ADC_REGISTER_CALLBACKS <code>0U</code>Uncomment the line below to expanse the \"assert_param\" macro in the HAL drivers code. define USE_HAL_CAN_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_COMP_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_CRYP_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_DAC_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_DCMI_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_DFSDM_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_DMA2D_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_DSI_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_GFXMMU_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_HASH_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_HCD_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_I2C_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_IRDA_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_LPTIM_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_LTDC_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_MMC_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_OPAMP_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_OSPI_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_PCD_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_QSPI_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_RNG_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_RTC_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_SAI_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_SD_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_SMARTCARD_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_SMBUS_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_SPI_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_SWPMI_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_TIM_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_TSC_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_UART_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_USART_REGISTER_CALLBACKS <code>0U</code> define USE_HAL_WWDG_REGISTER_CALLBACKS <code>0U</code> define USE_RTOS <code>0U</code> define USE_SPI_CRC <code>0U</code> define VDD_VALUE <code>3300U</code>This is the HAL system configuration section. define assert_param (expr) <code>((void)0U)</code>Include module's header file."},{"location":"Common/stm32l4xx__hal__conf_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>MCD Application Team </p> <p>Attention:</p> <p>Copyright (c) 2017 STMicroelectronics. All rights reserved.</p> <p>This software is licensed under terms that can be found in the LICENSE file in the root directory of this software component. If no LICENSE file comes with this software, it is provided AS-IS. </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Common/stm32l4xx__hal__conf_8h/#define-data_cache_enable","title":"define DATA_CACHE_ENABLE","text":"<pre><code>#define DATA_CACHE_ENABLE `1U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-external_sai1_clock_value","title":"define EXTERNAL_SAI1_CLOCK_VALUE","text":"<p>External clock source for SAI1 peripheral This value is used by the RCC HAL module to compute the SAI1 &amp; SAI2 clock source frequency. </p> <pre><code>#define EXTERNAL_SAI1_CLOCK_VALUE `2097000U`\n</code></pre> <p>Value of the SAI1 External clock source in Hz </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-external_sai2_clock_value","title":"define EXTERNAL_SAI2_CLOCK_VALUE","text":"<p>External clock source for SAI2 peripheral This value is used by the RCC HAL module to compute the SAI1 &amp; SAI2 clock source frequency. </p> <pre><code>#define EXTERNAL_SAI2_CLOCK_VALUE `2097000U`\n</code></pre> <p>Value of the SAI2 External clock source in Hz </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_adc_module_enabled","title":"define HAL_ADC_MODULE_ENABLED","text":"<pre><code>#define HAL_ADC_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_can_module_enabled","title":"define HAL_CAN_MODULE_ENABLED","text":"<pre><code>#define HAL_CAN_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_cortex_module_enabled","title":"define HAL_CORTEX_MODULE_ENABLED","text":"<pre><code>#define HAL_CORTEX_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_dac_module_enabled","title":"define HAL_DAC_MODULE_ENABLED","text":"<pre><code>#define HAL_DAC_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_dma_module_enabled","title":"define HAL_DMA_MODULE_ENABLED","text":"<pre><code>#define HAL_DMA_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_exti_module_enabled","title":"define HAL_EXTI_MODULE_ENABLED","text":"<pre><code>#define HAL_EXTI_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_exti_module_enabled_1","title":"define HAL_EXTI_MODULE_ENABLED","text":"<pre><code>#define HAL_EXTI_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_flash_module_enabled","title":"define HAL_FLASH_MODULE_ENABLED","text":"<pre><code>#define HAL_FLASH_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_gpio_module_enabled","title":"define HAL_GPIO_MODULE_ENABLED","text":"<pre><code>#define HAL_GPIO_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_i2c_module_enabled","title":"define HAL_I2C_MODULE_ENABLED","text":"<pre><code>#define HAL_I2C_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_i2s_module_enabled","title":"define HAL_I2S_MODULE_ENABLED","text":"<pre><code>#define HAL_I2S_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_iwdg_module_enabled","title":"define HAL_IWDG_MODULE_ENABLED","text":"<pre><code>#define HAL_IWDG_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_module_enabled","title":"define HAL_MODULE_ENABLED","text":"<p>This is the list of modules to be used in the HAL driver. </p> <pre><code>#define HAL_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_pwr_module_enabled","title":"define HAL_PWR_MODULE_ENABLED","text":"<pre><code>#define HAL_PWR_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_rcc_module_enabled","title":"define HAL_RCC_MODULE_ENABLED","text":"<pre><code>#define HAL_RCC_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_rng_module_enabled","title":"define HAL_RNG_MODULE_ENABLED","text":"<pre><code>#define HAL_RNG_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_rtc_module_enabled","title":"define HAL_RTC_MODULE_ENABLED","text":"<pre><code>#define HAL_RTC_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_sd_module_enabled","title":"define HAL_SD_MODULE_ENABLED","text":"<pre><code>#define HAL_SD_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_spi_module_enabled","title":"define HAL_SPI_MODULE_ENABLED","text":"<pre><code>#define HAL_SPI_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_tim_module_enabled","title":"define HAL_TIM_MODULE_ENABLED","text":"<pre><code>#define HAL_TIM_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_uart_module_enabled","title":"define HAL_UART_MODULE_ENABLED","text":"<pre><code>#define HAL_UART_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_usart_module_enabled","title":"define HAL_USART_MODULE_ENABLED","text":"<pre><code>#define HAL_USART_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hal_wwdg_module_enabled","title":"define HAL_WWDG_MODULE_ENABLED","text":"<pre><code>#define HAL_WWDG_MODULE_ENABLED \n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hse_startup_timeout","title":"define HSE_STARTUP_TIMEOUT","text":"<pre><code>#define HSE_STARTUP_TIMEOUT `((uint32_t)100U)`\n</code></pre> <p>Time out for HSE start up, in ms </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hse_value","title":"define HSE_VALUE","text":"<p>Adjust the value of External High Speed oscillator (HSE) used in your application. This value is used by the RCC HAL module to compute the system frequency (when HSE is used as system clock source, directly or through the PLL). </p> <pre><code>#define HSE_VALUE `((uint32_t)8000000U)`\n</code></pre> <p>Value of the External oscillator in Hz </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hsi48_value","title":"define HSI48_VALUE","text":"<p>Internal High Speed oscillator (HSI48) value for USB FS, SDMMC and RNG. This internal oscillator is mainly dedicated to provide a high precision clock to the USB peripheral by means of a special Clock Recovery System (CRS) circuitry. When the CRS is not used, the HSI48 RC oscillator runs on it default frequency which is subject to manufacturing process variations. </p> <pre><code>#define HSI48_VALUE `((uint32_t)48000000U)`\n</code></pre> <p>Value of the Internal High Speed oscillator for USB FS/SDMMC/RNG in Hz. The real value my vary depending on manufacturing process variations. </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-hsi_value","title":"define HSI_VALUE","text":"<p>Internal High Speed oscillator (HSI) value. This value is used by the RCC HAL module to compute the system frequency (when HSI is used as system clock source, directly or through the PLL). </p> <pre><code>#define HSI_VALUE `((uint32_t)16000000U)`\n</code></pre> <p>Value of the Internal oscillator in Hz </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-instruction_cache_enable","title":"define INSTRUCTION_CACHE_ENABLE","text":"<pre><code>#define INSTRUCTION_CACHE_ENABLE `1U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-lse_startup_timeout","title":"define LSE_STARTUP_TIMEOUT","text":"<pre><code>#define LSE_STARTUP_TIMEOUT `5000U`\n</code></pre> <p>Time out for LSE start up, in ms </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-lse_value","title":"define LSE_VALUE","text":"<p>External Low Speed oscillator (LSE) value. This value is used by the UART, RTC HAL module to compute the system frequency. </p> <pre><code>#define LSE_VALUE `32768U`\n</code></pre> <p>&lt; Value of the Internal Low Speed oscillator in Hz The real value may vary depending on the variations in voltage and temperature. Value of the External oscillator in Hz </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-lsi_value","title":"define LSI_VALUE","text":"<p>Internal Low Speed oscillator (LSI) value. </p> <pre><code>#define LSI_VALUE `32000U`\n</code></pre> <p>LSI Typical Value in Hz </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-msi_value","title":"define MSI_VALUE","text":"<p>Internal Multiple Speed oscillator (MSI) default value. This value is the default MSI range value after Reset. </p> <pre><code>#define MSI_VALUE `((uint32_t)4000000U)`\n</code></pre> <p>Value of the Internal oscillator in Hz </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-prefetch_enable","title":"define PREFETCH_ENABLE","text":"<pre><code>#define PREFETCH_ENABLE `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-tick_int_priority","title":"define TICK_INT_PRIORITY","text":"<pre><code>#define TICK_INT_PRIORITY `15U`\n</code></pre> <p>tick interrupt priority </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_adc_register_callbacks","title":"define USE_HAL_ADC_REGISTER_CALLBACKS","text":"<p>Uncomment the line below to expanse the \"assert_param\" macro in the HAL drivers code. </p> <pre><code>#define USE_HAL_ADC_REGISTER_CALLBACKS `0U`\n</code></pre> <p>Set below the peripheral configuration to \"1U\" to add the support of HAL callback registration/deregistration feature for the HAL driver(s). This allows user application to provide specific callback functions thanks to HAL_PPP_RegisterCallback() rather than overwriting the default weak callback functions (see each stm32l4xx_hal_ppp.h file for possible callback identifiers defined in HAL_PPP_CallbackIDTypeDef for each PPP peripheral). </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_can_register_callbacks","title":"define USE_HAL_CAN_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_CAN_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_comp_register_callbacks","title":"define USE_HAL_COMP_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_COMP_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_cryp_register_callbacks","title":"define USE_HAL_CRYP_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_CRYP_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_dac_register_callbacks","title":"define USE_HAL_DAC_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_DAC_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_dcmi_register_callbacks","title":"define USE_HAL_DCMI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_DCMI_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_dfsdm_register_callbacks","title":"define USE_HAL_DFSDM_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_DFSDM_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_dma2d_register_callbacks","title":"define USE_HAL_DMA2D_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_DMA2D_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_dsi_register_callbacks","title":"define USE_HAL_DSI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_DSI_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_gfxmmu_register_callbacks","title":"define USE_HAL_GFXMMU_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_GFXMMU_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_hash_register_callbacks","title":"define USE_HAL_HASH_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_HASH_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_hcd_register_callbacks","title":"define USE_HAL_HCD_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_HCD_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_i2c_register_callbacks","title":"define USE_HAL_I2C_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_I2C_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_irda_register_callbacks","title":"define USE_HAL_IRDA_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_IRDA_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_lptim_register_callbacks","title":"define USE_HAL_LPTIM_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_LPTIM_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_ltdc_register_callbacks","title":"define USE_HAL_LTDC_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_LTDC_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_mmc_register_callbacks","title":"define USE_HAL_MMC_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_MMC_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_opamp_register_callbacks","title":"define USE_HAL_OPAMP_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_OPAMP_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_ospi_register_callbacks","title":"define USE_HAL_OSPI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_OSPI_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_pcd_register_callbacks","title":"define USE_HAL_PCD_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_PCD_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_qspi_register_callbacks","title":"define USE_HAL_QSPI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_QSPI_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_rng_register_callbacks","title":"define USE_HAL_RNG_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_RNG_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_rtc_register_callbacks","title":"define USE_HAL_RTC_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_RTC_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_sai_register_callbacks","title":"define USE_HAL_SAI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SAI_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_sd_register_callbacks","title":"define USE_HAL_SD_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SD_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_smartcard_register_callbacks","title":"define USE_HAL_SMARTCARD_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SMARTCARD_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_smbus_register_callbacks","title":"define USE_HAL_SMBUS_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SMBUS_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_spi_register_callbacks","title":"define USE_HAL_SPI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SPI_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_swpmi_register_callbacks","title":"define USE_HAL_SWPMI_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_SWPMI_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_tim_register_callbacks","title":"define USE_HAL_TIM_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_TIM_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_tsc_register_callbacks","title":"define USE_HAL_TSC_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_TSC_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_uart_register_callbacks","title":"define USE_HAL_UART_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_UART_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_usart_register_callbacks","title":"define USE_HAL_USART_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_USART_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_hal_wwdg_register_callbacks","title":"define USE_HAL_WWDG_REGISTER_CALLBACKS","text":"<pre><code>#define USE_HAL_WWDG_REGISTER_CALLBACKS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_rtos","title":"define USE_RTOS","text":"<pre><code>#define USE_RTOS `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-use_spi_crc","title":"define USE_SPI_CRC","text":"<pre><code>#define USE_SPI_CRC `0U`\n</code></pre>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-vdd_value","title":"define VDD_VALUE","text":"<p>This is the HAL system configuration section. </p> <pre><code>#define VDD_VALUE `3300U`\n</code></pre> <p>Value of VDD in mv </p>"},{"location":"Common/stm32l4xx__hal__conf_8h/#define-assert_param","title":"define assert_param","text":"<p>Include module's header file. </p> <pre><code>#define assert_param (\n    expr\n) `((void)0U)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/Inc/stm32l4xx_hal_conf.h</code></p>"},{"location":"Common/stm32l4xx__hal__conf_8h_source/","title":"File stm32l4xx_hal_conf.h","text":"<p>File List &gt; common &gt; Inc &gt; stm32l4xx_hal_conf.h</p> <p>Go to the documentation of this file</p> <pre><code>\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef STM32L4xx_HAL_CONF_H\n#define STM32L4xx_HAL_CONF_H\n\n#ifdef __cplusplus\n extern \"C\" {\n#endif\n\n/* Exported types ------------------------------------------------------------*/\n/* Exported constants --------------------------------------------------------*/\n\n/* ########################## Module Selection ############################## */\n#define HAL_MODULE_ENABLED\n#define HAL_ADC_MODULE_ENABLED\n// #define HAL_CRYP_MODULE_ENABLED\n#define HAL_CAN_MODULE_ENABLED\n// #define HAL_COMP_MODULE_ENABLED\n#define HAL_I2C_MODULE_ENABLED\n// #define HAL_CRC_MODULE_ENABLED\n// #define HAL_CRYP_MODULE_ENABLED\n#define HAL_DAC_MODULE_ENABLED\n// #define HAL_DCMI_MODULE_ENABLED\n// #define HAL_DMA2D_MODULE_ENABLED\n// #define HAL_DFSDM_MODULE_ENABLED\n// #define HAL_DSI_MODULE_ENABLED\n// #define HAL_FIREWALL_MODULE_ENABLED\n// #define HAL_GFXMMU_MODULE_ENABLED\n// #define HAL_HCD_MODULE_ENABLED\n// #define HAL_HASH_MODULE_ENABLED\n#define HAL_I2S_MODULE_ENABLED\n// #define HAL_IRDA_MODULE_ENABLED\n#define HAL_IWDG_MODULE_ENABLED\n// #define HAL_LTDC_MODULE_ENABLED\n// #define HAL_LCD_MODULE_ENABLED\n// #define HAL_LPTIM_MODULE_ENABLED\n// #define HAL_MMC_MODULE_ENABLED\n// #define HAL_NAND_MODULE_ENABLED\n// #define HAL_NOR_MODULE_ENABLED\n// #define HAL_OPAMP_MODULE_ENABLED\n// #define HAL_OSPI_MODULE_ENABLED\n// #define HAL_OSPI_MODULE_ENABLED\n// #define HAL_PCD_MODULE_ENABLED\n// #define HAL_PKA_MODULE_ENABLED\n// #define HAL_QSPI_MODULE_ENABLED\n// #define HAL_QSPI_MODULE_ENABLED\n#define HAL_RNG_MODULE_ENABLED\n#define HAL_RTC_MODULE_ENABLED\n// #define HAL_SAI_MODULE_ENABLED\n#define HAL_SD_MODULE_ENABLED\n// #define HAL_SMBUS_MODULE_ENABLED\n// #define HAL_SMARTCARD_MODULE_ENABLED\n#define HAL_SPI_MODULE_ENABLED\n// #define HAL_SRAM_MODULE_ENABLED\n// #define HAL_SWPMI_MODULE_ENABLED\n#define HAL_TIM_MODULE_ENABLED\n// #define HAL_TSC_MODULE_ENABLED\n#define HAL_UART_MODULE_ENABLED\n#define HAL_USART_MODULE_ENABLED\n#define HAL_WWDG_MODULE_ENABLED\n#define HAL_EXTI_MODULE_ENABLED\n// #define HAL_PSSI_MODULE_ENABLED\n#define HAL_GPIO_MODULE_ENABLED\n#define HAL_EXTI_MODULE_ENABLED\n#define HAL_DMA_MODULE_ENABLED\n#define HAL_RCC_MODULE_ENABLED\n#define HAL_FLASH_MODULE_ENABLED\n#define HAL_PWR_MODULE_ENABLED\n#define HAL_CORTEX_MODULE_ENABLED\n\n/* ########################## Oscillator Values adaptation ####################*/\n#if !defined  (HSE_VALUE)\n  #define HSE_VALUE    ((uint32_t)8000000U) \n#endif /* HSE_VALUE */\n\n#if !defined  (HSE_STARTUP_TIMEOUT)\n  #define HSE_STARTUP_TIMEOUT    ((uint32_t)100U)   \n#endif /* HSE_STARTUP_TIMEOUT */\n\n#if !defined  (MSI_VALUE)\n  #define MSI_VALUE    ((uint32_t)4000000U) \n#endif /* MSI_VALUE */\n#if !defined  (HSI_VALUE)\n  #define HSI_VALUE    ((uint32_t)16000000U) \n#endif /* HSI_VALUE */\n\n#if !defined  (HSI48_VALUE)\n #define HSI48_VALUE   ((uint32_t)48000000U) \n#endif /* HSI48_VALUE */\n\n#if !defined  (LSI_VALUE)\n #define LSI_VALUE  32000U       \n#endif /* LSI_VALUE */                      \n\n#if !defined  (LSE_VALUE)\n  #define LSE_VALUE    32768U \n#endif /* LSE_VALUE */\n\n#if !defined  (LSE_STARTUP_TIMEOUT)\n  #define LSE_STARTUP_TIMEOUT    5000U   \n#endif /* HSE_STARTUP_TIMEOUT */\n\n#if !defined  (EXTERNAL_SAI1_CLOCK_VALUE)\n  #define EXTERNAL_SAI1_CLOCK_VALUE    2097000U \n#endif /* EXTERNAL_SAI1_CLOCK_VALUE */\n\n#if !defined  (EXTERNAL_SAI2_CLOCK_VALUE)\n  #define EXTERNAL_SAI2_CLOCK_VALUE    2097000U \n#endif /* EXTERNAL_SAI2_CLOCK_VALUE */\n\n/* Tip: To avoid modifying this file each time you need to use different HSE,\n   ===  you can define the HSE value in your toolchain compiler preprocessor. */\n\n/* ########################### System Configuration ######################### */\n\n#define  VDD_VALUE                    3300U \n#define  TICK_INT_PRIORITY            15U    \n#define  USE_RTOS                     0U\n#define  PREFETCH_ENABLE              0U\n#define  INSTRUCTION_CACHE_ENABLE     1U\n#define  DATA_CACHE_ENABLE            1U\n\n/* ########################## Assert Selection ############################## */\n//  #define USE_FULL_ASSERT    1U\n\n/* ################## Register callback feature configuration ############### */\n#define USE_HAL_ADC_REGISTER_CALLBACKS        0U\n#define USE_HAL_CAN_REGISTER_CALLBACKS        0U\n#define USE_HAL_COMP_REGISTER_CALLBACKS       0U\n#define USE_HAL_CRYP_REGISTER_CALLBACKS       0U\n#define USE_HAL_DAC_REGISTER_CALLBACKS        0U\n#define USE_HAL_DCMI_REGISTER_CALLBACKS       0U\n#define USE_HAL_DFSDM_REGISTER_CALLBACKS      0U\n#define USE_HAL_DMA2D_REGISTER_CALLBACKS      0U\n#define USE_HAL_DSI_REGISTER_CALLBACKS        0U\n#define USE_HAL_GFXMMU_REGISTER_CALLBACKS     0U\n#define USE_HAL_HASH_REGISTER_CALLBACKS       0U\n#define USE_HAL_HCD_REGISTER_CALLBACKS        0U\n#define USE_HAL_I2C_REGISTER_CALLBACKS        0U\n#define USE_HAL_IRDA_REGISTER_CALLBACKS       0U\n#define USE_HAL_LPTIM_REGISTER_CALLBACKS      0U\n#define USE_HAL_LTDC_REGISTER_CALLBACKS       0U\n#define USE_HAL_MMC_REGISTER_CALLBACKS        0U\n#define USE_HAL_OPAMP_REGISTER_CALLBACKS      0U\n#define USE_HAL_OSPI_REGISTER_CALLBACKS       0U\n#define USE_HAL_PCD_REGISTER_CALLBACKS        0U\n#define USE_HAL_QSPI_REGISTER_CALLBACKS       0U\n#define USE_HAL_RNG_REGISTER_CALLBACKS        0U\n#define USE_HAL_RTC_REGISTER_CALLBACKS        0U\n#define USE_HAL_SAI_REGISTER_CALLBACKS        0U\n#define USE_HAL_SD_REGISTER_CALLBACKS         0U\n#define USE_HAL_SMARTCARD_REGISTER_CALLBACKS  0U\n#define USE_HAL_SMBUS_REGISTER_CALLBACKS      0U\n#define USE_HAL_SPI_REGISTER_CALLBACKS        0U\n#define USE_HAL_SWPMI_REGISTER_CALLBACKS      0U\n#define USE_HAL_TIM_REGISTER_CALLBACKS        0U\n#define USE_HAL_TSC_REGISTER_CALLBACKS        0U\n#define USE_HAL_UART_REGISTER_CALLBACKS       0U\n#define USE_HAL_USART_REGISTER_CALLBACKS      0U\n#define USE_HAL_WWDG_REGISTER_CALLBACKS       0U\n\n/* ################## SPI peripheral configuration ########################## */\n\n/* CRC FEATURE: Use to activate CRC feature inside HAL SPI Driver\n * Activated: CRC code is present inside driver\n * Deactivated: CRC code cleaned from driver\n */\n\n#define USE_SPI_CRC                   0U\n\n/* Includes ------------------------------------------------------------------*/\n\n#ifdef HAL_RCC_MODULE_ENABLED\n  #include \"stm32l4xx_hal_rcc.h\"\n#endif /* HAL_RCC_MODULE_ENABLED */\n\n#ifdef HAL_GPIO_MODULE_ENABLED\n  #include \"stm32l4xx_hal_gpio.h\"\n#endif /* HAL_GPIO_MODULE_ENABLED */\n\n#ifdef HAL_DMA_MODULE_ENABLED\n  #include \"stm32l4xx_hal_dma.h\"\n#endif /* HAL_DMA_MODULE_ENABLED */\n\n#ifdef HAL_DFSDM_MODULE_ENABLED\n  #include \"stm32l4xx_hal_dfsdm.h\"\n#endif /* HAL_DFSDM_MODULE_ENABLED */\n\n#ifdef HAL_CORTEX_MODULE_ENABLED\n  #include \"stm32l4xx_hal_cortex.h\"\n#endif /* HAL_CORTEX_MODULE_ENABLED */\n\n#ifdef HAL_ADC_MODULE_ENABLED\n  #include \"stm32l4xx_hal_adc.h\"\n#endif /* HAL_ADC_MODULE_ENABLED */\n\n#ifdef HAL_CAN_MODULE_ENABLED\n  #include \"stm32l4xx_hal_can.h\"\n#endif /* HAL_CAN_MODULE_ENABLED */\n\n#ifdef HAL_CAN_LEGACY_MODULE_ENABLED\n  #include \"Legacy/stm32l4xx_hal_can_legacy.h\"\n#endif /* HAL_CAN_LEGACY_MODULE_ENABLED */\n\n#ifdef HAL_COMP_MODULE_ENABLED\n  #include \"stm32l4xx_hal_comp.h\"\n#endif /* HAL_COMP_MODULE_ENABLED */\n\n#ifdef HAL_CRC_MODULE_ENABLED\n  #include \"stm32l4xx_hal_crc.h\"\n#endif /* HAL_CRC_MODULE_ENABLED */\n\n#ifdef HAL_CRYP_MODULE_ENABLED\n  #include \"stm32l4xx_hal_cryp.h\"\n#endif /* HAL_CRYP_MODULE_ENABLED */\n\n#ifdef HAL_DAC_MODULE_ENABLED\n  #include \"stm32l4xx_hal_dac.h\"\n#endif /* HAL_DAC_MODULE_ENABLED */\n\n#ifdef HAL_DCMI_MODULE_ENABLED\n  #include \"stm32l4xx_hal_dcmi.h\"\n#endif /* HAL_DCMI_MODULE_ENABLED */\n\n#ifdef HAL_DMA2D_MODULE_ENABLED\n  #include \"stm32l4xx_hal_dma2d.h\"\n#endif /* HAL_DMA2D_MODULE_ENABLED */\n\n#ifdef HAL_DSI_MODULE_ENABLED\n  #include \"stm32l4xx_hal_dsi.h\"\n#endif /* HAL_DSI_MODULE_ENABLED */\n\n#ifdef HAL_EXTI_MODULE_ENABLED\n  #include \"stm32l4xx_hal_exti.h\"\n#endif /* HAL_EXTI_MODULE_ENABLED */\n\n#ifdef HAL_GFXMMU_MODULE_ENABLED\n  #include \"stm32l4xx_hal_gfxmmu.h\"\n#endif /* HAL_GFXMMU_MODULE_ENABLED */\n\n#ifdef HAL_FIREWALL_MODULE_ENABLED\n  #include \"stm32l4xx_hal_firewall.h\"\n#endif /* HAL_FIREWALL_MODULE_ENABLED */\n\n#ifdef HAL_FLASH_MODULE_ENABLED\n  #include \"stm32l4xx_hal_flash.h\"\n#endif /* HAL_FLASH_MODULE_ENABLED */\n\n#ifdef HAL_HASH_MODULE_ENABLED\n  #include \"stm32l4xx_hal_hash.h\"\n#endif /* HAL_HASH_MODULE_ENABLED */\n\n#ifdef HAL_HCD_MODULE_ENABLED\n  #include \"stm32l4xx_hal_hcd.h\"\n#endif /* HAL_HCD_MODULE_ENABLED */\n\n#ifdef HAL_I2C_MODULE_ENABLED\n  #include \"stm32l4xx_hal_i2c.h\"\n#endif /* HAL_I2C_MODULE_ENABLED */\n\n#ifdef HAL_IRDA_MODULE_ENABLED\n  #include \"stm32l4xx_hal_irda.h\"\n#endif /* HAL_IRDA_MODULE_ENABLED */\n\n#ifdef HAL_IWDG_MODULE_ENABLED\n  #include \"stm32l4xx_hal_iwdg.h\"\n#endif /* HAL_IWDG_MODULE_ENABLED */\n\n#ifdef HAL_LCD_MODULE_ENABLED\n  #include \"stm32l4xx_hal_lcd.h\"\n#endif /* HAL_LCD_MODULE_ENABLED */\n\n#ifdef HAL_LPTIM_MODULE_ENABLED\n  #include \"stm32l4xx_hal_lptim.h\"\n#endif /* HAL_LPTIM_MODULE_ENABLED */\n\n#ifdef HAL_LTDC_MODULE_ENABLED\n  #include \"stm32l4xx_hal_ltdc.h\"\n#endif /* HAL_LTDC_MODULE_ENABLED */\n\n#ifdef HAL_MMC_MODULE_ENABLED\n  #include \"stm32l4xx_hal_mmc.h\"\n#endif /* HAL_MMC_MODULE_ENABLED */\n\n#ifdef HAL_NAND_MODULE_ENABLED\n  #include \"stm32l4xx_hal_nand.h\"\n#endif /* HAL_NAND_MODULE_ENABLED */\n\n#ifdef HAL_NOR_MODULE_ENABLED\n  #include \"stm32l4xx_hal_nor.h\"\n#endif /* HAL_NOR_MODULE_ENABLED */\n\n#ifdef HAL_OPAMP_MODULE_ENABLED\n  #include \"stm32l4xx_hal_opamp.h\"\n#endif /* HAL_OPAMP_MODULE_ENABLED */\n\n#ifdef HAL_OSPI_MODULE_ENABLED\n  #include \"stm32l4xx_hal_ospi.h\"\n#endif /* HAL_OSPI_MODULE_ENABLED */\n\n#ifdef HAL_PCD_MODULE_ENABLED\n  #include \"stm32l4xx_hal_pcd.h\"\n#endif /* HAL_PCD_MODULE_ENABLED */\n\n#ifdef HAL_PKA_MODULE_ENABLED\n  #include \"stm32l4xx_hal_pka.h\"\n#endif /* HAL_PKA_MODULE_ENABLED */\n\n#ifdef HAL_PSSI_MODULE_ENABLED\n  #include \"stm32l4xx_hal_pssi.h\"\n#endif /* HAL_PSSI_MODULE_ENABLED */\n\n#ifdef HAL_PWR_MODULE_ENABLED\n  #include \"stm32l4xx_hal_pwr.h\"\n#endif /* HAL_PWR_MODULE_ENABLED */\n\n#ifdef HAL_QSPI_MODULE_ENABLED\n  #include \"stm32l4xx_hal_qspi.h\"\n#endif /* HAL_QSPI_MODULE_ENABLED */\n\n#ifdef HAL_RNG_MODULE_ENABLED\n  #include \"stm32l4xx_hal_rng.h\"\n#endif /* HAL_RNG_MODULE_ENABLED */\n\n#ifdef HAL_RTC_MODULE_ENABLED\n  #include \"stm32l4xx_hal_rtc.h\"\n#endif /* HAL_RTC_MODULE_ENABLED */\n\n#ifdef HAL_SAI_MODULE_ENABLED\n  #include \"stm32l4xx_hal_sai.h\"\n#endif /* HAL_SAI_MODULE_ENABLED */\n\n#ifdef HAL_SD_MODULE_ENABLED\n  #include \"stm32l4xx_hal_sd.h\"\n#endif /* HAL_SD_MODULE_ENABLED */\n\n#ifdef HAL_SMARTCARD_MODULE_ENABLED\n  #include \"stm32l4xx_hal_smartcard.h\"\n#endif /* HAL_SMARTCARD_MODULE_ENABLED */\n\n#ifdef HAL_SMBUS_MODULE_ENABLED\n  #include \"stm32l4xx_hal_smbus.h\"\n#endif /* HAL_SMBUS_MODULE_ENABLED */\n\n#ifdef HAL_SPI_MODULE_ENABLED\n  #include \"stm32l4xx_hal_spi.h\"\n#endif /* HAL_SPI_MODULE_ENABLED */\n\n#ifdef HAL_SRAM_MODULE_ENABLED\n  #include \"stm32l4xx_hal_sram.h\"\n#endif /* HAL_SRAM_MODULE_ENABLED */\n\n#ifdef HAL_SWPMI_MODULE_ENABLED\n  #include \"stm32l4xx_hal_swpmi.h\"\n#endif /* HAL_SWPMI_MODULE_ENABLED */\n\n#ifdef HAL_TIM_MODULE_ENABLED\n  #include \"stm32l4xx_hal_tim.h\"\n#endif /* HAL_TIM_MODULE_ENABLED */\n\n#ifdef HAL_TSC_MODULE_ENABLED\n  #include \"stm32l4xx_hal_tsc.h\"\n#endif /* HAL_TSC_MODULE_ENABLED */\n\n#ifdef HAL_UART_MODULE_ENABLED\n  #include \"stm32l4xx_hal_uart.h\"\n#endif /* HAL_UART_MODULE_ENABLED */\n\n#ifdef HAL_USART_MODULE_ENABLED\n  #include \"stm32l4xx_hal_usart.h\"\n#endif /* HAL_USART_MODULE_ENABLED */\n\n#ifdef HAL_WWDG_MODULE_ENABLED\n  #include \"stm32l4xx_hal_wwdg.h\"\n#endif /* HAL_WWDG_MODULE_ENABLED */\n\n/* Exported macro ------------------------------------------------------------*/\n#ifdef  USE_FULL_ASSERT\n  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__))\n/* Exported functions ------------------------------------------------------- */\n  void assert_failed(uint8_t *file, uint32_t line);\n#else\n  #define assert_param(expr) ((void)0U)\n#endif /* USE_FULL_ASSERT */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* STM32L4xx_HAL_CONF_H */\n</code></pre>"},{"location":"Common/stm32xx__hal_8h/","title":"File stm32xx_hal.h","text":"<p>FileList &gt; common &gt; Inc &gt; stm32xx_hal.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"task.h\"</code></li> <li><code>#include \"queue.h\"</code></li> <li><code>#include \"timers.h\"</code></li> <li><code>#include \"semphr.h\"</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> </ul>"},{"location":"Common/stm32xx__hal_8h/#public-functions","title":"Public Functions","text":"Type Name void Error_Handler (void)  void HAL_MspInit (void)  void SystemClock_Config (void)"},{"location":"Common/stm32xx__hal_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Common/stm32xx__hal_8h/#function-error_handler","title":"function Error_Handler","text":"<pre><code>void Error_Handler (\n    void\n) \n</code></pre>"},{"location":"Common/stm32xx__hal_8h/#function-hal_mspinit","title":"function HAL_MspInit","text":"<pre><code>void HAL_MspInit (\n    void\n) \n</code></pre>"},{"location":"Common/stm32xx__hal_8h/#function-systemclock_config","title":"function SystemClock_Config","text":"<pre><code>void SystemClock_Config (\n    void\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/Inc/stm32xx_hal.h</code></p>"},{"location":"Common/stm32xx__hal_8h_source/","title":"File stm32xx_hal.h","text":"<p>File List &gt; common &gt; Inc &gt; stm32xx_hal.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef STM32xx_HAL_H\n#define STM32xx_HAL_H\n\n// STM32\n#if defined(STM32F4xx)\n    #include \"stm32f4xx.h\"\n    #include \"stm32f4xx_hal.h\"\n    #include \"stm32f4xx_hal_conf.h\"\n#elif defined(STM32L4xx)\n    #include \"stm32l4xx.h\"\n    #include \"stm32l4xx_hal.h\"\n    #include \"stm32l4xx_hal_conf.h\"\n#else\n    #error \"No valid STM32 series defined. Please define either STM32F4xx or STM32L4xx.\"\n#endif\n\n// FreeRTOS\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"queue.h\"\n#include \"timers.h\"\n#include \"semphr.h\"\n\n// Standard Library\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n\n// Init function prototypes\nvoid Error_Handler(void);\nvoid HAL_MspInit(void);\nvoid SystemClock_Config(void);\n\n#endif /* STM32xs_HAL_H */\n</code></pre>"},{"location":"Common/dir_a68c9adcdd2c4e614c81801efca3e79f/","title":"Dir common/Src","text":"<p>FileList &gt; common &gt; Src</p>"},{"location":"Common/dir_a68c9adcdd2c4e614c81801efca3e79f/#files","title":"Files","text":"Type Name file freertos.c file syscalls.c Minimal System calls file. file sysmem.c System Memory calls file. <p>The documentation for this class was generated from the following file <code>common/Src/</code></p>"},{"location":"Common/freertos_8c/","title":"File freertos.c","text":"<p>FileList &gt; common &gt; Src &gt; freertos.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FreeRTOS.h\"</code></li> </ul>"},{"location":"Common/freertos_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name StackType_t xIdleStack StaticTask_t xIdleTaskTCBBuffer StackType_t xTimerStack StaticTask_t xTimerTaskTCBBuffer"},{"location":"Common/freertos_8c/#public-functions","title":"Public Functions","text":"Type Name void vApplicationGetIdleTaskMemory (StaticTask_t ** ppxIdleTaskTCBBuffer, StackType_t ** ppxIdleTaskStackBuffer, uint32_t * pulIdleTaskStackSize) Create memory for Idle task. void vApplicationGetTimerTaskMemory (StaticTask_t ** ppxTimerTaskTCBBuffer, StackType_t ** ppxTimerTaskStackBuffer, uint32_t * pulTimerTaskStackSize) Create memory for Timer task."},{"location":"Common/freertos_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Common/freertos_8c/#variable-xidlestack","title":"variable xIdleStack","text":"<pre><code>StackType_t xIdleStack[configMINIMAL_STACK_SIZE];\n</code></pre>"},{"location":"Common/freertos_8c/#variable-xidletasktcbbuffer","title":"variable xIdleTaskTCBBuffer","text":"<pre><code>StaticTask_t xIdleTaskTCBBuffer;\n</code></pre>"},{"location":"Common/freertos_8c/#variable-xtimerstack","title":"variable xTimerStack","text":"<pre><code>StackType_t xTimerStack[configTIMER_TASK_STACK_DEPTH];\n</code></pre>"},{"location":"Common/freertos_8c/#variable-xtimertasktcbbuffer","title":"variable xTimerTaskTCBBuffer","text":"<pre><code>StaticTask_t xTimerTaskTCBBuffer;\n</code></pre>"},{"location":"Common/freertos_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Common/freertos_8c/#function-vapplicationgetidletaskmemory","title":"function vApplicationGetIdleTaskMemory","text":"<p>Create memory for Idle task. </p> <pre><code>void vApplicationGetIdleTaskMemory (\n    StaticTask_t ** ppxIdleTaskTCBBuffer,\n    StackType_t ** ppxIdleTaskStackBuffer,\n    uint32_t * pulIdleTaskStackSize\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ppxIdleTaskTCBBuffer</code> </li> <li><code>ppxIdleTaskStackBuffer</code> </li> <li><code>pulIdleTaskStackSize</code> </li> </ul>"},{"location":"Common/freertos_8c/#function-vapplicationgettimertaskmemory","title":"function vApplicationGetTimerTaskMemory","text":"<p>Create memory for Timer task. </p> <pre><code>void vApplicationGetTimerTaskMemory (\n    StaticTask_t ** ppxTimerTaskTCBBuffer,\n    StackType_t ** ppxTimerTaskStackBuffer,\n    uint32_t * pulTimerTaskStackSize\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ppxTimerTaskTCBBuffer</code> </li> <li><code>ppxTimerTaskStackBuffer</code> </li> <li><code>pulTimerTaskStackSize</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>common/Src/freertos.c</code></p>"},{"location":"Common/freertos_8c_source/","title":"File freertos.c","text":"<p>File List &gt; common &gt; Src &gt; freertos.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"FreeRTOS.h\"\n\nstatic StaticTask_t xIdleTaskTCBBuffer;\nstatic StackType_t xIdleStack[configMINIMAL_STACK_SIZE];\n\nvoid vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )\n{\n  *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCBBuffer;\n  *ppxIdleTaskStackBuffer = &amp;xIdleStack[0];\n  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;\n}\n\nstatic StaticTask_t xTimerTaskTCBBuffer;\nstatic StackType_t xTimerStack[configTIMER_TASK_STACK_DEPTH];\n\nvoid vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize )\n{\n  *ppxTimerTaskTCBBuffer = &amp;xTimerTaskTCBBuffer;\n  *ppxTimerTaskStackBuffer = &amp;xTimerStack[0];\n  *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;\n}\n</code></pre>"},{"location":"Common/syscalls_8c/","title":"File syscalls.c","text":"<p>FileList &gt; common &gt; Src &gt; syscalls.c</p> <p>Go to the source code of this file</p> <p>Minimal System calls file. More...</p> <ul> <li><code>#include &lt;sys/stat.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;errno.h&gt;</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;signal.h&gt;</code></li> <li><code>#include &lt;time.h&gt;</code></li> <li><code>#include &lt;sys/time.h&gt;</code></li> <li><code>#include &lt;sys/times.h&gt;</code></li> </ul>"},{"location":"Common/syscalls_8c/#public-attributes","title":"Public Attributes","text":"Type Name char ** environ   = <code>\\_\\_env</code>"},{"location":"Common/syscalls_8c/#public-functions","title":"Public Functions","text":"Type Name __attribute__ ((weak))  int __io_getchar (void)  int __io_putchar (int ch)  int _close (int file)  int _execve (char * name, char ** argv, char ** env)  void _exit (int status)  int _fork (void)  int _fstat (int file, struct stat * st)  int _getpid (void)  int _isatty (int file)  int _kill (int pid, int sig)  int _link (char * old, char * new)  int _lseek (int file, int ptr, int dir)  int _open (char * path, int flags, ...)  int _stat (char * file, struct stat * st)  int _times (struct tms * buf)  int _unlink (char * name)  int _wait (int * status)  void initialise_monitor_handles ()"},{"location":"Common/syscalls_8c/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>Auto-generated by STM32CubeMX </p> <p>Attention:</p> <p>Copyright (c) 2020-2024 STMicroelectronics. All rights reserved.</p> <p>This software is licensed under terms that can be found in the LICENSE file in the root directory of this software component. If no LICENSE file comes with this software, it is provided AS-IS. </p>"},{"location":"Common/syscalls_8c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Common/syscalls_8c/#variable-environ","title":"variable environ","text":"<pre><code>char** environ;\n</code></pre>"},{"location":"Common/syscalls_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Common/syscalls_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-__io_getchar","title":"function __io_getchar","text":"<pre><code>int __io_getchar (\n    void\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-__io_putchar","title":"function __io_putchar","text":"<pre><code>int __io_putchar (\n    int ch\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_close","title":"function _close","text":"<pre><code>int _close (\n    int file\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_execve","title":"function _execve","text":"<pre><code>int _execve (\n    char * name,\n    char ** argv,\n    char ** env\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_exit","title":"function _exit","text":"<pre><code>void _exit (\n    int status\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_fork","title":"function _fork","text":"<pre><code>int _fork (\n    void\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_fstat","title":"function _fstat","text":"<pre><code>int _fstat (\n    int file,\n    struct stat * st\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_getpid","title":"function _getpid","text":"<pre><code>int _getpid (\n    void\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_isatty","title":"function _isatty","text":"<pre><code>int _isatty (\n    int file\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_kill","title":"function _kill","text":"<pre><code>int _kill (\n    int pid,\n    int sig\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_link","title":"function _link","text":"<pre><code>int _link (\n    char * old,\n    char * new\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_lseek","title":"function _lseek","text":"<pre><code>int _lseek (\n    int file,\n    int ptr,\n    int dir\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_open","title":"function _open","text":"<pre><code>int _open (\n    char * path,\n    int flags,\n    ...\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_stat","title":"function _stat","text":"<pre><code>int _stat (\n    char * file,\n    struct stat * st\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_times","title":"function _times","text":"<pre><code>int _times (\n    struct tms * buf\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_unlink","title":"function _unlink","text":"<pre><code>int _unlink (\n    char * name\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-_wait","title":"function _wait","text":"<pre><code>int _wait (\n    int * status\n) \n</code></pre>"},{"location":"Common/syscalls_8c/#function-initialise_monitor_handles","title":"function initialise_monitor_handles","text":"<pre><code>void initialise_monitor_handles () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/Src/syscalls.c</code></p>"},{"location":"Common/syscalls_8c_source/","title":"File syscalls.c","text":"<p>File List &gt; common &gt; Src &gt; syscalls.c</p> <p>Go to the documentation of this file</p> <pre><code>\n\n/* Includes */\n#include &lt;sys/stat.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;sys/times.h&gt;\n\n\n/* Variables */\nextern int __io_putchar(int ch) __attribute__((weak));\nextern int __io_getchar(void) __attribute__((weak));\n\n\nchar *__env[1] = { 0 };\nchar **environ = __env;\n\n\n/* Functions */\nvoid initialise_monitor_handles()\n{\n}\n\nint _getpid(void)\n{\n  return 1;\n}\n\nint _kill(int pid, int sig)\n{\n  (void)pid;\n  (void)sig;\n  errno = EINVAL;\n  return -1;\n}\n\nvoid _exit (int status)\n{\n  _kill(status, -1);\n  while (1) {}    /* Make sure we hang here */\n}\n\n__attribute__((weak)) int _read(int file, char *ptr, int len)\n{\n  (void)file;\n  int DataIdx;\n\n  for (DataIdx = 0; DataIdx &lt; len; DataIdx++)\n  {\n    *ptr++ = __io_getchar();\n  }\n\n  return len;\n}\n\n__attribute__((weak)) int _write(int file, char *ptr, int len)\n{\n  (void)file;\n  int DataIdx;\n\n  for (DataIdx = 0; DataIdx &lt; len; DataIdx++)\n  {\n    __io_putchar(*ptr++);\n  }\n  return len;\n}\n\nint _close(int file)\n{\n  (void)file;\n  return -1;\n}\n\n\nint _fstat(int file, struct stat *st)\n{\n  (void)file;\n  st-&gt;st_mode = S_IFCHR;\n  return 0;\n}\n\nint _isatty(int file)\n{\n  (void)file;\n  return 1;\n}\n\nint _lseek(int file, int ptr, int dir)\n{\n  (void)file;\n  (void)ptr;\n  (void)dir;\n  return 0;\n}\n\nint _open(char *path, int flags, ...)\n{\n  (void)path;\n  (void)flags;\n  /* Pretend like we always fail */\n  return -1;\n}\n\nint _wait(int *status)\n{\n  (void)status;\n  errno = ECHILD;\n  return -1;\n}\n\nint _unlink(char *name)\n{\n  (void)name;\n  errno = ENOENT;\n  return -1;\n}\n\nint _times(struct tms *buf)\n{\n  (void)buf;\n  return -1;\n}\n\nint _stat(char *file, struct stat *st)\n{\n  (void)file;\n  st-&gt;st_mode = S_IFCHR;\n  return 0;\n}\n\nint _link(char *old, char *new)\n{\n  (void)old;\n  (void)new;\n  errno = EMLINK;\n  return -1;\n}\n\nint _fork(void)\n{\n  errno = EAGAIN;\n  return -1;\n}\n\nint _execve(char *name, char **argv, char **env)\n{\n  (void)name;\n  (void)argv;\n  (void)env;\n  errno = ENOMEM;\n  return -1;\n}\n</code></pre>"},{"location":"Common/sysmem_8c/","title":"File sysmem.c","text":"<p>FileList &gt; common &gt; Src &gt; sysmem.c</p> <p>Go to the source code of this file</p> <p>System Memory calls file. More...</p> <ul> <li><code>#include &lt;errno.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"Common/sysmem_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint8_t * __sbrk_heap_end   = <code>NULL</code>"},{"location":"Common/sysmem_8c/#public-functions","title":"Public Functions","text":"Type Name void * _sbrk (ptrdiff_t incr) _sbrk() allocates memory to the newlib heap and is used by malloc and others from the C library"},{"location":"Common/sysmem_8c/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>Generated by STM32CubeMX </p> <p>Attention:</p> <p>Copyright (c) 2024 STMicroelectronics. All rights reserved.</p> <p>This software is licensed under terms that can be found in the LICENSE file in the root directory of this software component. If no LICENSE file comes with this software, it is provided AS-IS. </p>"},{"location":"Common/sysmem_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Common/sysmem_8c/#variable-__sbrk_heap_end","title":"variable __sbrk_heap_end","text":"<pre><code>uint8_t* __sbrk_heap_end;\n</code></pre> <p>Pointer to the current high watermark of the heap usage </p>"},{"location":"Common/sysmem_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Common/sysmem_8c/#function-_sbrk","title":"function _sbrk","text":"<p>_sbrk() allocates memory to the newlib heap and is used by malloc and others from the C library</p> <pre><code>void * _sbrk (\n    ptrdiff_t incr\n) \n</code></pre> <p>This implementation starts allocating at the '_end' linker symbol The '_Min_Stack_Size' linker symbol reserves a memory for the MSP stack The implementation considers '_estack' linker symbol to be RAM end NOTE: If the MSP stack, at any point during execution, grows larger than the reserved size, please increase the '_Min_Stack_Size'.</p> <p>Parameters:</p> <ul> <li><code>incr</code> Memory size </li> </ul> <p>Returns:</p> <p>Pointer to allocated memory </p> <p>The documentation for this class was generated from the following file <code>common/Src/sysmem.c</code></p>"},{"location":"Common/sysmem_8c_source/","title":"File sysmem.c","text":"<p>File List &gt; common &gt; Src &gt; sysmem.c</p> <p>Go to the documentation of this file</p> <pre><code>\n\n/* Includes */\n#include &lt;errno.h&gt;\n#include &lt;stdint.h&gt;\n\nstatic uint8_t *__sbrk_heap_end = NULL;\n\nvoid *_sbrk(ptrdiff_t incr)\n{\n  extern uint8_t _end; /* Symbol defined in the linker script */\n  extern uint8_t _estack; /* Symbol defined in the linker script */\n  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */\n  const uint32_t stack_limit = (uint32_t)&amp;_estack - (uint32_t)&amp;_Min_Stack_Size;\n  const uint8_t *max_heap = (uint8_t *)stack_limit;\n  uint8_t *prev_heap_end;\n\n  /* Initialize heap end at first call */\n  if (NULL == __sbrk_heap_end)\n  {\n    __sbrk_heap_end = &amp;_end;\n  }\n\n  /* Protect heap from growing into the reserved MSP stack */\n  if (__sbrk_heap_end + incr &gt; max_heap)\n  {\n    errno = ENOMEM;\n    return (void *)-1;\n  }\n\n  prev_heap_end = __sbrk_heap_end;\n  __sbrk_heap_end += incr;\n\n  return (void *)prev_heap_end;\n}\n</code></pre>"},{"location":"Common/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"Common/classes/","title":"Class Index","text":""},{"location":"Common/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p>"},{"location":"Common/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Common/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Common/class_members/","title":"Class Members","text":"<p>Nothing related to Class Members found.</p>"},{"location":"Common/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"Common/class_member_variables/","title":"Class Member Variables","text":"<p>Nothing related to Class Member Variables found.</p>"},{"location":"Common/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Common/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Common/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"Common/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"Common/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Common/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Common/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"Common/functions/","title":"Functions","text":""},{"location":"Common/functions/#e","title":"e","text":"<ul> <li>Error_Handler (stm32xx_hal.h)</li> </ul>"},{"location":"Common/functions/#h","title":"h","text":"<ul> <li>HAL_MspInit (stm32xx_hal.h)</li> </ul>"},{"location":"Common/functions/#i","title":"i","text":"<ul> <li>initialise_monitor_handles (syscalls.c)</li> </ul>"},{"location":"Common/functions/#s","title":"s","text":"<ul> <li>SystemClock_Config (stm32xx_hal.h)</li> </ul>"},{"location":"Common/functions/#v","title":"v","text":"<ul> <li>vApplicationGetIdleTaskMemory (freertos.c)</li> <li>vApplicationGetTimerTaskMemory (freertos.c)</li> </ul>"},{"location":"Common/functions/#_","title":"_","text":"<ul> <li>__attribute__ (syscalls.c)</li> <li>__io_getchar (syscalls.c)</li> <li>__io_putchar (syscalls.c)</li> <li>_close (syscalls.c)</li> <li>_execve (syscalls.c)</li> <li>_exit (syscalls.c)</li> <li>_fork (syscalls.c)</li> <li>_fstat (syscalls.c)</li> <li>_getpid (syscalls.c)</li> <li>_isatty (syscalls.c)</li> <li>_kill (syscalls.c)</li> <li>_link (syscalls.c)</li> <li>_lseek (syscalls.c)</li> <li>_open (syscalls.c)</li> <li>_stat (syscalls.c)</li> <li>_times (syscalls.c)</li> <li>_unlink (syscalls.c)</li> <li>_wait (syscalls.c)</li> <li>_sbrk (sysmem.c)</li> </ul>"},{"location":"Common/macros/","title":"Macros","text":""},{"location":"Common/macros/#a","title":"a","text":"<ul> <li>assert_param (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> </ul>"},{"location":"Common/macros/#c","title":"c","text":"<ul> <li>configASSERT (FreeRTOSConfig.h)</li> <li>configCPU_CLOCK_HZ (FreeRTOSConfig.h)</li> <li>configENABLE_FPU (FreeRTOSConfig.h)</li> <li>configENABLE_MPU (FreeRTOSConfig.h)</li> <li>configKERNEL_INTERRUPT_PRIORITY (FreeRTOSConfig.h)</li> <li>configLIBRARY_LOWEST_INTERRUPT_PRIORITY (FreeRTOSConfig.h)</li> <li>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY (FreeRTOSConfig.h)</li> <li>configMAX_CO_ROUTINE_PRIORITIES (FreeRTOSConfig.h)</li> <li>configMAX_PRIORITIES (FreeRTOSConfig.h)</li> <li>configMAX_SYSCALL_INTERRUPT_PRIORITY (FreeRTOSConfig.h)</li> <li>configMAX_TASK_NAME_LEN (FreeRTOSConfig.h)</li> <li>configMESSAGE_BUFFER_LENGTH_TYPE (FreeRTOSConfig.h)</li> <li>configMINIMAL_STACK_SIZE (FreeRTOSConfig.h)</li> <li>configPRIO_BITS (FreeRTOSConfig.h)</li> <li>configQUEUE_REGISTRY_SIZE (FreeRTOSConfig.h)</li> <li>configSUPPORT_DYNAMIC_ALLOCATION (FreeRTOSConfig.h)</li> <li>configSUPPORT_STATIC_ALLOCATION (FreeRTOSConfig.h)</li> <li>configTICK_RATE_HZ (FreeRTOSConfig.h)</li> <li>configTIMER_QUEUE_LENGTH (FreeRTOSConfig.h)</li> <li>configTIMER_TASK_PRIORITY (FreeRTOSConfig.h)</li> <li>configTIMER_TASK_STACK_DEPTH (FreeRTOSConfig.h)</li> <li>configUSE_16_BIT_TICKS (FreeRTOSConfig.h)</li> <li>configUSE_COUNTING_SEMAPHORES (FreeRTOSConfig.h)</li> <li>configUSE_CO_ROUTINES (FreeRTOSConfig.h)</li> <li>configUSE_IDLE_HOOK (FreeRTOSConfig.h)</li> <li>configUSE_MUTEXES (FreeRTOSConfig.h)</li> <li>configUSE_PORT_OPTIMISED_TASK_SELECTION (FreeRTOSConfig.h)</li> <li>configUSE_PREEMPTION (FreeRTOSConfig.h)</li> <li>configUSE_RECURSIVE_MUTEXES (FreeRTOSConfig.h)</li> <li>configUSE_TICK_HOOK (FreeRTOSConfig.h)</li> <li>configUSE_TIMERS (FreeRTOSConfig.h)</li> </ul>"},{"location":"Common/macros/#d","title":"d","text":"<ul> <li>DATA_CACHE_ENABLE (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>DP83848_PHY_ADDRESS (stm32f4xx_hal_conf.h)</li> </ul>"},{"location":"Common/macros/#e","title":"e","text":"<ul> <li>ETH_RXBUFNB (stm32f4xx_hal_conf.h)</li> <li>ETH_RX_BUF_SIZE (stm32f4xx_hal_conf.h)</li> <li>ETH_TXBUFNB (stm32f4xx_hal_conf.h)</li> <li>ETH_TX_BUF_SIZE (stm32f4xx_hal_conf.h)</li> <li>EXTERNAL_CLOCK_VALUE (stm32f4xx_hal_conf.h)</li> <li>EXTERNAL_SAI1_CLOCK_VALUE (stm32l4xx_hal_conf.h)</li> <li>EXTERNAL_SAI2_CLOCK_VALUE (stm32l4xx_hal_conf.h)</li> </ul>"},{"location":"Common/macros/#h","title":"h","text":"<ul> <li>HAL_ADC_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_CAN_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_CORTEX_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_DAC_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_DMA_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_EXTI_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_FLASH_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_GPIO_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_I2C_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_I2S_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_IWDG_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_PWR_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_RCC_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_RNG_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_RTC_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_SD_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_SPI_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_TIM_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_UART_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_USART_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HAL_WWDG_MODULE_ENABLED (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HSE_STARTUP_TIMEOUT (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HSE_VALUE (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HSI_VALUE (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>HSI48_VALUE (stm32l4xx_hal_conf.h)</li> </ul>"},{"location":"Common/macros/#i","title":"i","text":"<ul> <li>INCLUDE_uxTaskPriorityGet (FreeRTOSConfig.h)</li> <li>INCLUDE_vTaskCleanUpResources (FreeRTOSConfig.h)</li> <li>INCLUDE_vTaskDelay (FreeRTOSConfig.h)</li> <li>INCLUDE_vTaskDelayUntil (FreeRTOSConfig.h)</li> <li>INCLUDE_vTaskDelete (FreeRTOSConfig.h)</li> <li>INCLUDE_vTaskPrioritySet (FreeRTOSConfig.h)</li> <li>INCLUDE_vTaskSuspend (FreeRTOSConfig.h)</li> <li>INCLUDE_xTaskGetSchedulerState (FreeRTOSConfig.h)</li> <li>INSTRUCTION_CACHE_ENABLE (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> </ul>"},{"location":"Common/macros/#l","title":"l","text":"<ul> <li>LSE_STARTUP_TIMEOUT (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>LSE_VALUE (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>LSI_VALUE (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> </ul>"},{"location":"Common/macros/#m","title":"m","text":"<ul> <li>MAC_ADDR0 (stm32f4xx_hal_conf.h)</li> <li>MAC_ADDR1 (stm32f4xx_hal_conf.h)</li> <li>MAC_ADDR2 (stm32f4xx_hal_conf.h)</li> <li>MAC_ADDR3 (stm32f4xx_hal_conf.h)</li> <li>MAC_ADDR4 (stm32f4xx_hal_conf.h)</li> <li>MAC_ADDR5 (stm32f4xx_hal_conf.h)</li> <li>MSI_VALUE (stm32l4xx_hal_conf.h)</li> </ul>"},{"location":"Common/macros/#p","title":"p","text":"<ul> <li>PHY_AUTONEGOTIATION (stm32f4xx_hal_conf.h)</li> <li>PHY_AUTONEGO_COMPLETE (stm32f4xx_hal_conf.h)</li> <li>PHY_BCR (stm32f4xx_hal_conf.h)</li> <li>PHY_BSR (stm32f4xx_hal_conf.h)</li> <li>PHY_CONFIG_DELAY (stm32f4xx_hal_conf.h)</li> <li>PHY_DUPLEX_STATUS (stm32f4xx_hal_conf.h)</li> <li>PHY_FULLDUPLEX_100M (stm32f4xx_hal_conf.h)</li> <li>PHY_FULLDUPLEX_10M (stm32f4xx_hal_conf.h)</li> <li>PHY_HALFDUPLEX_100M (stm32f4xx_hal_conf.h)</li> <li>PHY_HALFDUPLEX_10M (stm32f4xx_hal_conf.h)</li> <li>PHY_ISOLATE (stm32f4xx_hal_conf.h)</li> <li>PHY_JABBER_DETECTION (stm32f4xx_hal_conf.h)</li> <li>PHY_LINKED_STATUS (stm32f4xx_hal_conf.h)</li> <li>PHY_LOOPBACK (stm32f4xx_hal_conf.h)</li> <li>PHY_POWERDOWN (stm32f4xx_hal_conf.h)</li> <li>PHY_READ_TO (stm32f4xx_hal_conf.h)</li> <li>PHY_RESET (stm32f4xx_hal_conf.h)</li> <li>PHY_RESET_DELAY (stm32f4xx_hal_conf.h)</li> <li>PHY_RESTART_AUTONEGOTIATION (stm32f4xx_hal_conf.h)</li> <li>PHY_SPEED_STATUS (stm32f4xx_hal_conf.h)</li> <li>PHY_SR (stm32f4xx_hal_conf.h)</li> <li>PHY_WRITE_TO (stm32f4xx_hal_conf.h)</li> <li>PREFETCH_ENABLE (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> </ul>"},{"location":"Common/macros/#t","title":"t","text":"<ul> <li>TICK_INT_PRIORITY (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> </ul>"},{"location":"Common/macros/#u","title":"u","text":"<ul> <li>USE_HAL_ADC_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_CAN_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_CEC_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h)</li> <li>USE_HAL_CRYP_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_DAC_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_DCMI_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_DFSDM_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_DMA2D_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_DSI_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_ETH_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h)</li> <li>USE_HAL_FMPI2C_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h)</li> <li>USE_HAL_FMPSMBUS_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h)</li> <li>USE_HAL_HASH_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_HCD_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_I2C_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_I2S_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h)</li> <li>USE_HAL_IRDA_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_LPTIM_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_LTDC_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_MMC_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_NAND_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h)</li> <li>USE_HAL_NOR_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h)</li> <li>USE_HAL_PCCARD_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h)</li> <li>USE_HAL_PCD_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_QSPI_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_RNG_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_RTC_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_SAI_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_SDRAM_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h)</li> <li>USE_HAL_SD_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_SMARTCARD_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_SMBUS_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_SPDIFRX_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h)</li> <li>USE_HAL_SPI_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_SRAM_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h)</li> <li>USE_HAL_TIM_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_UART_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_USART_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_WWDG_REGISTER_CALLBACKS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_RTOS (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_SPI_CRC (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> <li>USE_HAL_COMP_REGISTER_CALLBACKS (stm32l4xx_hal_conf.h)</li> <li>USE_HAL_GFXMMU_REGISTER_CALLBACKS (stm32l4xx_hal_conf.h)</li> <li>USE_HAL_OPAMP_REGISTER_CALLBACKS (stm32l4xx_hal_conf.h)</li> <li>USE_HAL_OSPI_REGISTER_CALLBACKS (stm32l4xx_hal_conf.h)</li> <li>USE_HAL_SWPMI_REGISTER_CALLBACKS (stm32l4xx_hal_conf.h)</li> <li>USE_HAL_TSC_REGISTER_CALLBACKS (stm32l4xx_hal_conf.h)</li> </ul>"},{"location":"Common/macros/#v","title":"v","text":"<ul> <li>vPortSVCHandler (FreeRTOSConfig.h)</li> <li>VDD_VALUE (stm32f4xx_hal_conf.h, stm32l4xx_hal_conf.h)</li> </ul>"},{"location":"Common/macros/#x","title":"x","text":"<ul> <li>xPortPendSVHandler (FreeRTOSConfig.h)</li> <li>xPortSysTickHandler (FreeRTOSConfig.h)</li> <li>xQueueSendCircularBuffer (queue_ex.h)</li> <li>xQueueSendCircularBufferFromISR (queue_ex.h)</li> </ul>"},{"location":"Common/variables/","title":"Variables","text":""},{"location":"Common/variables/#e","title":"e","text":"<ul> <li>environ (syscalls.c)</li> </ul>"},{"location":"Common/variables/#x","title":"x","text":"<ul> <li>xIdleStack (freertos.c)</li> <li>xIdleTaskTCBBuffer (freertos.c)</li> <li>xTimerStack (freertos.c)</li> <li>xTimerTaskTCBBuffer (freertos.c)</li> </ul>"},{"location":"Common/variables/#_","title":"_","text":"<ul> <li>__sbrk_heap_end (sysmem.c)</li> </ul>"},{"location":"Common/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}