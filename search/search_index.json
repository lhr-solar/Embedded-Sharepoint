{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the Embedded Sharepoint Documentation","text":"<p>Welcome to the Embedded Sharepoint! Embedded-Sharepoint contains the shared embedded files to build and develop for our custom STM32 PCBs.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<p>Follow the installation instructions for your specific platform, found here</p>"},{"location":"#command-usage","title":"Command Usage","text":"<p>The Makefile in the top level directory compiles all needed files for the STM32, it is not meant to be called directly, instead you must call it from a different Makefile</p>"},{"location":"#running-tests","title":"Running tests","text":"<p>In the test/ directory there is a Makefile meant for just running test files. Every test file should end with <code>_test</code>  To run a test do:</p> <pre><code>make TEST=[name of test file without _test_ and the .c extension] PROJECT_TARGET=[name of the STM32 you want to compile for]\n\n# For example:\nmake TEST=blinky PROJECT_TARGET=stm32f413rht\n# This compiles the blinky_test.c test for the STM32F413RHT\n</code></pre> <p>For all PROJECT_TARGET options, see the STM32_Ports page</p>"},{"location":"#flashing-code","title":"Flashing code","text":"<p>Once your code is compiled, use the makefile in the <code>test/</code> directory to flash your built code to the microcontroller. If you are running WSL there are some extra steps to connect the STM32 to your computer, which can be found here.</p> <p>Run the following command to flash:</p> <pre><code>make flash\n</code></pre>"},{"location":"#adding-embedded-sharepoint-to-your-project","title":"Adding Embedded Sharepoint to your project","text":"<p>Follow these instructions on how to add Embedded Sharepoint to your project</p>"},{"location":"#contributing","title":"Contributing","text":"<p>See our Issues to see what you can work on! Once you're ready for a review please open a pull request to merge into main. Pull Requests explained </p>"},{"location":"#porting","title":"Porting","text":"<p>A valid port of an STM requires three things:</p> <ol> <li>A directory under stm/stm32f4xx, stm/stm32l4xx, or stm/stm32g4xx must be generated with the generic name of the microcontroller. This is typically stm32 followed by four characters specifying the series and line (stm32f413, stm32l431, etc.)</li> <li>A linker script under the aforementioned directory. This can be autogenerated by STM32CubeMX or grabbed from the internet. The name should take the form of STM32*_FLASH.ld, and should include the full name of the processor (STM32F413RHTx_FLASH.ld, STM32L431CBTx_FLASH.ld, etc.)</li> <li>A startup assembly file including the vector table and some basic handlers (most important being Reset_Handler). This can be autogenerated by STM32CubeMX or grabbed from the internet. The name should take the form of startup_stm32 followed by the four characters specifying the series and line and then xx (startup_stm32f413xx.s, startup_stm32l431xx.s)</li> <li>A configuration file with the exact MCU name (e.g. stm32l432kcu.cfg) specifying which BSP modules to disable in a space separated list like so:     <code>BSP_DISABLE=CAN UART ADC</code>     Please check which peripherals actually exist on your MCU, or be prepared for strange build errors.</li> </ol> <p>The Makefile will expect this exact naming structure, so please ensure you've set it up properly. If everything goes to plan, you should be able to build with PROJECT_TARGET set to the full name of the port.</p>"},{"location":"CubeMX/","title":"CubeMX","text":"<p>STM32 CubeMX is a graphical tool made by STMicro to help in creating STM32 hardware and software. While the generated code is not always optimal, CubeMX is extremely useful for figuring out pin alternate functions, setting up clock trees, and quickly enabling peripherals.</p>"},{"location":"CubeMX/#1-installing-cubemx","title":"1. Installing CubeMX","text":"<p>Download CubeMX here.</p>"},{"location":"CubeMX/#2-using-the-cubemx-microcontroller-editor","title":"2. Using the CubeMX Microcontroller Editor","text":"<ol> <li>Open \"STM32CubeMX\".  </li> <li>Press \"Access to MCU Selector\".  </li> <li>Search for your MCU part number (e.g. STM32F413RHT)</li> <li>Click \"Start Project\" and CubeMX will generate a project workspace.</li> </ol> Note: This is the configuration view for the STM32F413RHT so your pinout might look slightly different."},{"location":"CubeMX/#3-editing-peripheral-settings","title":"3. Editing Peripheral Settings","text":"<p>This section will show you how to change configurations for peripherals you wish to interface.</p>"},{"location":"CubeMX/#31-selecting-a-peripheral","title":"3.1 Selecting a Peripheral","text":"<ul> <li>On the left-hand side of CubeMX, locate the pane with the \"Categories\" tab selected.</li> <li>Toggle the dropdowns to see the peripherals that are supported on your MCU:</li> </ul> <p>Analog - ADCs, DACs Timers - TIM1, TIM2, ... Connectivity - I\u00b2C, USART / UART, SPI </p> <ul> <li>Now, you can select the peripherals you want to enable (e.g., USART1, I2C1, TIM2, etc.).  </li> <li>CubeMX will automatically assign the required pins on the microcontroller diagram.  </li> <li>If there are conflicts (e.g., two peripherals trying to use the same pin), CubeMX will show a warning and let you reassign pins manually.  </li> <li>Hover over the microcontroller diagram and click on a pin to change its function or remap it.</li> </ul> Yay, we can configure our peripherals now!"},{"location":"CubeMX/#32-configuring-a-peripheral","title":"3.2 Configuring a Peripheral","text":"<ul> <li>Clicking a specific peripheral opens a settings window for that peripheral.  </li> <li> <p>The \"Mode\" and \"Configuration\" windows can be used to change configurations for a specific peripheral</p> </li> <li> <p>Examples of configurations:   \u00a0\u00a0-  USART: baud rate, word length, stop bits, parity, DMA options   \u00a0\u00a0-  Timers: PWM mode, clock source, prescaler values, channel mappings   \u00a0\u00a0-  ADC: resolution, sampling time, number of channels, trigger source</p> </li> <li> <p>You can also configure NVIC interrupts and enable/disable them from this window.</p> </li> </ul>"},{"location":"CubeMX/#33-clock-configuration","title":"3.3 Clock Configuration","text":"<ul> <li>Go to the \"Clock Configuration\" tab.  </li> <li>Set up the input oscillator (HSI, HSE, LSE) and PLL settings.  </li> <li>To change derived clock speeds enter your desired value and CubeMX will calculate the necessary prescalers to get there.</li> <li>If you exceed limits, CubeMX will flag the error in red.</li> </ul> \u23f0\u23f0\u23f0"},{"location":"CubeMX/#4-generating-code","title":"4. Generating Code","text":"<ol> <li>Press the \"Project Manager\" tab.  </li> <li>Under \"Code Generator\" you can specify project name, location, and toolchain (e.g., STM32CubeIDE, Keil, IAR, or Makefile).  </li> <li>Click \"Generate Code\" (you may have to install firmware packages for the MCU \ud83d\ude34).  </li> <li>Open the generated project in your chosen IDE and enjoy!</li> </ol>"},{"location":"DBC/","title":"Table of Contents","text":"<ul> <li>Lv Carrier</li> <li>Prohelion Wavesculptor22</li> <li>Tpee Mppta</li> <li>Tpee Mpptb</li> </ul>"},{"location":"DBC/#lv_carrierdbc","title":"lv_carrier.dbc","text":"<p>GitHub Link</p>"},{"location":"DBC/#messages","title":"Messages","text":"ID Name DLC Signals 0x600 LV_Carrier_Status 2 LTC4421_HVDCDC_Selected, LTC4421_HVDCDC_Fault, LTC4421_HVDCDC_Valid, LTC4421_SuppBatt_Selected, LTC4421_SuppBatt_Fault, LTC4421_SuppBatt_Valid, LV_EN_SupplementalBattery, LV_EN_PowerSupply 0x601 Supplemental_Battery_Status 8 Supplemental_Battery_Voltage 0x602 Supplemental_Battery_Charger_Sta 8 SuppCharger_Status, Supplemental_Battery_Current, Supplemental_DCDC_Voltage, Supplemental_DCDC_Current"},{"location":"DBC/#signals","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit LTC4421_HVDCDC_Selected LV_Carrier_Status [0:0] 1 1 0 0 1 LTC4421_HVDCDC_Fault LV_Carrier_Status [1:1] 1 1 0 0 1 LTC4421_HVDCDC_Valid LV_Carrier_Status [2:2] 1 1 0 0 1 LTC4421_SuppBatt_Selected LV_Carrier_Status [3:3] 1 1 0 0 1 LTC4421_SuppBatt_Fault LV_Carrier_Status [4:4] 1 1 0 0 1 LTC4421_SuppBatt_Valid LV_Carrier_Status [5:5] 1 1 0 0 1 LV_EN_SupplementalBattery LV_Carrier_Status [6:6] 1 1 0 0 1 LV_EN_PowerSupply LV_Carrier_Status [7:7] 1 1 0 0 1 Supplemental_Battery_Voltage Supplemental_Battery_Status [0:15] 16 1 0 0 40 V SuppCharger_Status Supplemental_Battery_Charger_Sta [0:1] 2 0 0 None None Supplemental_Battery_Current Supplemental_Battery_Charger_Sta [16:31] 16 1 0 -2300 28700 mA Supplemental_DCDC_Voltage Supplemental_Battery_Charger_Sta [32:47] 16 1 0 0 26 V Supplemental_DCDC_Current Supplemental_Battery_Charger_Sta [48:63] 16 1 0 -2300 28700 mA"},{"location":"DBC/#prohelion_wavesculptor22dbc","title":"prohelion_wavesculptor22.dbc","text":"<p>GitHub Link</p>"},{"location":"DBC/#messages_1","title":"Messages","text":"ID Name DLC Signals 0x240 IDInfo 8 TritiumID, SerialNumber 0x241 Status 8 LimitOutputVoltagePWM, LimitMotorCurrent, LimitVelocity, LimitBusCurrent, LimitBusVoltageUpper, LimitBusVoltageLower, LimitIpmOrMotorTemp, LimitReserved, ErrorHardwareOverCurrent, ErrorSoftwareOverCurrent, ErrorDcBusOverVoltage, ErrorBadMotorPositionHallSeq, ErrorWatchdogCausedLastReset, ErrorConfigRead, Error15vRailUnderVoltage, ErrorDesaturationFault, ErrorMotorOverSpeed, ErrorReserved, ActiveMotor, TxErrorCount, RxErrorCount 0x242 BusMeasurement 8 BusVoltage, BusCurrent 0x243 VelocityMeasurement 8 MotorVelocity, VehicleVelocity 0x244 PhaseCurrentMeasurement 8 PhaseCurrentB, PhaseCurrentC 0x245 MotorVoltageVectorMeasurement 8 Vq, Vd 0x246 MotorCurrentVectorMeasurement 8 Iq, Id 0x247 BackEMFMeasurementPrediction 8 BEMFq, BEMFd 0x248 VoltageRail15VMeasurement 8 ReservedSupply15V, Supply15V 0x249 VoltageRail3V31V9Measurement 8 Supply1V9, Supply3V3 0x24A Reserved0A 8 Reserved0A0, Reserved0A1 0x24B HeatsinkMotorTempMeasurement 8 MotorTemp, HeatsinkTemp 0x24C DspBoardTempMeasurement 8 DspBoardTemp, ReservedDspBoardTemp 0x24D Reserved0D 8 Reserved0D0, Reserved0D1 0x24E OdometerBusAhMeasurement 8 Odometer, DCBusAh 0x257 SlipSpeedMeasurement 8 SlipSpeed, ReservedSlipSpeed"},{"location":"DBC/#signals_1","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit TritiumID IDInfo [0:31] 32 1 0 None None SerialNumber IDInfo [32:63] 32 1 0 None None LimitOutputVoltagePWM Status [0:0] 1 1 0 0 1 On / Off LimitMotorCurrent Status [1:1] 1 1 0 0 1 On / Off LimitVelocity Status [2:2] 1 1 0 0 1 On / Off LimitBusCurrent Status [3:3] 1 1 0 0 1 On / Off LimitBusVoltageUpper Status [4:4] 1 1 0 0 1 On / Off LimitBusVoltageLower Status [5:5] 1 1 0 0 1 On / Off LimitIpmOrMotorTemp Status [6:6] 1 1 0 0 1 On / Off LimitReserved Status [7:15] 9 1 0 0 511 On / Off ErrorHardwareOverCurrent Status [16:16] 1 1 0 0 1 On / Off ErrorSoftwareOverCurrent Status [17:17] 1 1 0 0 1 On / Off ErrorDcBusOverVoltage Status [18:18] 1 1 0 0 1 On / Off ErrorBadMotorPositionHallSeq Status [19:19] 1 1 0 0 1 On / Off ErrorWatchdogCausedLastReset Status [20:20] 1 1 0 0 1 On / Off ErrorConfigRead Status [21:21] 1 1 0 0 1 On / Off Error15vRailUnderVoltage Status [22:22] 1 1 0 0 1 On / Off ErrorDesaturationFault Status [23:23] 1 1 0 0 1 On / Off ErrorMotorOverSpeed Status [24:24] 1 1 0 0 1 On / Off ErrorReserved Status [25:31] 7 1 0 None None On / Off ActiveMotor Status [32:47] 16 1 0 None None TxErrorCount Status [48:55] 8 1 0 None None RxErrorCount Status [56:63] 8 1 0 None None BusVoltage BusMeasurement [0:31] 32 1 0 0 100 V BusCurrent BusMeasurement [32:63] 32 1 0 0 1000 A MotorVelocity VelocityMeasurement [0:31] 32 1 0 None None rpm VehicleVelocity VelocityMeasurement [32:63] 32 2.237 0 None None mph PhaseCurrentB PhaseCurrentMeasurement [0:31] 32 1 0 None None A_rms PhaseCurrentC PhaseCurrentMeasurement [32:63] 32 1 0 None None A_rms Vq MotorVoltageVectorMeasurement [0:31] 32 1 0 None None V Vd MotorVoltageVectorMeasurement [32:63] 32 1 0 None None V Iq MotorCurrentVectorMeasurement [0:31] 32 1 0 None None A Id MotorCurrentVectorMeasurement [32:63] 32 1 0 None None A BEMFq BackEMFMeasurementPrediction [0:31] 32 1 0 None None V BEMFd BackEMFMeasurementPrediction [32:63] 32 1 0 None None V ReservedSupply15V VoltageRail15VMeasurement [0:31] 32 1 0 None None Supply15V VoltageRail15VMeasurement [32:63] 32 1 0 None None V Supply1V9 VoltageRail3V31V9Measurement [0:31] 32 1 0 None None V Supply3V3 VoltageRail3V31V9Measurement [32:63] 32 1 0 None None V Reserved0A0 Reserved0A [0:31] 32 1 0 None None Reserved0A1 Reserved0A [32:63] 32 1 0 None None MotorTemp HeatsinkMotorTempMeasurement [0:31] 32 1 0 None None C HeatsinkTemp HeatsinkMotorTempMeasurement [32:63] 32 1 0 None None C DspBoardTemp DspBoardTempMeasurement [0:31] 32 1 0 None None C ReservedDspBoardTemp DspBoardTempMeasurement [32:63] 32 1 0 None None Reserved0D0 Reserved0D [0:31] 32 1 0 None None Reserved0D1 Reserved0D [32:63] 32 1 0 None None Odometer OdometerBusAhMeasurement [0:31] 32 1 0 None None m DCBusAh OdometerBusAhMeasurement [32:63] 32 1 0 None None Ah SlipSpeed SlipSpeedMeasurement [0:31] 32 1 0 None None Hz ReservedSlipSpeed SlipSpeedMeasurement [32:63] 32 1 0 None None"},{"location":"DBC/#tpee_mpptadbc","title":"tpee_mpptA.dbc","text":"<p>GitHub Link</p>"},{"location":"DBC/#messages_2","title":"Messages","text":"ID Name DLC Signals 0x201 MPPT_32_0_Status 5 MPPT_Mode, MPPT_Fault, MPPT_Enabled, MPPT_AmbientTemperature, MPPT_HeatsinkTemperature 0x200 MPPT_32_0_Power 8 MPPT_Vin, MPPT_Iin, MPPT_Vout, MPPT_Iout 0x209 MPPT_32_0_SetMode 1 Boost_Enable"},{"location":"DBC/#signals_2","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit MPPT_Mode MPPT_32_0_Status [0:7] 8 1 0 None None MPPT_Fault MPPT_32_0_Status [8:15] 8 1 0 None None MPPT_Enabled MPPT_32_0_Status [16:23] 8 1 0 None None MPPT_AmbientTemperature MPPT_32_0_Status [31:38] 8 1 0 -128 127 C MPPT_HeatsinkTemperature MPPT_32_0_Status [39:46] 8 1 0 -128 127 C MPPT_Vin MPPT_32_0_Power [7:22] 16 0.01 0 -327.68 327.67 V MPPT_Iin MPPT_32_0_Power [23:38] 16 0.0005 0 -16.384 16.3835 A MPPT_Vout MPPT_32_0_Power [39:54] 16 0.01 0 -327.68 327.67 V MPPT_Iout MPPT_32_0_Power [55:70] 16 0.0005 0 None None A Boost_Enable MPPT_32_0_SetMode [0:0] 1 1 0 0 1"},{"location":"DBC/#tpee_mpptbdbc","title":"tpee_mpptB.dbc","text":"<p>GitHub Link</p>"},{"location":"DBC/#messages_3","title":"Messages","text":"ID Name DLC Signals 0x211 MPPT_33_0_Status 5 MPPT_Mode, MPPT_Fault, MPPT_Enabled, MPPT_AmbientTemperature, MPPT_HeatsinkTemperature 0x210 MPPT_33_0_Power 8 MPPT_Vin, MPPT_Iin, MPPT_Vout, MPPT_Iout 0x219 MPPT_33_0_SetMode 1 Boost_Enable"},{"location":"DBC/#signals_3","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit MPPT_Mode MPPT_33_0_Status [0:7] 8 1 0 None None MPPT_Fault MPPT_33_0_Status [8:15] 8 1 0 None None MPPT_Enabled MPPT_33_0_Status [16:23] 8 1 0 None None MPPT_AmbientTemperature MPPT_33_0_Status [31:38] 8 1 0 -128 127 C MPPT_HeatsinkTemperature MPPT_33_0_Status [39:46] 8 1 0 -128 127 C MPPT_Vin MPPT_33_0_Power [7:22] 16 0.01 0 -327.68 327.67 V MPPT_Iin MPPT_33_0_Power [23:38] 16 0.0005 0 -16.384 16.3835 A MPPT_Vout MPPT_33_0_Power [39:54] 16 0.01 0 -327.68 327.67 V MPPT_Iout MPPT_33_0_Power [55:70] 16 0.0005 0 None None A Boost_Enable MPPT_33_0_SetMode [0:0] 1 1 0 0 1"},{"location":"EMC2305/","title":"EMC2305 PWM Fan Controller Driver Documentation","text":""},{"location":"EMC2305/#overview","title":"Overview","text":"<p>The EMC2305 is a 5\u2011channel PWM fan controller with optional closed\u2011loop RPM control using tachometer feedback. Driver functions must be called while the FreeRTOS scheduler is active.</p>"},{"location":"EMC2305/#minimal-working-example","title":"Minimal Working Example","text":"<p>WARNING. Don't just copy this code without reading the rest of this page. Lakshay Gupta takes all responsibility for incorrect information regarding this driver. Happy cooling :D</p> <pre><code>// Assuming I2C was initialized and interrupt callbacks overridden\n// Reference \n\n#include \"EMC2305.h\"\n\nI2C_HandleTypeDef hi2c1;\nEMC2305_HandleTypeDef chip;\n\nvoid Init_Task(void* argument) {\n    // Initialize EMC2305\n    // Only call from ONE task!\n    if (EMC2305_Init(&amp;chip, &amp;hi2c1, 0x4D) != EMC2305_OK) {\n        Error_Handler();\n    }\n\n    // Task kills itself\n    vTaskDelete(NULL);\n}\n\nvoid EMC2305_Task_1(void* argument) {\n    // Allow chip to power on\n    vTaskDelay(pdMS_TO_TICKS(250));\n\n    // Set global config\n    EMC2305_Global_Config config = { 0 };\n    config.watchdog_enable = true;\n\n    if (EMC2305_SetGlobalConfig(&amp;chip, &amp;config) != EMC2305_OK) {\n        Error_Handler();\n    }\n\n    // Set config1 and config2\n    EMC2305_Fan_Config1 config1 = { 0 };\n    config1.enable_closed_loop = false; // Set this to true if using FSC (Closed Loop RPM Control). False for using PWM directly\n    config1.edges = EMC2305_EDG_5; // 5 edges is default for 2 pole fans\n    config1.range = EMC2305_RNG_2000;\n\n    EMC2305_Fan_Config2 config2 = { 0 };\n    config2.enable_ramp_rate_ctl = true;\n    config2.enable_glitch_filter = true;\n    config2.error_window = EMC2305_ERG_200RPM;\n    config2.derivative_options = EMC2305_DPT_BOTH;\n\n    if (EMC2305_SetFanConfig(&amp;chip, EMC2305_FAN2, &amp;config1, &amp;config2) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Depends on the fan lol (should be in fan datasheet)\n    if (EMC2305_SetPWMBaseFrequency(&amp;chip, EMC2305_FAN2, EMC2305_PWM_19k53) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Set minimum drive to 0%\n    if (EMC2305_WriteReg(&amp;chip, EMC2305_FAN_REG_ADDR(EMC2305_FAN2, EMC2305_REG_FAN1_MIN_DRIVE), 0x00) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Set PID Gain to lowest (1x)\n    if (EMC2305_WriteReg(&amp;chip, EMC2305_FAN_REG_ADDR(EMC2305_FAN2, EMC2305_REG_GAIN1), 0x00) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Set PWM output mode to open-drain (use false for push-pull)\n    if (EMC2305_SetPWMOutputMode(&amp;chip, EMC2305_FAN2, true) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Control with direct PWM\n    // Set PWM2 duty cycle to 25%\n    if (EMC2305_SetFanPWM(&amp;chip, EMC2305_FAN2, 25) != EMC2305_OK) {\n        Error_Handler();\n    };\n\n    // Control with closed-loop FSC\n    // Set RPM to 3000\n    if (EMC2305_SetFanRPM(&amp;chip, EMC2305_FAN2, 3000) != EMC2305_OK) {\n        Error_Handler();\n    };\n}\n\nint main(void) {\n    // Init your HAL, System Clock, and Peripherals here\n\n    // Create tasks\n    xTaskCreateStatic(Init_Task,\n        \"Init Task\",\n        configMINIMAL_STACK_SIZE,\n        NULL,\n        tskIDLE_PRIORITY + 1,\n        initTaskStack,\n        &amp;initTaskBuffer);\n\n    xTaskCreateStatic(EMC2305_Task_1,\n        \"EMC2305 Task 1\",\n        configMINIMAL_STACK_SIZE,\n        NULL,\n        tskIDLE_PRIORITY + 2,\n        emc2305TaskStack_1,\n        &amp;emc2305TaskBuffer_1);\n\n    vTaskStartScheduler();\n\n    while (1) {\n    }\n\n    return 0;\n}\n\n// I2C Transmit Interrupt Callback\nvoid HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef* hi2c) {\n    EMC2305_I2C_MasterTxCpltCallback(hi2c);\n}\n\n// I2C Receive Interrupt Callback\nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef* hi2c) {\n    EMC2305_I2C_MasterTxCpltCallback(hi2c);\n}\n</code></pre>"},{"location":"EMC2305/#required-hardware-setup","title":"Required Hardware Setup","text":""},{"location":"EMC2305/#mcu-requirements","title":"MCU Requirements","text":"<p>Your board must have:</p> <ul> <li>An STM32 MCU using STM32 HAL (PSOM, LSOM, or any of our other custom STM32 boards)</li> <li>A configured I2C peripheral (interrupt\u2011driven)</li> <li>FreeRTOS enabled in your project (all Embedded-Sharepoint projects use RTOS by default)</li> </ul> <p>This driver relies on:</p> <ul> <li><code>HAL_I2C_Master_Transmit_IT()</code></li> <li><code>HAL_I2C_Master_Receive_IT()</code></li> <li>FreeRTOS queues, semaphores, and static task creation</li> </ul>"},{"location":"EMC2305/#fan-electrical-requirements","title":"Fan Electrical Requirements","text":"<p>Fans may be controlled via:</p> <ul> <li>Push\u2011pull PWM (driven to high and low logic levels)</li> <li>Open\u2011drain PWM (only driven low, requires an external pull\u2011up)</li> </ul> <p>This is configured per\u2011fan using:</p> <pre><code>EMC2305_SetPWMOutputMode()\n</code></pre>"},{"location":"EMC2305/#initialization-process-required-order","title":"Initialization Process (Required Order)","text":""},{"location":"EMC2305/#prerequisites","title":"Prerequisites","text":"<p>Before calling any EMC2305 function:</p> <ul> <li>FreeRTOS scheduler must be running</li> <li>The STM32 I2C peripheral must be initialized</li> <li>I2C interrupts must be enabled</li> </ul>"},{"location":"EMC2305/#required-hal-callbacks","title":"Required HAL Callbacks","text":"<p>You must forward these HAL callbacks:</p> <pre><code>void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c) {\n    EMC2305_I2C_MasterTxCpltCallback(hi2c);\n}\n\nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c) {\n    EMC2305_I2C_MasterRxCpltCallback(hi2c);\n}\n</code></pre> <p>Without this, all I2C operations will hang.</p>"},{"location":"EMC2305/#driver-initialization","title":"Driver Initialization","text":"<p>The first thing you need to do is initialize the chip using this function. It may only be called from one RTOS task (recommended to do this in your init task). An example using I2C bus 1 and the default chip address (0x4D):</p> <pre><code>EMC2305_HandleTypeDef chip;\n\nEMC2305_Init(&amp;chip, &amp;hi2c1, 0x4D);\n</code></pre> <p>What this does internally:</p> <ul> <li>Stores the HAL I2C handle</li> <li>Converts the 7\u2011bit address to HAL format (<code>&lt;&lt; 1</code>)</li> <li>Creates RTOS objects</li> <li>Spawns the I2C worker task</li> <li>Associates the chip with a specific I2C instance</li> <li> <p>Verifies:</p> </li> <li> <p>Product ID (<code>PID == 0b00</code>)</p> </li> <li>Manufacturer ID (<code>0x5D</code>)</li> </ul> <p>If any step fails, <code>EMC2305_ERR</code> is returned.</p>"},{"location":"EMC2305/#core-configuration-functions","title":"Core Configuration Functions","text":""},{"location":"EMC2305/#global-chip-configuration","title":"Global Chip Configuration","text":"<pre><code>EMC2305_Global_Config cfg = {\n    .alert_mask = false,\n    .disable_smbus_timeout = true,\n    .watchdog_enable = false,\n    .drive_ext_clk = false,\n    .use_ext_clk = false,\n};\n\nEMC2305_SetGlobalConfig(&amp;chip, &amp;cfg);\n</code></pre> <p>Controls global chip behavior.</p>"},{"location":"EMC2305/#software-lock-optional","title":"Software Lock (Optional)","text":"<pre><code>EMC2305_EnableSWLock(&amp;chip);\n</code></pre> <ul> <li>Makes all SWL registers read\u2011only</li> <li>Lock persists until power cycle</li> <li>Use only after configuration is complete</li> <li>Do not use this unless you are very confident in your settings</li> </ul>"},{"location":"EMC2305/#operating-modes","title":"Operating Modes","text":""},{"location":"EMC2305/#openloop-pwm-mode-simple","title":"Open\u2011Loop PWM Mode (Simple)","text":"<p>When to use:</p> <ul> <li>You just want to set a duty cycle</li> <li>Fan tach feedback is unavailable or unnecessary</li> </ul> <p>Required configuration:</p> <ul> <li><code>enable_closed_loop = false</code></li> </ul> <p>Control function:</p> <p>Example to set Fan 1 PWM output to 60%:</p> <pre><code>EMC2305_SetFanPWM(&amp;chip, EMC2305_FAN1, 60);\n</code></pre>"},{"location":"EMC2305/#closedloop-rpm-control-recommended","title":"Closed\u2011Loop RPM Control (Recommended)","text":"<p>When to use:</p> <ul> <li>You need stable RPM across voltage/temperature changes</li> <li>You have tach feedback connected</li> </ul> <p>Required configuration:</p> <pre><code>EMC2305_Fan_Config1 cfg1 = {\n    .enable_closed_loop = true,\n    .range = EMC2305_RNG_2000,\n    .edges = EMC2305_EDG_5,\n    .update_time = EMC2305_UDT_100,\n};\n\nEMC2305_Fan_Config2 cfg2 = {\n    .enable_ramp_rate_ctl = true,\n    .enable_glitch_filter = true,\n    .derivative_options = EMC2305_DPT_BOTH,\n    .error_window = EMC2305_ERG_200RPM,\n};\n\nEMC2305_SetFanConfig(&amp;chip, EMC2305_FAN1, &amp;cfg1, &amp;cfg2);\n</code></pre> <p>Control function:</p> <pre><code>EMC2305_SetFanRPM(&amp;chip, EMC2305_FAN1, 3000);\n</code></pre>"},{"location":"EMC2305/#fan-control-api-summary","title":"Fan Control API Summary","text":"Purpose Function Set PWM duty <code>EMC2305_SetFanPWM()</code> Set RPM target <code>EMC2305_SetFanRPM()</code> Read RPM <code>EMC2305_GetFanRPM()</code> Read PWM <code>EMC2305_GetFanPWM()</code> Read fault status <code>EMC2305_GetFanStatus()</code>"},{"location":"EMC2305/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"EMC2305/#using-apis-before-rtos-starts","title":"Using APIs Before RTOS Starts","text":"<p>\u274c Wrong</p> <pre><code>EMC2305_SetFanPWM(...);\n</code></pre> <p>before <code>vTaskStartScheduler()</code></p> <p>\u2714 Correct</p> <p>Call all APIs from tasks only.</p>"},{"location":"EMC2305/#missing-hal-i2c-callbacks","title":"Missing HAL I2C Callbacks","text":"<p>Symptoms:</p> <ul> <li>Functions block forever</li> <li>Timeouts occur</li> </ul> <p>Fix:</p> <ul> <li>Forward HAL callbacks exactly as shown above</li> </ul>"},{"location":"EMC2305/#queue-semaphore-exhaustion","title":"Queue / Semaphore Exhaustion","text":"<p>If too many tasks call EMC2305 APIs simultaneously:</p> <ul> <li><code>EMC2305_ReadReg()</code> returns <code>EMC2305_ERR</code></li> </ul> <p>Fix:</p> <ul> <li>Increase <code>EMC2305_QUEUE_LENGTH</code></li> <li>Avoid excessive polling</li> </ul>"},{"location":"EMC2305/#wrong-control-mode","title":"Wrong Control Mode","text":"<p>Calling:</p> <pre><code>EMC2305_SetFanPWM()\n</code></pre> <p>while closed\u2011loop control is enabled will not work as expected (and vice-versa).</p>"},{"location":"EMC2305/#debugging-guide","title":"Debugging Guide","text":""},{"location":"EMC2305/#chip-not-detected","title":"Chip Not Detected","text":"<p>Check:</p> <ul> <li>I2C address (passed as 7\u2011bit, not shifted)</li> <li>SDA/SCL wiring</li> <li>Pull\u2011ups present</li> </ul>"},{"location":"EMC2305/#rpm-always-reads-uint16_max","title":"RPM Always Reads UINT16_MAX","text":"<p>Causes:</p> <ul> <li>Invalid fan index</li> <li>I2C read failure</li> <li>Tach reading = 0</li> </ul>"},{"location":"EMC2305/#fan-status-flags","title":"Fan Status Flags","text":"<p>Use:</p> <pre><code>EMC2305_Fan_Status status = EMC2305_GetFanStatus(&amp;chip);\n</code></pre> <p>Flags indicate:</p> <ul> <li>Watchdog expiration</li> <li>Spin failure</li> <li>Stall detection</li> <li>Drive failure</li> </ul>"},{"location":"FlashAndTheBug/","title":"Flashing and Debugging on an MCU","text":"<p>This page will walk you through how you can flash your C code on an MCU using Embedded Sharepoint!</p> <p>... and also debug it \ud83e\udee0</p> <p>\u2139\ufe0f Prerequisite :  Make sure you've added Embedded Sharepoint.</p>"},{"location":"FlashAndTheBug/#attaching-usb-devices-in-wsl","title":"Attaching USB devices in WSL","text":"<p>When you plug in your STM32 device, it won't automatically get recognized by your WSL</p> <p>To attach a USB device on WSL you need to install <code>usbipd-win</code>.</p> <ol> <li>Install WinGet if you haven't already using these instructions</li> <li>Open your powershell in administrator mode</li> <li>Run <code>winget install --interactive --exact dorssel.usbipd-win</code></li> </ol> <p>Once we have <code>usbipd</code> we can bind and attach USB devices.</p> <ol> <li>Open Powershell and \"Run as Administrator\".</li> <li>Run <code>usbipd list</code> to get a list of all USB buses.</li> <li>Locate the device called \"ST-Link Debug\" and note the \"BUSID\" (usually in the format of number-number ).</li> <li>Run <code>usbipd bind --busid &lt;BUSID&gt;</code>.</li> <li>Run <code>usbipd attach --wsl --busid &lt;BUSID&gt;</code> (must have an instance of WSL running).</li> </ol> <p>And you're good!</p> <p>Confirm that your device is shared to WSL by running <code>lsusb</code> in your WSL terminal.  </p>"},{"location":"FlashAndTheBug/#attach-usb-devices-using-usbipd-extension","title":"Attach USB devices using USBIPD extension","text":"<p>If you're using VSCode then you can use the <code>USBIPD Connect</code> extension to streamline the process.</p> <p>Once the extension is installed you should see an <code>Attach</code> button at the bottom of your VSCode that when pressed will show you all USB devices. You can now press the ST-Link USB device to connect to it. </p> <p>Note: The extension only works with ST-Links/Nucleos that you\u2019ve previously connected. If you want to use a new device, you\u2019ll need to go through the full manual usbipd setup first. Once a device has been connected manually, the extension can be used to reconnect it quickly in the future.</p>"},{"location":"FlashAndTheBug/#hardware-interface","title":"Hardware Interface","text":"<p>There are two main methods for programming the STM32 microcontrollers we use on our boards: Serial Wire Debug (SWD) and UART. SWD is available on any board with a 4-pin programming header. UART requires a USB-UART conversion chip, along with a USB-C port, which can be found on the PSOM and LSOM, for example.</p>"},{"location":"FlashAndTheBug/#swd-setup","title":"SWD Setup","text":"<p>SWD is a two-wire protocol that is an alternative to JTAG. JTAG is the most common interface for debugging/accessing MCU registers, but it requires 4 pins to communicate while SWD only requires 2, so many ARM microcontrollers will use SWD to ease pin requirements.</p> <p>To program the STM32 microcontroller with SWD, we use an ST-Link\u2014a tool from STMicroelectronics that runs dedicated firmware designed to program STM32 devices.</p> <p>If you take a look at your STM32 Nucleo you should notice two sections on the board:</p> <p></p> Red ST-Link for Debugging Blue STM32 MCU and Peripherals"},{"location":"FlashAndTheBug/#st-link-connector","title":"ST-Link Connector","text":"<p>Your board may have the jumpers ON or OFF on the ST-Link Connector (CN2).</p> <p>ON - you are programming the INTERNAL STM32 MCU (Nucleo)</p> <p>OFF - you are programming the EXTERNAL STM32 MCU (Solar Board)</p> <p>Decide whether you need jumpers based on which MCU you are trying to program.</p> <p>\u2139\ufe0f If you're unsure, run <code>st-info --probe</code> to see the MCU you're flashing to.</p>"},{"location":"FlashAndTheBug/#swd-connector","title":"SWD Connector","text":"<p>When programming an external MCU (not on the Nucleo) the 6-pin SWD connector (CN4) on the ST-Link will be used. </p> <p>Here's the pinout for reference</p> Pin CN4 Designation 1 VDD_TARGET VDD from application 2 SWCLK SWD clock 3 GND Ground 4 SWDIO SWD data I/O 5 NRST RESET of target STM32 6 SWO Reserved <p>On our solar boards we have a SWD interface that looks like this</p> <p>After connecting the corresponding pins you'll be able to program the MCU on your board.</p>"},{"location":"FlashAndTheBug/#uart-setup","title":"UART Setup","text":"<p>UART is the simplest way to program our boards, only requiring a USB-C cable to connect to your laptop. However, while it does allow for flashing and serial monitoring using <code>printf</code>, it does not allow you to run OpenOCD and GDB to step through your code.</p> <p>To connect to your board over UART, plug in a USB-C data cable to the board and your computer. Verify that the board powers up (LEDs turn on) and that you can see the USB-UART chip as a COM port in Device Manager (Windows) or using <code>lsusb_mac</code>/<code>lsusb</code> (MacOS/Linux). On WSL, use <code>usbipd</code> to bind and attach the board the same way you would for ST-Link.</p> <p></p> <p>When programming over UART, you'll have to use the Boot switch and Reset button on the board (PSOM shown below) to enter and exit the bootloader (special section of code that can erase/write to flash memory). When the Boot switch is set to USR, the MCU will start executing your flashed code whenever the Reset button is pressed. When the Boot switch is set to EXT, the MCU will enter the bootloader and wait for any of its peripherals to receive an erase/flash command. In this case, the command will come over UART from the USB-UART converter, but it can also come from CAN, SPI, or several other interfaces.</p> <p></p>"},{"location":"FlashAndTheBug/#software-tooling","title":"Software Tooling","text":""},{"location":"FlashAndTheBug/#overview","title":"Overview","text":"<p>The OpenOCD and stlink packages are some software tools we use to flash and debug code on our board. They are two different options for doing the same thing (flashing and debugging via JTAG/SWD).</p> <ul> <li> <p>stlink is a software package developed by STMicroelectronics to interface with an ST-LINK device for programming and debugging purposes.</p> </li> <li> <p>OpenOCD runs a GDB server, which allows us to debug remote targets via GDB. It also lets us write to flash with some extra configuration.</p> </li> </ul> <p>We currently use the OpenOCD GDB server for debugging while using <code>st-flash</code>, a tool in the stlink package for flashing code.</p>"},{"location":"FlashAndTheBug/#implementation","title":"Implementation","text":"<p>Embedded Sharepoint contains Makefiles to simplify the process of flashing code on an MCU. These Makefiles directly call the <code>st-flash</code> command.</p> <p>On an STM32 MCU, flash memory starts at <code>0x8000000</code>.</p> <p></p> <p>After the Makefile compiles your source code into a binary (<code>.bin</code>), it writes to flash using</p> <pre> st-flash write $(BUILD_DIR)/$(TARGET).bin 0x8000000 </pre> <p>NOTE: We're not flashing the <code>.elf</code> file because it contains unnecessary debug symbols that we don't need to simply flash.</p>"},{"location":"FlashAndTheBug/#make-executables","title":"Make Executables","text":"<p>You can use the Makefile from the <code>test/</code> directory to flash files within the <code>tests/</code> directory.</p> <ol> <li> <p>Navigate to the <code>test/</code> directory.</p> </li> <li> <p>If you've set the environment variables mentioned in \"Adding Embedded Sharepoint\" then you can run <code>make TEST=&lt;testfile&gt;</code> where <code>tests/testfile.c</code> is your test.</p> </li> <li> <p>After your code has been compiled and linked you should see information regarding the <code>.elf</code> file created.</p> </li> </ol> <p></p> <p>If you don't see a similar message nor a <code>.elf</code> file in the <code>build/</code> directory, then look at your console output for a specific error traceback.</p>"},{"location":"FlashAndTheBug/#flash","title":"Flash","text":"<p>If you ran the previous section without error then you should have a <code>.bin</code> and a <code>.elf</code> in your <code>build/</code> corresponding to your target MCU.</p> <p>To flash with SWD:</p> <ol> <li>Navigate to <code>test/</code></li> <li>Run <code>make flash</code></li> </ol> <p>Or alternatively with UART:</p> <ol> <li>Navigate to <code>test/</code></li> <li>Flip the boot switch to EXT &amp; press reset</li> <li>Run <code>make flash-uart</code></li> <li>Flip the boot switch to USR &amp; press reset</li> </ol> <p>... and you've flashed to the MCU!</p>"},{"location":"FlashAndTheBug/#debug","title":"Debug","text":""},{"location":"FlashAndTheBug/#gdb","title":"GDB","text":"<p>To debug we'll use OpenOCD. </p> <ol> <li>Navigate to the root directory of Embedded Sharepoint.</li> <li>Run <code>openocd -f openocd-stm32f4x.cfg</code> if you're programming an F4 MCU or the corresponding <code>..l4x.cfg</code> if you're programming an L4.</li> <li>You should see a message that a GDB server was started on port <code>3333</code>.</li> </ol> <p>Open a second terminal session to use GDB</p> <ol> <li>Run <code>gdb-multiarch build/(TARGET).elf</code>. If you aren't in root the filepath will look slightly different. On mac you need to do <code>arm-none-eabi-gdb</code> instead of 'gdb'</li> <li>Verify that GDB is using the debug symbols from the <code>.elf</code> file.</li> <li>Run <code>tar extended-remote :3333</code> to connect to the OpenOCD GDB server.</li> </ol> <p>Step through your code in GDB to analyze execution!</p>"},{"location":"FlashAndTheBug/#serial-monitoring","title":"Serial Monitoring","text":"<p>Another debugging option is serial monitoring. The <code>printf</code> method is integrated into Embedded-Sharepoint.</p> <ol> <li> <p>The <code>HAL_UART_MspGPIOInit()</code> function must be implemented with the proper GPIO initialization (RCC_CLK_ENABLE, GPIO struct filled in, HAL_GPIO_Init called).</p> </li> <li> <p>The <code>UART_HandleTypeDef</code> struct must be initialized with the proper settings before calling printf_init.</p> </li> <li> <p>Run <code>printf_init(UART_HandleTypeDef)</code> with your desired UART to output to. For a Nucleo, this will be specified in the Nucleo user manual which you can find online. For one of our PCBs, check the schematic to see which UART peripheral your USB is connected to. </p> </li> <li> <p><code>printf_init</code> must be run after the RTOS is initialized.</p> </li> <li> <p>Run <code>printf(...)</code> with your desired format!</p> </li> </ol> <p>To view the output, open up an application like PuTTY or picocom.</p> <ul> <li>For PuTTY, click Serial and enter your desired COM port. This should show up on your device manager (for Mac or Linux, run <code>lsusb</code>). Set the baud rate to what you configured the UART for. Hit the big open button at the bottom.</li> <li>For picocom, type in <code>picocom -b &lt;baud-rate&gt; &lt;tty-name&gt;</code> and you should be set.</li> </ul>"},{"location":"Installation/","title":"Installation Instructions","text":"<p>Development for Embedded-Sharepoint requires a Linux environment. Running Linux natively yields the best results, but there are workarounds through Nix on Mac OS or Windows Subsystem for Linux (WSL) on Windows.  </p>"},{"location":"Installation/#prerequisites","title":"Prerequisites","text":"<p>Please ensure you've done the following before moving on:  </p> <ul> <li>Install Visual Studio Code</li> <li>Set up your GitHub account and SSH key.<ul> <li>You need to both generate an ssh key and add it to your github account</li> </ul> </li> <li>Been added to the lhr-solar organization as a member. Ask one of your leads to do so.</li> <li>Install STM32CubeProgrammer</li> <li>Install drivers for the CP210x USB to UART bridge (needed to flash boards using USB)</li> </ul> <p>Any line that starts with <code>#</code> is a comment and you don't need to run it. </p> <pre><code># Clone the embedded sharepoint repository from the internet to your local computer\ngit clone git@github.com:lhr-solar/Embedded-Sharepoint.git --recursive\n# cd (change directory) to enter the Embedded Sharepoint's directory \ncd Embedded-Sharepoint\n</code></pre>"},{"location":"Installation/#linux","title":"Linux","text":"<p>Run the steps in Nix next</p>"},{"location":"Installation/#windows","title":"Windows","text":""},{"location":"Installation/#windows-subsystem-for-linux-wsl","title":"Windows Subsystem for Linux (WSL)","text":"<p>Windows Subsystem for Linux allows you to run a linux terminal on your windows machine. We specifically use WSL2 since it allows USB passthrough for flashing our microcontrollers. To install WSL follow this guide. Make sure to install WSL2 and not WSL1. It will take time to fully install it, but once installed you can open WSL and it will ask you to create a username and password.</p>"},{"location":"Installation/#usbipd","title":"USBIPD","text":"<p>In order to see a USB device in WSL, we need to pass access of a USB device from windows to WSL. You can do this through USBIPD. In an administrator Powershell terminal run:</p> <pre><code>winget install usbipd\n</code></pre>"},{"location":"Installation/#using-wsl","title":"Using WSL","text":"<p>From now on, you'll be writing all of your solar code in WSL. We primary use VSCode as our code IDE, but there are other IDEs/code editors you can use like Vim or Nano.</p> <ol> <li>Open Visual Studio Code</li> <li>Go into extensions menu on the left side of VSCode, select the WSL extension from Microsoft</li> <li>Press CTRL+SHIFT+P and press connect to WSL</li> <li>Now your VSCode is running WSL and you can run it like a Linux environment. For more info see the WSL guide</li> <li>Do the instructions for generating the github ssh key again while you're in WSL </li> </ol> <p>Run the Ubuntu application, and now you'll be in your WSL/Linux environment.</p> <p>Run the steps in Nix next</p>"},{"location":"Installation/#mac","title":"Mac","text":"<p>Run the steps in Nix</p>"},{"location":"Installation/#nix","title":"Nix","text":"<p>Nix is a package manger that lets you write out all the packages you want to install in a human readable format. This simplifies development since I can write out a list of dependencies needed to compile.  </p> <p>Enter the Embedded Sharepoint and run the following commands in the terminal: </p> <p>Make the nix_install script runnable</p> <pre><code>chmod +x ./nix_install.sh\n</code></pre> <p>Run the script to install the needed nix dependencies.</p> <pre><code>sudo ./nix_install.sh\n</code></pre> <p>Enter the nix shell and download dependencies for Embedded-Sharepoint</p> <pre><code>nix develop\n</code></pre> <p>In this nix shell all the dependencies needed for Embedded-Sharepoint should be installed.  Anytime you open a new terminal and want to run compile/flash code you need to run nix develop to open the shell with Sharepoint's dependencies.  </p> <p>Test if installation is succesful by compiling a test </p> <pre><code>cd test\nmake TEST=blinky\n</code></pre> <p>Now that you've successfully compiled a test, we want to flash our code to the microcontroller. The term \"flashing\" in an embedded system refers to putting your code onto the microcontroller. If you're using WSL there are some extra setup steps you need to do to connect to the microcontroller, that can be found here in the <code>Attaching USB devices in WSL</code> section.  </p> <p>After that run <code>lsusb</code> and make sure you see an ST-Link Debug device is seen by your terminal. Then run the following command to flash to your microcontroller</p> <pre><code>make flash\n</code></pre>"},{"location":"Installation/#common-errors","title":"Common Errors","text":""},{"location":"Installation/#could-not-open-usb-device","title":"Could not open USB device","text":"<p>if you're getting: <code>libusb couldn't open USB device /dev/bus/usb/001/003, errno=13</code> This means your user doesn't have permissions to use a USB port.  To fix this run</p> <pre><code>sudo chmod -R 777 /dev/bus/usb/\n</code></pre>"},{"location":"Installation/#cant-flash-after-changing-project_target","title":"Can't flash after changing PROJECT_TARGET","text":"<p>If you build your code for one PROJECT_TARGET and then switch to another, you\u2019ll usually need to run <code>make clean</code> before flashing to remove all old build files. Otherwise, leftover files from the previous build may remain in your build folder, causing <code>make flash</code> to get confused about which <code>.bin</code> file to use.</p>"},{"location":"STM32_Ports/","title":"List of STM32 Port Names","text":""},{"location":"STM32_Ports/#l4","title":"L4","text":"<ul> <li><code>STM32L431CBTx</code><ul> <li><code>PROJECT_TARGET=stm32l431cbt</code></li> </ul> </li> <li><code>STM32L432KCUx</code><ul> <li><code>PROJECT_TARGET=stm32l432kcu</code></li> </ul> </li> <li><code>STM32L476RGTx</code><ul> <li><code>PROJECT_TARGET=stm32l476rgt</code></li> </ul> </li> </ul>"},{"location":"STM32_Ports/#f4","title":"F4","text":"<ul> <li><code>STM32F401REx</code><ul> <li><code>PROJECT_TARGET=stm32f401re</code></li> </ul> </li> <li><code>STM32F413RHTx</code><ul> <li><code>PROJECT_TARGET=stm32f413rht</code></li> </ul> </li> <li><code>STM32F429ZITx</code><ul> <li><code>PROJECT_TARGET=stm32f429zit</code></li> </ul> </li> <li><code>STM32F446RETx</code><ul> <li><code>PROJECT_TARGET=stm32f446ret</code></li> </ul> </li> </ul>"},{"location":"STM32_Ports/#g4","title":"G4","text":"<ul> <li><code>STM32G473XXx</code><ul> <li><code>PROJECT_TARGET=stm32g473xx</code></li> </ul> </li> <li><code>STM32G474XXx</code><ul> <li><code>PROJECT_TARGET=stm32g474xx</code></li> </ul> </li> </ul>"},{"location":"SharepointSubmodule/","title":"Adding Sharepoint To Your Project","text":""},{"location":"SharepointSubmodule/#1-suggested-directories","title":"1. Suggested directories","text":"<p>It is good practice to organize files into folders based on their abstraction from the STM32 hardware. Embedded-Sharepoint contains a folder for the STM32 HAL (Hardware Abstraction Library), which holds low-level calls to the STM32. Above this are drivers that interact with the HAL, and then applications that use the drivers. This application layer is where your RTOS tasks typically run. You should also have a <code>tests/</code> directory. If your repository contains more than just firmware, it's recommended to create a <code>firmware/</code> directory for all your code, including Embedded-Sharepoint.</p> <p>The suggested (minimal) structure is as follows:</p> <pre><code>Firmware/\n\u251c\u2500\u2500 Embedded-Sharepoint/  #  Don't create this folder manually, it'll be created in the next step\n\u251c\u2500\u2500 Makefile              # The makefile that you write\n\u251c\u2500\u2500 core/                 # Stores tasks and main application logic\n\u251c\u2500\u2500 drivers/              # Drivers\n\u251c\u2500\u2500 middleware/           # External libraries stored in the repository\n\u2514\u2500\u2500 tests/                # Unit and integration tests\n</code></pre> <p>These directories should all have Src/ and Inc/ folders to separate the c header and source files.</p>"},{"location":"SharepointSubmodule/#2-add-embedded-sharepoint-as-a-submodule","title":"2. Add Embedded-Sharepoint as a Submodule","text":"<p>A Git submodule is a way to include one Git repository inside another.  Embedded-Sharepoint contains common files so it should be stored as a submodule inside your repository. For more information about submodules: git submodules documentation.</p> <p>Wherever you want to add Embedded-Sharepoint, run: </p> <pre><code>git submodule add https://github.com/lhr-solar/Embedded-Sharepoint.git\ngit submodule update --init --recursive\n</code></pre> <p>Ensure that the link you're using to add this submodule is the HTTPs link and not the SSH link (needed to for automatic github workflows to trigger).</p>"},{"location":"SharepointSubmodule/#3-writing-a-makefile-for-your-project","title":"3. Writing a makefile for your project","text":"<p>A Makefile is a file used to outline how you want your code to compile. There is a Makefile that compiles all needed files for the STM32 (our microcontroller) in the top level of the Embedded Sharepoint. You need to write another Makefile to compile your project files and call the Embedded-Sharepoint Makefile.  There is a minimal template Makefile in the template/ folder in Embedded-Sharepoint. Lines with <code>#\u2757 CHANGE THIS \u2757</code> define where you should make changes to your Makefile. Move the template Makefile to the same directory as your firmware, and rename it to just be called <code>Makefile</code>. </p> <p>For a more in depth tutorial, I suggest visiting this article on Makefiles</p>"},{"location":"SharepointSubmodule/#basic-makefile-syntax","title":"Basic Makefile syntax","text":"<p>This section explains common Makefile syntax used in the template Makefile.</p>"},{"location":"SharepointSubmodule/#comments","title":"Comments","text":"<p>Any line becomes a comment by adding <code>#</code> When adding comments, it's suggested to make them on a separate line from actual Makefile code, i.e avoid</p> <pre><code>PROJECT_TARGET ?= stm32g473xx # this line contains the project target\n</code></pre> <p>and instead do</p> <pre><code># this line contaisn the project target\nPROJECT_TARGET ?= stm32g473xx \n</code></pre> <p>This is because Makefiles can sometimes compile the comments into the command and break directories. </p>"},{"location":"SharepointSubmodule/#conditional-assignments","title":"Conditional Assignments (<code>?=</code>)","text":"<p>The <code>?=</code> operator assigns a value only if the variable is not already set. This allows variables to be overridden from the command line.</p> <pre><code>PROJECT_TARGET ?= stm32g473xx\n</code></pre> <p>This by default sets the <code>PROJECT_TARGET</code> to be <code>stm32g473xx</code>, but by running</p> <pre><code>make PROJECT_TARGET=stm32l432cbt\n</code></pre> <p>The <code>PROJECT_TARGET</code> will be overridden to <code>stm32l432cbt</code></p>"},{"location":"SharepointSubmodule/#variable-expansion","title":"Variable Expansion","text":"<p>Variables are referenced using <code>$(VAR)</code> or <code>${VAR}</code> (both are valid).</p> <pre><code>$(MAKE) -C $(BUILD_MAKEFILE_DIR) all\n@echo \"Building ${PROJECT_TARGET}\"\n</code></pre>"},{"location":"SharepointSubmodule/#wildcards","title":"Wildcards","text":"<p>Makefiles commonly store multiple files or directories as space-separated lists.</p> <pre><code>PROJECT_C_INCLUDES = core/Inc drivers/Inc\nPROJECT_C_SOURCES  = core/Src/main.c drivers/Src/can.c\n</code></pre> <p>Instead of setting these manually, you can do a <code>wildcard</code> search and add all files that meet certain criteria.</p> <pre><code>PROJECT_C_SOURCES = $(wildcard */Src/*.c)\n</code></pre> <p>This looks through all immediate subdirectories for a <code>Src</code> folder and adds all <code>.c</code> files found within.</p>"},{"location":"SharepointSubmodule/#set-project-variables","title":"Set Project Variables","text":"<p>Below are several variables that the Embedded-Sharepoint Makefile uses to compile your code, these variables are used in the template Makefile, and you can update them.</p> <ul> <li><code>PROJECT_TARGET</code>: The STM32 part number (e.g., <code>stm32f446ret</code>)</li> <li><code>PROJECT_C_SOURCES</code>: List of your C source files</li> <li><code>PROJECT_C_INCLUDES</code>: List of your include directories</li> <li><code>PROJECT_BUILD_DIR</code>: Where to place build outputs</li> <li><code>BEAR_ENABLE</code> to make VSCode not mad at you (the red error squiggles). Bear is by default enabled, but you can set it to 0 to turn it off</li> </ul>"},{"location":"SharepointSubmodule/#creating-a-test-folder","title":"Creating a test folder","text":"<p>It's good to be able to test independent portions of your code instead of your whole code base at once. For example, if I have a driver just for controlling lights I should have a test file that just runs some code for my lights driver instead of the whole codebase which could be running a lot of things other than lights.</p> <p>C expects a <code>main()</code> function as the starting point of your code, so the way we generally implement this is filtering out the main.c file where the <code>main()</code> function is implemented, and compiling your test file instead with it's own <code>main()</code> function.  </p> <p>Create a <code>tests/</code> folder to store your tests, then via your Makefile you can compile those tests into your project, by default they will not be compiled. It's also good practice to add a test prefix or suffix to the name of the test file, e.g. <code>test_can.c</code> to show that it's a test file, and to avoid issues on case-insensitive filesystems like on macOS.</p>"},{"location":"SharepointSubmodule/#copy-the-gitignore","title":"Copy the .gitignore","text":"<p>A lot of junk files are generated during compilation, many of those files should not be pushed so we tell git to ignore these files. A <code>.gitignore</code> file tells which files or directories to ignore, so they are not pushed to the remote repository. There is a template .gitignore file in the template/ directory, which you should place in your firmware/ directory. You are also free to add what's in the template to your already existing .gitignore file. </p> <p>The following are files and directories you should not be pushing:</p> <ul> <li><code>.DS_Store</code> these are mac dump files that are generated in every directory</li> <li><code>build/</code> this is where compiled c files are placed by default, if you change the directory in the Makefile this needs to be updated</li> <li><code>.venv/</code> this is where python environment files are stored, and are usually user and OS dependent</li> </ul>"},{"location":"SharepointSubmodule/#4-add-necessary-functions","title":"4. Add necessary functions","text":""},{"location":"SharepointSubmodule/#create-a-mainc","title":"Create a main.c","text":"<p>Your code begins from the <code>main()</code> function, and if there is no <code>main()</code> function defined the code will not compile. The <code>main()</code> function does not necessarily have to be located in a file named <code>main.c</code> but it is good practice. If you want to use any stm32 related header files, please include the <code>stm32xx_hal.h</code> header file.</p>"},{"location":"SharepointSubmodule/#define-systemclock_config","title":"Define SystemClock_Config","text":"<p>The <code>SystemClock_Config</code> function configures the clock that your STM32 runs on (things like clock frequency, clock source, etc). If the clock is not setup properly then you risk unexpected behavior since a lot of low level embedded code runs using the system clock. We normally run the system clock at 80mhz.</p> <p>We define the SystemClock_Config function as \"weak\", which means that the function can be overridden by a different implementation of the function. We have a default implementation in the stm32xx_hal_init.c file, which by default initializes the internal oscillator of some specific Nucleo's clock, but since we operate with a variety of Nucleos and processors you should redefine the function for your specific usecase.</p> <p>Generate a new SystemClock_Config in STM32CubeMX and add it to one of your files in your repository (suggested is your main.c). This should serve as a redefinition of the function and will override the default behavior. Make sure you are generating the code with the correct microcontroller part number in the software, and you are using an external oscillator (if generating code for one of our SOM PCBs). Instructions on how to use CubeMX and generate a SystemClock_Config can be found here.</p>"},{"location":"SharepointSubmodule/#5-compiling-your-repository","title":"5. Compiling your repository","text":"<p>Code compilation must be done in a nix shell, in Embedded-Sharepoint you can normally just run</p> <pre><code>nix develop\n</code></pre> <p>since the <code>flake.nix</code> file is stored in that directory, but in your repository the flake.nix file is stored in a different directory. To enter the Nix shell when the <code>flake.nix</code> file is stored somewhere else, simply run:</p> <pre><code>nix develop [directory to where flake.nix is]\n</code></pre> <p>For example:</p> <pre><code>nix develop ./Embedded-Sharepoint\n</code></pre> <p>Once you're in the nix shell, run </p> <pre><code>make\n</code></pre> <p>in the same directory as your new Makefile.</p> <p>If you do not want to type that out everytime, you can create a bash script that runs the nix develop command and hardcodes the directory where the nix file is. See this example in VCU</p>"},{"location":"SharepointSubmodule/#6-create-a-readme","title":"6. Create a README","text":"<p>A README.md file is very important for onboarding instructions, and to outline workflows. A README should explain how to go from cloning a repository to how to contribute code. The more descriptive the better!</p>"},{"location":"SharepointSubmodule/#7-creating-github-actions","title":"7. Creating GitHub Actions","text":"<p>A GitHub Action is an automated workflow that runs on GitHub\u2019s servers in response to repository events such as pushing code, opening a pull request, or merging into a branch. Actions are commonly used to run checks like builds, tests, formatting, and static analysis so that issues are caught before code is merged.</p>"},{"location":"SharepointSubmodule/#writing-a-test-compilation-script","title":"Writing a test compilation script","text":"<p>We primarily use GitHub Actions to run build checks on code before we merge it in, your GitHub action should make sure your main and all tests compile. There is a template python script to compile all test files located in <code>/template</code>, where lines with <code>#\u2757 CHANGE THIS \u2757</code> show where you should change the script to run. </p>"},{"location":"SharepointSubmodule/#creating-the-build-action","title":"Creating the build action","text":"<p>To create a GitHub action, you need to make a <code>workflows</code> folder in the <code>.github</code> folder and create a <code>.yml</code> file that defines your GitHub action. GitHub will then run your action whenever the event your action specifies happens.</p>"},{"location":"SharepointSubmodule/#examples-of-github-actions","title":"Examples of GitHub Actions","text":"<ul> <li>VCU</li> <li>Embedded-Sharepoint</li> </ul>"},{"location":"SharepointSubmodule/#examples-of-projects-that-use-embedded-sharepoint","title":"Examples of projects that use Embedded Sharepoint","text":"<ul> <li>BPS-Leader</li> <li>VCU</li> </ul>"},{"location":"dbcEditor/","title":"Editing CAN DBC files","text":""},{"location":"dbcEditor/#what-is-a-can-dbc-file","title":"What is a CAN DBC file","text":"<p>A CAN DBC file stores encodings for CAN messages. CAN messages are grouped into IDs with a length, and then messages have specific signals which have a length and start bit. A CAN message signal stores how a value is packed into raw CAN data, including its bit position, size, scaling factor, offset, and units.  </p> <p>For example, we have Contactor Sense CAN message with an ID of <code>0x400</code>. There are various signals in this message like the state of the Array Contactor, which has a length of 1 bit and stored in the 6th bit.</p> <p>CAN DBC intro</p>"},{"location":"dbcEditor/#how-to-edit-can-dbc-files","title":"How to edit CAN DBC files","text":"<p>To edit CAN DBC files, we use an online DBC editor from CSS Electronics. We also forked the files to Embedded-Sharepoint in the <code>middleware/dbc-editor</code> directory.  </p> <p>To open the CAN DBC editor you can do one of the following:</p> <ul> <li>Open the CAN DBC editor website linked above</li> <li>Open the <code>dbc-editor.html</code> file located in <code>middleware/dbc-editor</code></li> <li>Run <code>make dbc-editor</code> in the Makefile in <code>tests/</code></li> </ul> <p>From the DBC editor you can open and edit any dbc file, all of which are stored in the <code>can/dbc</code> directory.</p> <p>Ensure that your CAN message type is set to standard, and the length of the message (DLC) is not above 8 bytes.</p> <p>Make sure all your signals have factor and unit set properly.</p>"},{"location":"dbcEditor/#suggestions-for-structuring-can-messages","title":"Suggestions for structuring CAN messages","text":"<p>When structuring CAN messages, consider which other devices on the CAN bus are using that message. </p>"},{"location":"dbcEditor/#can-message-packing","title":"CAN message packing","text":"<p>It is usually beneficial to pack as much related data as possible into a single CAN message. Devices on the bus are often limited by the number of CAN IDs they can store in hardware filters, so reducing the total number of unique message IDs helps avoid exhausting filter slots.</p> <p>As long as the message length remains under 8 bytes (for Classical CAN), there is little downside to using more bytes in a single frame. Most of the overhead in processing CAN messages comes from processing headers and handling message arbitration, so it's beneficial to have less CAN messages.</p>"},{"location":"dbcEditor/#can-multiplexing","title":"CAN multiplexing","text":"<p>CAN message multiplexing allows multiple logical message layouts to share the same CAN ID. A multiplexor signal is used to indicate which set of signals is valid for a given frame.</p> <p>For example, instead of having an ID for every battery module's voltage, you can allocate a set of bits to indicate which module the message is about.</p>"},{"location":"dbcEditor/#can-message-priority","title":"CAN message priority","text":"<p>When two CAN IDs want to go on the same CANbus at the same time, the ID with the higher \"priority\" is sent first. Lower ID numbers represent a high CAN priority. It's beneficial to make sure CAN messages that are essential to the operation of car are higher priority than other messages. </p>"},{"location":"nav/","title":"Nav","text":"<ul> <li>README</li> <li>Installation</li> <li>Flashing and Debugging</li> <li>Adding Embedded Sharepoint</li> <li>CubeMX</li> <li>STM32 Ports</li> <li>CAN Messages<ul> <li>Editing DBC Files</li> <li>Signals &amp; Messages</li> </ul> </li> <li>Drivers Documentation<ul> <li>EMC2305 Usage Guide</li> <li>EMC2305</li> <li>SevenSegment</li> <li>printf</li> </ul> </li> <li>BSP Documentation<ul> <li>ADC</li> <li>CAN</li> <li>UART</li> </ul> </li> </ul>"},{"location":"BSP/ADC_8h/","title":"File ADC.h","text":"<p>FileList &gt; bsp &gt; Inc &gt; ADC.h</p> <p>Go to the source code of this file</p> <p>Provides functions for initializing, reading, and managing ADC peripherals. More...</p> <ul> <li><code>#include \"stm32xx_hal.h\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> <li><code>#include \"queue.h\"</code></li> <li><code>#include \"semphr.h\"</code></li> </ul>"},{"location":"BSP/ADC_8h/#public-types","title":"Public Types","text":"Type Name enum adc_status_t"},{"location":"BSP/ADC_8h/#public-functions","title":"Public Functions","text":"Type Name adc_status_t adc_deinit (ADC_HandleTypeDef * h) Deinitializes the ADC peripheral. adc_status_t adc_init (ADC_InitTypeDef * init, ADC_HandleTypeDef * hadc) Initializes the ADC peripheral with the specified configuration. adc_status_t adc_read (uint32_t channel, uint32_t samplingTime, ADC_HandleTypeDef * h, QueueHandle_t q) Reads a value from the specified ADC channel."},{"location":"BSP/ADC_8h/#detailed-description","title":"Detailed Description","text":"<p>This file contains the API for working with ADC (Analog-to-Digital Converter) peripherals in an embedded system, including initialization, reading channels, and queue-based data handling (e.g., with FreeRTOS). The functions support flexible configuration of ADC instances, sampling times, and data storage mechanisms.</p> <p>Initialization:</p> <ul> <li>Call <code>adc_init()</code> to configure and initialize a specific ADC instance.</li> <li>Provide the ADC configuration structure and handle for the target peripheral.</li> <li>Returns a status code indicating success or failure.</li> </ul> <p>Reading ADC Values:</p> <ul> <li>Call <code>adc_read()</code> to sample a channel on the ADC.</li> <li>Provide the channel number, sampling time, ADC handle, and storage/queue reference.</li> <li>Returns a status code indicating success or failure.</li> </ul> <p>Data Retrieval:</p> <ul> <li>If using queues, use standard FreeRTOS queue functions (e.g., <code>xQueueReceive()</code>) to retrieve ADC readings.</li> <li>Supports both blocking and non-blocking behavior depending on the chosen timeout.</li> </ul> <p>Note:</p> <p>This driver is designed to work with multiple ADC instances and supports integration with an RTOS for asynchronous data handling. </p>"},{"location":"BSP/ADC_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"BSP/ADC_8h/#enum-adc_status_t","title":"enum adc_status_t","text":"<pre><code>enum adc_status_t {\n    ADC_OK,\n    ADC_INIT_FAIL,\n    ADC_DEINIT_FAIL,\n    ADC_CHANNEL_CONFIG_FAIL,\n    ADC_INTERRUPT_BUSY,\n    ADC_INTERRUPT_TIMEOUT,\n    ADC_INTERRUPT_ERROR,\n    ADC_QUEUE_FULL\n};\n</code></pre>"},{"location":"BSP/ADC_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/ADC_8h/#function-adc_deinit","title":"function adc_deinit","text":"<p>Deinitializes the ADC peripheral. </p> <pre><code>adc_status_t adc_deinit (\n    ADC_HandleTypeDef * h\n) \n</code></pre> <p>This function releases resources used by the ADC and resets it to its default uninitialized state.</p> <p>Parameters:</p> <ul> <li><code>h</code> Pointer to the ADC handle structure.</li> </ul> <p>Returns:</p> <p>adc_status_t Returns ADC_OK on success or an appropriate error code. </p>"},{"location":"BSP/ADC_8h/#function-adc_init","title":"function adc_init","text":"<p>Initializes the ADC peripheral with the specified configuration. </p> <pre><code>adc_status_t adc_init (\n    ADC_InitTypeDef * init,\n    ADC_HandleTypeDef * hadc\n) \n</code></pre> <p>This function sets up the ADC hardware according to the parameters in the initialization structure and prepares it for subsequent conversions.</p> <p>Parameters:</p> <ul> <li><code>init</code> ADC initialization structure containing configuration parameters. </li> <li><code>hadc</code> Pointer to the ADC handle structure.</li> </ul> <p>Returns:</p> <p>adc_status_t Returns ADC_OK on success or an appropriate error code. </p>"},{"location":"BSP/ADC_8h/#function-adc_read","title":"function adc_read","text":"<p>Reads a value from the specified ADC channel. </p> <pre><code>adc_status_t adc_read (\n    uint32_t channel,\n    uint32_t samplingTime,\n    ADC_HandleTypeDef * h,\n    QueueHandle_t q\n) \n</code></pre> <p>This function triggers a conversion on the given channel and stores the converted result in the provided queue. It supports both blocking and non-blocking operation depending on configuration.</p> <p>Parameters:</p> <ul> <li><code>channel</code> ADC channel to read from. </li> <li><code>samplingTime</code> ADC sampling time (in ADC clock cycles). </li> <li><code>h</code> Pointer to the ADC handle structure. </li> <li><code>q</code> Pointer to the user-provided queue handle for result storage.</li> </ul> <p>Returns:</p> <p>adc_status_t Returns ADC_OK on success or an appropriate error code. </p> <p>The documentation for this class was generated from the following file <code>bsp/Inc/ADC.h</code></p>"},{"location":"BSP/ADC_8h_source/","title":"File ADC.h","text":"<p>File List &gt; bsp &gt; Inc &gt; ADC.h</p> <p>Go to the documentation of this file</p> <pre><code>\n#ifndef _ADC_H\n#define _ADC_H\n\n#include \"stm32xx_hal.h\"\n\n#include \"FreeRTOS.h\"\n#include \"queue.h\"\n#include \"semphr.h\"\n\ntypedef enum {\n    ADC_OK,\n    ADC_INIT_FAIL,\n    ADC_DEINIT_FAIL,\n    ADC_CHANNEL_CONFIG_FAIL,\n    ADC_INTERRUPT_BUSY,\n    ADC_INTERRUPT_TIMEOUT,\n    ADC_INTERRUPT_ERROR,\n    ADC_QUEUE_FULL,\n\n} adc_status_t;\n\n#ifdef ADC1\nextern ADC_HandleTypeDef* hadc1;\n#endif /* ADC1 */\n#ifdef ADC2\nextern ADC_HandleTypeDef* hadc2;\n#endif /* ADC2 */\n#ifdef ADC3\nextern ADC_HandleTypeDef* hadc3;\n#endif /* ADC3 */\n#ifdef ADC4\nextern ADC_HandleTypeDef* hadc4;\n#endif /* ADC4 */\n#ifdef ADC5\nextern ADC_HandleTypeDef* hadc5;\n#endif /* ADC5 */\n\nadc_status_t adc_init(ADC_InitTypeDef *init, ADC_HandleTypeDef* hadc);\n\nadc_status_t adc_read(uint32_t channel, uint32_t samplingTime, ADC_HandleTypeDef *h, QueueHandle_t q);\n\nadc_status_t adc_deinit(ADC_HandleTypeDef *h);\n\n#endif\n</code></pre>"},{"location":"BSP/CAN_8h/","title":"File CAN.h","text":"<p>FileList &gt; bsp &gt; Inc &gt; CAN.h</p> <p>Go to the source code of this file</p> <p>CAN peripheral driver for LHRS embedded systems. More...</p> <ul> <li><code>#include \"stm32xx_hal.h\"</code></li> </ul>"},{"location":"BSP/CAN_8h/#public-types","title":"Public Types","text":"Type Name enum can_status_t"},{"location":"BSP/CAN_8h/#public-functions","title":"Public Functions","text":"Type Name can_status_t can_deinit (CAN_HandleTypeDef * handle) Deinitializes the CAN peripheral. can_status_t can_init (CAN_HandleTypeDef * handle, CAN_FilterTypeDef * filter) Initializes the CAN peripheral. can_status_t can_recv (CAN_HandleTypeDef * handle, uint16_t id, CAN_RxHeaderTypeDef * header, uint8_t data, TickType_t delay_ticks) Receives a CAN message. can_status_t can_send (CAN_HandleTypeDef * handle, const CAN_TxHeaderTypeDef * header, const uint8_t data, TickType_t delay_ticks) Sends a CAN message. can_status_t can_start (CAN_HandleTypeDef * handle) Starts the CAN peripheral. can_status_t can_stop (CAN_HandleTypeDef * handle) Stops the CAN peripheral."},{"location":"BSP/CAN_8h/#detailed-description","title":"Detailed Description","text":"<p>This driver provides initialization, deinitialization, start/stop, sending, and receiving functionality for CAN peripherals.</p> <p>Function Descriptions:</p> <ul> <li>Init: Initializes the CAN peripheral given the configuration (does not start the CAN peripheral).</li> <li>DeInit: Deinitializes the CAN peripheral; resets configuration to default values.</li> <li>Start: Starts the CAN peripheral, enabling interrupts and message handling.</li> <li>Stop: Stops the CAN peripheral; configuration is unchanged, but interrupts and message handling are disabled.</li> <li>Send: Prepares a message to be sent when the CAN peripheral is ready (puts it into a queue).</li> <li>Recv: Reads a message from the queue depending on ID.</li> </ul> <p>How to Use This Driver:</p> <ul> <li>Init to initialize the CAN peripheral.</li> <li>Start to activate the CAN peripheral.</li> <li>Use Send, Recv, Stop, and Start as needed.</li> <li>DeInit to deinitialize the CAN peripheral.</li> </ul> <p>Usage Notes:</p> <ul> <li>CAN2 is usually a slave CAN, sharing transistors with CAN1. Ensure CAN1 is initialized before CAN2.</li> <li>CAN2 often shares filter banks with CAN1; carefully consider filter configurations passed to can_init.</li> <li>CAN3 is usually a master CAN; no sharing considerations are needed.</li> <li>This driver uses a macro to define which messages a CAN interface should receive. See can1_recv_entries.h for examples. Ensure entries align with filter configurations. </li> </ul>"},{"location":"BSP/CAN_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"BSP/CAN_8h/#enum-can_status_t","title":"enum can_status_t","text":"<pre><code>enum can_status_t {\n    CAN_ERR,\n    CAN_OK,\n    CAN_SENT,\n    CAN_RECV,\n    CAN_EMPTY\n};\n</code></pre>"},{"location":"BSP/CAN_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/CAN_8h/#function-can_deinit","title":"function can_deinit","text":"<p>Deinitializes the CAN peripheral. </p> <pre><code>can_status_t can_deinit (\n    CAN_HandleTypeDef * handle\n) \n</code></pre> <p>This function deinitializes the HAL CAN driver and disables CAN interrupts.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Pointer to the CAN handle structure.</li> </ul> <p>Returns:</p> <p>can_status_t Returns CAN_OK on success, CAN_ERR on failure. </p>"},{"location":"BSP/CAN_8h/#function-can_init","title":"function can_init","text":"<p>Initializes the CAN peripheral. </p> <pre><code>can_status_t can_init (\n    CAN_HandleTypeDef * handle,\n    CAN_FilterTypeDef * filter\n) \n</code></pre> <p>This function initializes the CAN peripheral, sets up send/receive queues, configures the HAL CAN driver, applies the filter configuration, and enables CAN interrupts.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Pointer to the CAN handle structure. </li> <li><code>filter</code> Pointer to the CAN filter configuration structure.</li> </ul> <p>Returns:</p> <p>can_status_t Returns CAN_OK on success, CAN_ERR on failure. </p>"},{"location":"BSP/CAN_8h/#function-can_recv","title":"function can_recv","text":"<p>Receives a CAN message. </p> <pre><code>can_status_t can_recv (\n    CAN_HandleTypeDef * handle,\n    uint16_t id,\n    CAN_RxHeaderTypeDef * header,\n    uint8_t data,\n    TickType_t delay_ticks\n) \n</code></pre> <p>Reads a message from the receive queue corresponding to the specified ID. Supports blocking or non-blocking behavior depending on delay_ticks.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Pointer to the CAN handle structure. </li> <li><code>id</code> CAN identifier of the message to receive. </li> <li><code>header</code> Pointer to a CAN_RxHeaderTypeDef structure to store the received header. </li> <li><code>data</code> Array to store the received data. </li> <li><code>delay_ticks</code> Maximum delay to wait if queue is empty (FreeRTOS ticks).</li> </ul> <p>Returns:</p> <p>can_status_t Returns CAN_RECV if a message was received, CAN_EMPTY if the queue was empty, CAN_ERR on failure or invalid ID. </p>"},{"location":"BSP/CAN_8h/#function-can_send","title":"function can_send","text":"<p>Sends a CAN message. </p> <pre><code>can_status_t can_send (\n    CAN_HandleTypeDef * handle,\n    const CAN_TxHeaderTypeDef * header,\n    const uint8_t data,\n    TickType_t delay_ticks\n) \n</code></pre> <p>Places a CAN message into the transmit mailbox if available, otherwise queues it in the send queue for later transmission.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Pointer to the CAN handle structure. </li> <li><code>header</code> Pointer to the CAN transmit header structure. </li> <li><code>data</code> Array containing the data to send. </li> <li><code>delay_ticks</code> Maximum delay to wait if queue is full (FreeRTOS ticks).</li> </ul> <p>Returns:</p> <p>can_status_t Returns CAN_SENT if message was successfully sent or queued, CAN_ERR on failure. </p>"},{"location":"BSP/CAN_8h/#function-can_start","title":"function can_start","text":"<p>Starts the CAN peripheral. </p> <pre><code>can_status_t can_start (\n    CAN_HandleTypeDef * handle\n) \n</code></pre> <p>Activates the CAN peripheral so it can transmit and receive messages.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Pointer to the CAN handle structure.</li> </ul> <p>Returns:</p> <p>can_status_t Returns CAN_OK on success, CAN_ERR on failure. </p>"},{"location":"BSP/CAN_8h/#function-can_stop","title":"function can_stop","text":"<p>Stops the CAN peripheral. </p> <pre><code>can_status_t can_stop (\n    CAN_HandleTypeDef * handle\n) \n</code></pre> <p>Stops the CAN peripheral; the configuration is preserved, but the peripheral will not process messages or trigger interrupts.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Pointer to the CAN handle structure.</li> </ul> <p>Returns:</p> <p>can_status_t Returns CAN_OK on success, CAN_ERR on failure. </p> <p>The documentation for this class was generated from the following file <code>bsp/Inc/CAN.h</code></p>"},{"location":"BSP/CAN_8h_source/","title":"File CAN.h","text":"<p>File List &gt; bsp &gt; Inc &gt; CAN.h</p> <p>Go to the documentation of this file</p> <pre><code>\n#ifndef CAN_H\n#define CAN_H\n\n#include \"stm32xx_hal.h\"\n\n#if !defined(CAN1)\n  #error \"[CONFIG] CAN not enabled on this chip.\"\n#endif /* CAN1 */\n\n// return code for can driver\ntypedef enum {\n    CAN_ERR,   // unsuccessful operation\n    CAN_OK,\n    CAN_SENT,  // successful send\n    CAN_RECV,  // successful recieve\n    CAN_EMPTY, // recieved nothing with no errors\n} can_status_t;\n\n// can handlers\n#ifdef CAN1\nextern CAN_HandleTypeDef* hcan1;\n#endif /* CAN1 */\n\n#ifdef CAN2\nextern CAN_HandleTypeDef* hcan2;\n#endif /* CAN2 */\n\n#ifdef CAN3\nextern CAN_HandleTypeDef* hcan3;\n#endif /* CAN3 */\n\ncan_status_t can_init(CAN_HandleTypeDef* handle, CAN_FilterTypeDef* filter);\n\ncan_status_t can_deinit(CAN_HandleTypeDef* handle);\n\ncan_status_t can_start(CAN_HandleTypeDef* handle);\n\ncan_status_t can_stop(CAN_HandleTypeDef* handle);\n\ncan_status_t can_send(CAN_HandleTypeDef* handle,\n                      const CAN_TxHeaderTypeDef* header, const uint8_t data[],\n                      TickType_t delay_ticks);\n\ncan_status_t can_recv(CAN_HandleTypeDef* handle, uint16_t id,\n                      CAN_RxHeaderTypeDef* header, uint8_t data[],\n                      TickType_t delay_ticks);\n\n#endif /* CAN_H */\n</code></pre>"},{"location":"BSP/UART_8h/","title":"File UART.h","text":"<p>FileList &gt; bsp &gt; Inc &gt; UART.h</p> <p>Go to the source code of this file</p> <p>Provides functions for initializing, sending, receiving, and managing UART peripherals. More...</p> <ul> <li><code>#include \"stm32xx_hal.h\"</code></li> </ul>"},{"location":"BSP/UART_8h/#public-types","title":"Public Types","text":"Type Name enum uart_status_t"},{"location":"BSP/UART_8h/#public-functions","title":"Public Functions","text":"Type Name uart_status_t uart_deinit (UART_HandleTypeDef * handle) Deinitializes the specified UART peripheral. uart_status_t uart_init (UART_HandleTypeDef * handle) Initializes the specified UART peripheral. uart_status_t uart_recv (UART_HandleTypeDef * handle, uint8_t * data, uint8_t length, TickType_t delay_ticks) Receives data from UART RX queue. uart_status_t uart_send (UART_HandleTypeDef * handle, const uint8_t * data, uint8_t length, TickType_t delay_ticks) Transmits data over UART. If a transmission is in progress, data will be queued."},{"location":"BSP/UART_8h/#detailed-description","title":"Detailed Description","text":"<p>This file contains the API for working with UART (Universal Asynchronous Receiver/Transmitter) peripherals in an embedded system, including initialization, data transmission, reception, and queue-based handling (e.g., with FreeRTOS). The functions support flexible configuration of UART instances and integration with user-provided GPIO initialization.</p> <p>Initialization:</p> <ul> <li>Call <code>uart_init()</code> to configure and initialize a specific UART peripheral.</li> <li>Provide the UART configuration structure and handle for the target peripheral.</li> <li>Returns a status code indicating success or failure.</li> </ul> <p>Data Transmission:</p> <ul> <li>Call <code>uart_send()</code> to queue data for transmission over the UART.</li> <li>The function will transmit when the peripheral is available.</li> </ul> <p>Data Reception:</p> <ul> <li>Call <code>uart_recv()</code> to read received data from the RX queue.</li> <li>Specify the number of bytes to read.</li> </ul> <p>Deinitialization:</p> <ul> <li>Call <code>uart_deinit()</code> to reset the UART peripheral and release resources.</li> </ul> <p>Note:</p> <ul> <li>The functions <code>HAL_UART_MspGPIOInit()</code> and <code>HAL_UART_MspGPIODeInit()</code> must be overridden by the user to provide GPIO initialization/deinitialization for the selected UART, including enabling clocks and calling <code>HAL_GPIO_Init()</code> with the correct <code>GPIO_InitTypeDef</code>.</li> <li>Each UART peripheral is currently intended for use by a single task since only one receive queue exists. </li> </ul>"},{"location":"BSP/UART_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"BSP/UART_8h/#enum-uart_status_t","title":"enum uart_status_t","text":"<pre><code>enum uart_status_t {\n    UART_ERR,\n    UART_OK,\n    UART_SENT,\n    UART_RECV,\n    UART_EMPTY\n};\n</code></pre>"},{"location":"BSP/UART_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/UART_8h/#function-uart_deinit","title":"function uart_deinit","text":"<p>Deinitializes the specified UART peripheral. </p> <pre><code>uart_status_t uart_deinit (\n    UART_HandleTypeDef * handle\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>handle</code> Pointer to the UART handle. </li> </ul> <p>Returns:</p> <p>uart_status_t Returns UART_OK on success, UART_ERR on failure. </p>"},{"location":"BSP/UART_8h/#function-uart_init","title":"function uart_init","text":"<p>Initializes the specified UART peripheral. </p> <pre><code>uart_status_t uart_init (\n    UART_HandleTypeDef * handle\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>handle</code> Pointer to the UART handle. </li> </ul> <p>Returns:</p> <p>uart_status_t Returns UART_OK on success, UART_ERR on failure. </p>"},{"location":"BSP/UART_8h/#function-uart_recv","title":"function uart_recv","text":"<p>Receives data from UART RX queue. </p> <pre><code>uart_status_t uart_recv (\n    UART_HandleTypeDef * handle,\n    uint8_t * data,\n    uint8_t length,\n    TickType_t delay_ticks\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>handle</code> Pointer to the UART handle. </li> <li><code>data</code> Pointer to buffer where received data will be stored. </li> <li><code>length</code> Number of bytes to read. </li> <li><code>delay_ticks</code> Ticks to wait for data (0 = non-blocking, portMAX_DELAY = block until available). </li> </ul> <p>Returns:</p> <p>uart_status_t Returns UART_RECV on success, UART_EMPTY if RX queue empty, UART_ERR on failure. </p>"},{"location":"BSP/UART_8h/#function-uart_send","title":"function uart_send","text":"<p>Transmits data over UART. If a transmission is in progress, data will be queued. </p> <pre><code>uart_status_t uart_send (\n    UART_HandleTypeDef * handle,\n    const uint8_t * data,\n    uint8_t length,\n    TickType_t delay_ticks\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>handle</code> Pointer to the UART handle. </li> <li><code>data</code> Pointer to the buffer containing data to send. </li> <li><code>length</code> Number of bytes to transmit. </li> <li><code>delay_ticks</code> Ticks to wait if TX queue is full (0 = no wait, portMAX_DELAY = wait indefinitely). </li> </ul> <p>Returns:</p> <p>uart_status_t Returns UART_SENT on queued/sent, UART_ERR on failure. </p> <p>The documentation for this class was generated from the following file <code>bsp/Inc/UART.h</code></p>"},{"location":"BSP/UART_8h_source/","title":"File UART.h","text":"<p>File List &gt; bsp &gt; Inc &gt; UART.h</p> <p>Go to the documentation of this file</p> <pre><code>\n#ifndef UART_H_\n#define UART_H_\n\n#include \"stm32xx_hal.h\"\n\n#if !defined(UART4) &amp;&amp; !defined(USART1)\n  #error \"[CONFIG] UART not enabled on this chip.\"\n#endif /* UART4 */\n\n// Return codes for UART operations\ntypedef enum {\n    UART_ERR,\n    UART_OK,\n    UART_SENT,\n    UART_RECV,\n    UART_EMPTY,\n} uart_status_t;\n\n// uart handlers\n#ifdef UART4\nextern UART_HandleTypeDef* huart4;\n#endif /* UART4 */\n\n#ifdef UART5\nextern UART_HandleTypeDef* huart5;\n#endif /* UART5 */\n\n#ifdef USART1\nextern UART_HandleTypeDef* husart1;\n#endif /* USART1 */\n\n#ifdef USART2\nextern UART_HandleTypeDef* husart2;\n#endif /* USART2 */\n\n#ifdef USART3\nextern UART_HandleTypeDef* husart3;\n#endif /* USART3 */\n\nuart_status_t uart_init(UART_HandleTypeDef* handle);\n\nuart_status_t uart_deinit(UART_HandleTypeDef* handle);\n\nuart_status_t uart_send(UART_HandleTypeDef* handle, const uint8_t* data, uint8_t length, TickType_t delay_ticks);\n\nuart_status_t uart_recv(UART_HandleTypeDef* handle, uint8_t* data, uint8_t length, TickType_t delay_ticks);\n\n#endif /* UART_H_ */\n</code></pre>"},{"location":"BSP/annotated/","title":"Class List","text":"<p>No classes, structs, unions or interfaces found.</p>"},{"location":"BSP/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"BSP/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"BSP/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"BSP/class_member_variables/","title":"Class Member Variables","text":"<p>Nothing related to Class Member Variables found.</p>"},{"location":"BSP/class_members/","title":"Class Members","text":"<p>Nothing related to Class Members found.</p>"},{"location":"BSP/classes/","title":"Class Index","text":""},{"location":"BSP/dir_3c5459f7c179b79c90e2565474bb2856/","title":"Dir bsp","text":"<p>FileList &gt; bsp</p>"},{"location":"BSP/dir_3c5459f7c179b79c90e2565474bb2856/#directories","title":"Directories","text":"Type Name dir Inc <p>The documentation for this class was generated from the following file <code>bsp/</code></p>"},{"location":"BSP/dir_f9758a777e5683291000913d5e959461/","title":"Dir bsp/Inc","text":"<p>FileList &gt; bsp &gt; Inc</p>"},{"location":"BSP/dir_f9758a777e5683291000913d5e959461/#files","title":"Files","text":"Type Name file ADC.h Provides functions for initializing, reading, and managing ADC peripherals. file CAN.h CAN peripheral driver for LHRS embedded systems. file UART.h Provides functions for initializing, sending, receiving, and managing UART peripherals. <p>The documentation for this class was generated from the following file <code>bsp/Inc/</code></p>"},{"location":"BSP/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir bsp <ul> <li>dir Inc <ul> <li>file ADC.h Provides functions for initializing, reading, and managing ADC peripherals. </li> <li>file CAN.h CAN peripheral driver for LHRS embedded systems. </li> <li>file UART.h Provides functions for initializing, sending, receiving, and managing UART peripherals. </li> </ul> </li> </ul> </li> </ul>"},{"location":"BSP/functions/","title":"Functions","text":""},{"location":"BSP/functions/#a","title":"a","text":"<ul> <li>adc_deinit (ADC.h)</li> <li>adc_init (ADC.h)</li> <li>adc_read (ADC.h)</li> </ul>"},{"location":"BSP/functions/#c","title":"c","text":"<ul> <li>can_deinit (CAN.h)</li> <li>can_init (CAN.h)</li> <li>can_recv (CAN.h)</li> <li>can_send (CAN.h)</li> <li>can_start (CAN.h)</li> <li>can_stop (CAN.h)</li> </ul>"},{"location":"BSP/functions/#u","title":"u","text":"<ul> <li>uart_deinit (UART.h)</li> <li>uart_init (UART.h)</li> <li>uart_recv (UART.h)</li> <li>uart_send (UART.h)</li> </ul>"},{"location":"BSP/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p>"},{"location":"BSP/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"BSP/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"BSP/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"BSP/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"BSP/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"BSP/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"BSP/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"BSP/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"BSP/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"BSP/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"BSP/variables/","title":"Variables","text":""},{"location":"BSP/variables/#a","title":"a","text":"<ul> <li>adc_status_t (ADC.h)</li> </ul>"},{"location":"BSP/variables/#c","title":"c","text":"<ul> <li>can_status_t (CAN.h)</li> </ul>"},{"location":"BSP/variables/#u","title":"u","text":"<ul> <li>uart_status_t (UART.h)</li> </ul>"},{"location":"Drivers/EMC2305_8h/","title":"File EMC2305.h","text":"<p>FileList &gt; driver &gt; Inc &gt; EMC2305.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"stm32xx_hal.h\"</code></li> <li><code>#include \"FreeRTOS.h\"</code></li> </ul>"},{"location":"Drivers/EMC2305_8h/#classes","title":"Classes","text":"Type Name struct EMC2305_Fan_Config1 struct EMC2305_Fan_Config2 struct EMC2305_Fan_Status struct EMC2305_Global_Config struct EMC2305_HandleTypeDef struct EMC2305_I2C_Message"},{"location":"Drivers/EMC2305_8h/#public-types","title":"Public Types","text":"Type Name enum EMC2305_DPT enum EMC2305_EDG enum EMC2305_ERG enum EMC2305_Fan enum EMC2305_I2C_OP enum EMC2305_PID_Gain enum EMC2305_PWM_BaseFreq enum EMC2305_RNG enum EMC2305_Status enum EMC2305_UDT"},{"location":"Drivers/EMC2305_8h/#public-functions","title":"Public Functions","text":"Type Name EMC2305_Status EMC2305_EnableSWLock (EMC2305_HandleTypeDef * chip) Software locks all SWL registers. SWL registers are now read-only until power cycle. uint8_t EMC2305_GetFanPWM (EMC2305_HandleTypeDef * chip, EMC2305_Fan fan) Gets current fan driver PWM duty cycle. uint16_t EMC2305_GetFanRPM (EMC2305_HandleTypeDef * chip, EMC2305_Fan fan) Gets current fan RPM based on tachometer measurement. EMC2305_Fan_Status EMC2305_GetFanStatus (EMC2305_HandleTypeDef * chip) Gets current fan status for all drivers. void EMC2305_I2C_MasterRxCpltCallback (I2C_HandleTypeDef * hi2c)  void EMC2305_I2C_MasterTxCpltCallback (I2C_HandleTypeDef * hi2c)  void EMC2305_I2C_Worker_Task (void * pvParameters)  EMC2305_Status EMC2305_Init (EMC2305_HandleTypeDef * chip, I2C_HandleTypeDef * hi2c, uint16_t dev_addr) Initializes the I2C bus and validates the chip by reading the Product ID and Manufacturer ID. EMC2305_Status EMC2305_ReadReg (EMC2305_HandleTypeDef * chip, uint8_t reg, uint8_t * data) Reads a byte of data from the specified register. EMC2305_Status EMC2305_SetFanConfig (EMC2305_HandleTypeDef * chip, EMC2305_Fan fan, EMC2305_Fan_Config1 * config1, EMC2305_Fan_Config2 * config2) Sets the EMC2305 configuration 1 and 2 registers based on the provided config. EMC2305_Status EMC2305_SetFanPWM (EMC2305_HandleTypeDef * chip, EMC2305_Fan fan, uint8_t duty_cycle) Sets the PWM drive of the specified fan directly. Works only with fan speed control (FSC) disabled. EMC2305_Status EMC2305_SetFanRPM (EMC2305_HandleTypeDef * chip, EMC2305_Fan fan, uint16_t rpm_target) Sets the RPM target for the control algorithm. Works only with fan speed control (FSC) enabled. EMC2305_Status EMC2305_SetGlobalConfig (EMC2305_HandleTypeDef * chip, EMC2305_Global_Config * config) Sets the EMC2305 global configuration register based on provided config. EMC2305_Status EMC2305_SetPWMBaseFrequency (EMC2305_HandleTypeDef * chip, EMC2305_Fan fan, EMC2305_PWM_BaseFreq freq) Sets the base frequency of the specified fan's PWM driver. EMC2305_Status EMC2305_SetPWMOutputMode (EMC2305_HandleTypeDef * chip, EMC2305_Fan fan, bool open_drain) Sets the specified fan's PWM driver to open-drain or push-pull. EMC2305_Status EMC2305_WriteReg (EMC2305_HandleTypeDef * chip, uint8_t reg, uint8_t data) Writes a byte of data to the specified register."},{"location":"Drivers/EMC2305_8h/#macros","title":"Macros","text":"Type Name define EMC2305_CFG_DIS_TO <code>(1u &amp;lt;&amp;lt; 6)  /\\* DIS\\_TO - SMBus timeout disable (I2C compat) \\*/</code> define EMC2305_CFG_DRECK <code>(1u &amp;lt;&amp;lt; 1)  /\\* DRECK - CLK pin drives internal clock when set (output) \\*/</code> define EMC2305_CFG_MASK_ALERT <code>(1u &amp;lt;&amp;lt; 7)  /\\* MASK - mask ALERT pin when set \\*/</code> define EMC2305_CFG_USECK <code>(1u &amp;lt;&amp;lt; 0)  /\\* USECK - use external CLK pin as tach clock when set \\*/</code> define EMC2305_CFG_WD_EN <code>(1u &amp;lt;&amp;lt; 5)  /\\* WD\\_EN - enable watchdog continuous mode \\*/</code> define EMC2305_CONFIG1_EDG_SHIFT <code>3u</code> define EMC2305_CONFIG1_ENAG_SHIFT <code>7u</code> define EMC2305_CONFIG1_RNG_SHIFT <code>5u</code> define EMC2305_CONFIG1_UDT_SHIFT <code>0u</code> define EMC2305_CONFIG2_DPT_SHIFT <code>3u</code> define EMC2305_CONFIG2_ENRC_SHIFT <code>6u</code> define EMC2305_CONFIG2_ERG_SHIFT <code>1u</code> define EMC2305_CONFIG2_GHEN_SHIFT <code>5u</code> define EMC2305_FAN1_MASK <code>(1u &amp;lt;&amp;lt; 0)</code> define EMC2305_FAN2_MASK <code>(1u &amp;lt;&amp;lt; 1)</code> define EMC2305_FAN3_MASK <code>(1u &amp;lt;&amp;lt; 2)</code> define EMC2305_FAN4_MASK <code>(1u &amp;lt;&amp;lt; 3)</code> define EMC2305_FAN5_MASK <code>(1u &amp;lt;&amp;lt; 4)</code> define EMC2305_FAN_ADDRESS_OFFSET <code>0x10u</code> define EMC2305_FAN_REG_ADDR (fan_num, fan1_reg_addr) <code>((fan1\\_reg\\_addr) + ((fan\\_num) \\* [**EMC2305\\_FAN\\_ADDRESS\\_OFFSET**](EMC2305_8h.md#define-emc2305_fan_address_offset)))</code>Calculates the register address for a specific fan (N) based on the Fan 1 register address and known offset. define EMC2305_I2C_TIMEOUT <code>100u</code> define EMC2305_INVALID_FAN (fan_num) <code>(fan &amp;lt; EMC2305\\_FAN1 \\|\\| fan &amp;gt; EMC2305\\_FAN5)</code> define EMC2305_MAX_RPM <code>16000</code> define EMC2305_MIN_RPM <code>500</code> define EMC2305_PWM_FAN1_MASK <code>0x03u</code> define EMC2305_PWM_FAN1_SHIFT <code>0u</code> define EMC2305_PWM_FAN2_MASK <code>0x0Cu</code> define EMC2305_PWM_FAN2_SHIFT <code>2u</code> define EMC2305_PWM_FAN3_MASK <code>0x30u</code> define EMC2305_PWM_FAN3_SHIFT <code>4u</code> define EMC2305_PWM_FAN4_MASK <code>0x03u</code> define EMC2305_PWM_FAN4_SHIFT <code>0u</code> define EMC2305_PWM_FAN5_MASK <code>0x0Cu</code> define EMC2305_PWM_FAN5_SHIFT <code>2u</code> define EMC2305_QUEUE_ITEM_SIZE <code>sizeof([**EMC2305\\_I2C\\_Message**](structEMC2305__I2C__Message.md))</code> define EMC2305_QUEUE_LENGTH <code>10</code> define EMC2305_REG_CONFIGURATION <code>0x20u</code> define EMC2305_REG_DRIVE_FAIL_STATUS <code>0x27u</code> define EMC2305_REG_FAN1_CONFIG1 <code>0x32u</code> define EMC2305_REG_FAN1_CONFIG2 <code>0x33u</code> define EMC2305_REG_FAN1_DRVFAIL_H <code>0x3Bu</code> define EMC2305_REG_FAN1_DRVFAIL_L <code>0x3Au</code> define EMC2305_REG_FAN1_MAX_STEP <code>0x37u</code> define EMC2305_REG_FAN1_MIN_DRIVE <code>0x38u</code> define EMC2305_REG_FAN1_SETTING <code>0x30u</code> define EMC2305_REG_FAN1_SPIN <code>0x36u</code> define EMC2305_REG_FAN1_TACH_READING_H <code>0x3Eu</code> define EMC2305_REG_FAN1_TACH_READING_L <code>0x3Fu</code> define EMC2305_REG_FAN1_TACH_TARGET_H <code>0x3Du</code> define EMC2305_REG_FAN1_TACH_TARGET_L <code>0x3Cu</code> define EMC2305_REG_FAN1_VALID_TACH <code>0x39u</code> define EMC2305_REG_FAN_INTERRUPT_ENABLE <code>0x29u</code> define EMC2305_REG_FAN_SPIN_STATUS <code>0x26u</code> define EMC2305_REG_FAN_STALL_STATUS <code>0x25u</code> define EMC2305_REG_FAN_STATUS <code>0x24u</code> define EMC2305_REG_GAIN1 <code>0x35u</code> define EMC2305_REG_MANUFACTURER_ID <code>0xFEu</code> define EMC2305_REG_PRODUCT_FEAT <code>0xFCu</code> define EMC2305_REG_PRODUCT_ID <code>0xFDu</code> define EMC2305_REG_PWM1_DIVIDE <code>0x31u</code> define EMC2305_REG_PWM_BASEF123 <code>0x2Du</code> define EMC2305_REG_PWM_BASEF45 <code>0x2Cu</code> define EMC2305_REG_PWM_OUTPUT_CONFIG <code>0x2Bu</code> define EMC2305_REG_PWM_POLARITY <code>0x2Au</code> define EMC2305_REG_REVISION <code>0xFFu</code> define EMC2305_REG_SW_LOCK <code>0xEFu</code> define EMC2305_SEMAPHORE_POOL_SIZE <code>[**EMC2305\\_QUEUE\\_LENGTH**](EMC2305_8h.md#define-emc2305_queue_length)</code> define EMC2305_STAT_DRVFAIL <code>(1u &amp;lt;&amp;lt; 2)  /\\* Drive fail summary \\*/</code> define EMC2305_STAT_FNSPIN <code>(1u &amp;lt;&amp;lt; 1)  /\\* spin-up failure summary \\*/</code> define EMC2305_STAT_FNSTL <code>(1u &amp;lt;&amp;lt; 0)  /\\* stall summary \\*/</code> define EMC2305_STAT_WATCH <code>(1u &amp;lt;&amp;lt; 7)  /\\* WATCH - watchdog fired (read-to-clear) \\*/</code> define EMC2305_SWL <code>(1u &amp;lt;&amp;lt; 0)</code> define EMC2305_TACH_MULT <code>2u</code> define EMC2305_TACH_RPM_CONV <code>3932160u</code>"},{"location":"Drivers/EMC2305_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Drivers/EMC2305_8h/#enum-emc2305_dpt","title":"enum EMC2305_DPT","text":"<pre><code>enum EMC2305_DPT {\n    EMC2305_DPT_NONE = 0b00,\n    EMC2305_DPT_BASIC = 0b01,\n    EMC2305_DPT_STEP = 0b10,\n    EMC2305_DPT_BOTH = 0b11\n};\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#enum-emc2305_edg","title":"enum EMC2305_EDG","text":"<pre><code>enum EMC2305_EDG {\n    EMC2305_EDG_9 = 0b11,\n    EMC2305_EDG_7 = 0b10,\n    EMC2305_EDG_5 = 0b01,\n    EMC2305_EDG_3 = 0b00\n};\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#enum-emc2305_erg","title":"enum EMC2305_ERG","text":"<pre><code>enum EMC2305_ERG {\n    EMC2305_ERG_0RPM = 0b00,\n    EMC2305_ERG_50RPM = 0b01,\n    EMC2305_ERG_100RPM = 0b10,\n    EMC2305_ERG_200RPM = 0b11\n};\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#enum-emc2305_fan","title":"enum EMC2305_Fan","text":"<pre><code>enum EMC2305_Fan {\n    EMC2305_FAN1,\n    EMC2305_FAN2,\n    EMC2305_FAN3,\n    EMC2305_FAN4,\n    EMC2305_FAN5\n};\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#enum-emc2305_i2c_op","title":"enum EMC2305_I2C_OP","text":"<pre><code>enum EMC2305_I2C_OP {\n    EMC2305_OP_WRITE,\n    EMC2305_OP_READ\n};\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#enum-emc2305_pid_gain","title":"enum EMC2305_PID_Gain","text":"<pre><code>enum EMC2305_PID_Gain {\n    EMC2305_PID_8X = 0b11,\n    EMC2305_PID_4X = 0b10,\n    EMC2305_PID_2X = 0b01,\n    EMC2305_PID_1X = 0b00\n};\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#enum-emc2305_pwm_basefreq","title":"enum EMC2305_PWM_BaseFreq","text":"<pre><code>enum EMC2305_PWM_BaseFreq {\n    EMC2305_PWM_2k441 = 0b11,\n    EMC2305_PWM_4k882 = 0b10,\n    EMC2305_PWM_19k53 = 0b01,\n    EMC2305_PWM_26k00 = 0b00\n};\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#enum-emc2305_rng","title":"enum EMC2305_RNG","text":"<pre><code>enum EMC2305_RNG {\n    EMC2305_RNG_4000 = 0b11,\n    EMC2305_RNG_2000 = 0b10,\n    EMC2305_RNG_1000 = 0b01,\n    EMC2305_RNG_500 = 0b00\n};\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#enum-emc2305_status","title":"enum EMC2305_Status","text":"<pre><code>enum EMC2305_Status {\n    EMC2305_OK,\n    EMC2305_ERR\n};\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#enum-emc2305_udt","title":"enum EMC2305_UDT","text":"<pre><code>enum EMC2305_UDT {\n    EMC2305_UDT_100 = 0b000,\n    EMC2305_UDT_200 = 0b001,\n    EMC2305_UDT_300 = 0b010,\n    EMC2305_UDT_400 = 0b011,\n    EMC2305_UDT_500 = 0b100,\n    EMC2305_UDT_800 = 0b101,\n    EMC2305_UDT_1200 = 0b110,\n    EMC2305_UDT_1600 = 0b111\n};\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Drivers/EMC2305_8h/#function-emc2305_enableswlock","title":"function EMC2305_EnableSWLock","text":"<p>Software locks all SWL registers. SWL registers are now read-only until power cycle. </p> <pre><code>EMC2305_Status EMC2305_EnableSWLock (\n    EMC2305_HandleTypeDef * chip\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 to lock </li> </ul> <p>Returns:</p> <p>OK if successful, ERR otherwise </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_getfanpwm","title":"function EMC2305_GetFanPWM","text":"<p>Gets current fan driver PWM duty cycle. </p> <pre><code>uint8_t EMC2305_GetFanPWM (\n    EMC2305_HandleTypeDef * chip,\n    EMC2305_Fan fan\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 to get </li> <li><code>fan</code> Fan to get (1-5) </li> </ul> <p>Returns:</p> <p>Driven fan PWM duty cycle (0-100). UINT8_MAX on error </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_getfanrpm","title":"function EMC2305_GetFanRPM","text":"<p>Gets current fan RPM based on tachometer measurement. </p> <pre><code>uint16_t EMC2305_GetFanRPM (\n    EMC2305_HandleTypeDef * chip,\n    EMC2305_Fan fan\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 to get </li> <li><code>fan</code> Fan to get (1-5) </li> </ul> <p>Returns:</p> <p>Measured fan RPM. UINT16_MAX on error </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_getfanstatus","title":"function EMC2305_GetFanStatus","text":"<p>Gets current fan status for all drivers. </p> <pre><code>EMC2305_Fan_Status EMC2305_GetFanStatus (\n    EMC2305_HandleTypeDef * chip\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 to get </li> </ul> <p>Returns:</p> <p>Fan status for all drivers </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_i2c_masterrxcpltcallback","title":"function EMC2305_I2C_MasterRxCpltCallback","text":"<pre><code>void EMC2305_I2C_MasterRxCpltCallback (\n    I2C_HandleTypeDef * hi2c\n) \n</code></pre>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_i2c_mastertxcpltcallback","title":"function EMC2305_I2C_MasterTxCpltCallback","text":"<pre><code>void EMC2305_I2C_MasterTxCpltCallback (\n    I2C_HandleTypeDef * hi2c\n) \n</code></pre>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_i2c_worker_task","title":"function EMC2305_I2C_Worker_Task","text":"<pre><code>void EMC2305_I2C_Worker_Task (\n    void * pvParameters\n) \n</code></pre>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_init","title":"function EMC2305_Init","text":"<p>Initializes the I2C bus and validates the chip by reading the Product ID and Manufacturer ID. </p> <pre><code>EMC2305_Status EMC2305_Init (\n    EMC2305_HandleTypeDef * chip,\n    I2C_HandleTypeDef * hi2c,\n    uint16_t dev_addr\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 to initialize </li> <li><code>hi2c</code> STM32 HAL I2C handle </li> <li><code>dev_addr</code> Device address (7-bit address &lt;&lt; 1) </li> </ul> <p>Returns:</p> <p>OK if successful, ERR otherwise </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_readreg","title":"function EMC2305_ReadReg","text":"<p>Reads a byte of data from the specified register. </p> <pre><code>EMC2305_Status EMC2305_ReadReg (\n    EMC2305_HandleTypeDef * chip,\n    uint8_t reg,\n    uint8_t * data\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 handle </li> <li><code>reg</code> Register to read from </li> <li><code>data</code> Pointer where register data will be stored </li> </ul> <p>Returns:</p> <p>OK if successful, ERR if message queue is full </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_setfanconfig","title":"function EMC2305_SetFanConfig","text":"<p>Sets the EMC2305 configuration 1 and 2 registers based on the provided config. </p> <pre><code>EMC2305_Status EMC2305_SetFanConfig (\n    EMC2305_HandleTypeDef * chip,\n    EMC2305_Fan fan,\n    EMC2305_Fan_Config1 * config1,\n    EMC2305_Fan_Config2 * config2\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 to set </li> <li><code>fan</code> Fan to set (1-5) </li> <li><code>config1</code> Configuration for register 1 </li> <li><code>config2</code> Configuration for register 2 </li> </ul> <p>Returns:</p> <p>OK if successful, ERR otherwise </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_setfanpwm","title":"function EMC2305_SetFanPWM","text":"<p>Sets the PWM drive of the specified fan directly. Works only with fan speed control (FSC) disabled. </p> <pre><code>EMC2305_Status EMC2305_SetFanPWM (\n    EMC2305_HandleTypeDef * chip,\n    EMC2305_Fan fan,\n    uint8_t duty_cycle\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 to set </li> <li><code>fan</code> Fan to set (1-5) </li> <li><code>duty_cycle</code> PWM duty cycle percentage (0 to 100) </li> </ul> <p>Returns:</p> <p>OK if successful, ERR otherwise </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_setfanrpm","title":"function EMC2305_SetFanRPM","text":"<p>Sets the RPM target for the control algorithm. Works only with fan speed control (FSC) enabled. </p> <pre><code>EMC2305_Status EMC2305_SetFanRPM (\n    EMC2305_HandleTypeDef * chip,\n    EMC2305_Fan fan,\n    uint16_t rpm_target\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 to set </li> <li><code>fan</code> Fan to set (1-5) </li> <li><code>rpm_target</code> RPM target to set (500 to 16k) </li> </ul> <p>Returns:</p> <p>OK if successful, ERR otherwise </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_setglobalconfig","title":"function EMC2305_SetGlobalConfig","text":"<p>Sets the EMC2305 global configuration register based on provided config. </p> <pre><code>EMC2305_Status EMC2305_SetGlobalConfig (\n    EMC2305_HandleTypeDef * chip,\n    EMC2305_Global_Config * config\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 to configure </li> <li><code>config</code> Global configuration to use </li> </ul> <p>Returns:</p> <p>OK if successful, ERR otherwise </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_setpwmbasefrequency","title":"function EMC2305_SetPWMBaseFrequency","text":"<p>Sets the base frequency of the specified fan's PWM driver. </p> <pre><code>EMC2305_Status EMC2305_SetPWMBaseFrequency (\n    EMC2305_HandleTypeDef * chip,\n    EMC2305_Fan fan,\n    EMC2305_PWM_BaseFreq freq\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 to set </li> <li><code>fan</code> Fan to set (1-5) </li> <li><code>freq</code> Base frequency as specified in Section 6.10 </li> </ul> <p>Returns:</p> <p>OK if successful, ERR otherwise </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_setpwmoutputmode","title":"function EMC2305_SetPWMOutputMode","text":"<p>Sets the specified fan's PWM driver to open-drain or push-pull. </p> <pre><code>EMC2305_Status EMC2305_SetPWMOutputMode (\n    EMC2305_HandleTypeDef * chip,\n    EMC2305_Fan fan,\n    bool open_drain\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 to set </li> <li><code>fan</code> Fan to set (1-5) </li> <li><code>open_drain</code> Set to true for open-drain (only driven low, requires pullup) or false for push-pull (driven high and low, no pullup) </li> </ul> <p>Returns:</p> <p>OK if successful, ERR otherwise </p>"},{"location":"Drivers/EMC2305_8h/#function-emc2305_writereg","title":"function EMC2305_WriteReg","text":"<p>Writes a byte of data to the specified register. </p> <pre><code>EMC2305_Status EMC2305_WriteReg (\n    EMC2305_HandleTypeDef * chip,\n    uint8_t reg,\n    uint8_t data\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>chip</code> EMC2305 handle </li> <li><code>reg</code> Register to write to </li> <li><code>data</code> Data to write </li> </ul> <p>Returns:</p> <p>OK if successful, ERR if message queue is full </p>"},{"location":"Drivers/EMC2305_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Drivers/EMC2305_8h/#define-emc2305_cfg_dis_to","title":"define EMC2305_CFG_DIS_TO","text":"<pre><code>#define EMC2305_CFG_DIS_TO `(1u &lt;&lt; 6)  /* DIS_TO - SMBus timeout disable (I2C compat) */`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_cfg_dreck","title":"define EMC2305_CFG_DRECK","text":"<pre><code>#define EMC2305_CFG_DRECK `(1u &lt;&lt; 1)  /* DRECK - CLK pin drives internal clock when set (output) */`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_cfg_mask_alert","title":"define EMC2305_CFG_MASK_ALERT","text":"<pre><code>#define EMC2305_CFG_MASK_ALERT `(1u &lt;&lt; 7)  /* MASK - mask ALERT pin when set */`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_cfg_useck","title":"define EMC2305_CFG_USECK","text":"<pre><code>#define EMC2305_CFG_USECK `(1u &lt;&lt; 0)  /* USECK - use external CLK pin as tach clock when set */`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_cfg_wd_en","title":"define EMC2305_CFG_WD_EN","text":"<pre><code>#define EMC2305_CFG_WD_EN `(1u &lt;&lt; 5)  /* WD_EN - enable watchdog continuous mode */`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_config1_edg_shift","title":"define EMC2305_CONFIG1_EDG_SHIFT","text":"<pre><code>#define EMC2305_CONFIG1_EDG_SHIFT `3u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_config1_enag_shift","title":"define EMC2305_CONFIG1_ENAG_SHIFT","text":"<pre><code>#define EMC2305_CONFIG1_ENAG_SHIFT `7u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_config1_rng_shift","title":"define EMC2305_CONFIG1_RNG_SHIFT","text":"<pre><code>#define EMC2305_CONFIG1_RNG_SHIFT `5u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_config1_udt_shift","title":"define EMC2305_CONFIG1_UDT_SHIFT","text":"<pre><code>#define EMC2305_CONFIG1_UDT_SHIFT `0u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_config2_dpt_shift","title":"define EMC2305_CONFIG2_DPT_SHIFT","text":"<pre><code>#define EMC2305_CONFIG2_DPT_SHIFT `3u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_config2_enrc_shift","title":"define EMC2305_CONFIG2_ENRC_SHIFT","text":"<pre><code>#define EMC2305_CONFIG2_ENRC_SHIFT `6u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_config2_erg_shift","title":"define EMC2305_CONFIG2_ERG_SHIFT","text":"<pre><code>#define EMC2305_CONFIG2_ERG_SHIFT `1u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_config2_ghen_shift","title":"define EMC2305_CONFIG2_GHEN_SHIFT","text":"<pre><code>#define EMC2305_CONFIG2_GHEN_SHIFT `5u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_fan1_mask","title":"define EMC2305_FAN1_MASK","text":"<pre><code>#define EMC2305_FAN1_MASK `(1u &lt;&lt; 0)`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_fan2_mask","title":"define EMC2305_FAN2_MASK","text":"<pre><code>#define EMC2305_FAN2_MASK `(1u &lt;&lt; 1)`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_fan3_mask","title":"define EMC2305_FAN3_MASK","text":"<pre><code>#define EMC2305_FAN3_MASK `(1u &lt;&lt; 2)`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_fan4_mask","title":"define EMC2305_FAN4_MASK","text":"<pre><code>#define EMC2305_FAN4_MASK `(1u &lt;&lt; 3)`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_fan5_mask","title":"define EMC2305_FAN5_MASK","text":"<pre><code>#define EMC2305_FAN5_MASK `(1u &lt;&lt; 4)`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_fan_address_offset","title":"define EMC2305_FAN_ADDRESS_OFFSET","text":"<pre><code>#define EMC2305_FAN_ADDRESS_OFFSET `0x10u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_fan_reg_addr","title":"define EMC2305_FAN_REG_ADDR","text":"<p>Calculates the register address for a specific fan (N) based on the Fan 1 register address and known offset. </p> <pre><code>#define EMC2305_FAN_REG_ADDR (\n    fan_num,\n    fan1_reg_addr\n) `((fan1_reg_addr) + ((fan_num) * EMC2305_FAN_ADDRESS_OFFSET ))`\n</code></pre> <p>Parameters:</p> <ul> <li><code>fan_num</code> The fan number (0-4 to match fan enum). </li> <li><code>fan1_reg_addr</code> The address of the corresponding Fan 1 register (base) </li> </ul> <p>Returns:</p> <p>The calculated register address for Fan N. </p>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_i2c_timeout","title":"define EMC2305_I2C_TIMEOUT","text":"<pre><code>#define EMC2305_I2C_TIMEOUT `100u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_invalid_fan","title":"define EMC2305_INVALID_FAN","text":"<pre><code>#define EMC2305_INVALID_FAN (\n    fan_num\n) `(fan &lt; EMC2305_FAN1 || fan &gt; EMC2305_FAN5 )`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_max_rpm","title":"define EMC2305_MAX_RPM","text":"<pre><code>#define EMC2305_MAX_RPM `16000`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_min_rpm","title":"define EMC2305_MIN_RPM","text":"<pre><code>#define EMC2305_MIN_RPM `500`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_pwm_fan1_mask","title":"define EMC2305_PWM_FAN1_MASK","text":"<pre><code>#define EMC2305_PWM_FAN1_MASK `0x03u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_pwm_fan1_shift","title":"define EMC2305_PWM_FAN1_SHIFT","text":"<pre><code>#define EMC2305_PWM_FAN1_SHIFT `0u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_pwm_fan2_mask","title":"define EMC2305_PWM_FAN2_MASK","text":"<pre><code>#define EMC2305_PWM_FAN2_MASK `0x0Cu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_pwm_fan2_shift","title":"define EMC2305_PWM_FAN2_SHIFT","text":"<pre><code>#define EMC2305_PWM_FAN2_SHIFT `2u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_pwm_fan3_mask","title":"define EMC2305_PWM_FAN3_MASK","text":"<pre><code>#define EMC2305_PWM_FAN3_MASK `0x30u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_pwm_fan3_shift","title":"define EMC2305_PWM_FAN3_SHIFT","text":"<pre><code>#define EMC2305_PWM_FAN3_SHIFT `4u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_pwm_fan4_mask","title":"define EMC2305_PWM_FAN4_MASK","text":"<pre><code>#define EMC2305_PWM_FAN4_MASK `0x03u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_pwm_fan4_shift","title":"define EMC2305_PWM_FAN4_SHIFT","text":"<pre><code>#define EMC2305_PWM_FAN4_SHIFT `0u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_pwm_fan5_mask","title":"define EMC2305_PWM_FAN5_MASK","text":"<pre><code>#define EMC2305_PWM_FAN5_MASK `0x0Cu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_pwm_fan5_shift","title":"define EMC2305_PWM_FAN5_SHIFT","text":"<pre><code>#define EMC2305_PWM_FAN5_SHIFT `2u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_queue_item_size","title":"define EMC2305_QUEUE_ITEM_SIZE","text":"<pre><code>#define EMC2305_QUEUE_ITEM_SIZE `sizeof( EMC2305_I2C_Message )`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_queue_length","title":"define EMC2305_QUEUE_LENGTH","text":"<pre><code>#define EMC2305_QUEUE_LENGTH `10`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_configuration","title":"define EMC2305_REG_CONFIGURATION","text":"<pre><code>#define EMC2305_REG_CONFIGURATION `0x20u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_drive_fail_status","title":"define EMC2305_REG_DRIVE_FAIL_STATUS","text":"<pre><code>#define EMC2305_REG_DRIVE_FAIL_STATUS `0x27u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_config1","title":"define EMC2305_REG_FAN1_CONFIG1","text":"<pre><code>#define EMC2305_REG_FAN1_CONFIG1 `0x32u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_config2","title":"define EMC2305_REG_FAN1_CONFIG2","text":"<pre><code>#define EMC2305_REG_FAN1_CONFIG2 `0x33u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_drvfail_h","title":"define EMC2305_REG_FAN1_DRVFAIL_H","text":"<pre><code>#define EMC2305_REG_FAN1_DRVFAIL_H `0x3Bu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_drvfail_l","title":"define EMC2305_REG_FAN1_DRVFAIL_L","text":"<pre><code>#define EMC2305_REG_FAN1_DRVFAIL_L `0x3Au`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_max_step","title":"define EMC2305_REG_FAN1_MAX_STEP","text":"<pre><code>#define EMC2305_REG_FAN1_MAX_STEP `0x37u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_min_drive","title":"define EMC2305_REG_FAN1_MIN_DRIVE","text":"<pre><code>#define EMC2305_REG_FAN1_MIN_DRIVE `0x38u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_setting","title":"define EMC2305_REG_FAN1_SETTING","text":"<pre><code>#define EMC2305_REG_FAN1_SETTING `0x30u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_spin","title":"define EMC2305_REG_FAN1_SPIN","text":"<pre><code>#define EMC2305_REG_FAN1_SPIN `0x36u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_tach_reading_h","title":"define EMC2305_REG_FAN1_TACH_READING_H","text":"<pre><code>#define EMC2305_REG_FAN1_TACH_READING_H `0x3Eu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_tach_reading_l","title":"define EMC2305_REG_FAN1_TACH_READING_L","text":"<pre><code>#define EMC2305_REG_FAN1_TACH_READING_L `0x3Fu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_tach_target_h","title":"define EMC2305_REG_FAN1_TACH_TARGET_H","text":"<pre><code>#define EMC2305_REG_FAN1_TACH_TARGET_H `0x3Du`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_tach_target_l","title":"define EMC2305_REG_FAN1_TACH_TARGET_L","text":"<pre><code>#define EMC2305_REG_FAN1_TACH_TARGET_L `0x3Cu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan1_valid_tach","title":"define EMC2305_REG_FAN1_VALID_TACH","text":"<pre><code>#define EMC2305_REG_FAN1_VALID_TACH `0x39u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan_interrupt_enable","title":"define EMC2305_REG_FAN_INTERRUPT_ENABLE","text":"<pre><code>#define EMC2305_REG_FAN_INTERRUPT_ENABLE `0x29u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan_spin_status","title":"define EMC2305_REG_FAN_SPIN_STATUS","text":"<pre><code>#define EMC2305_REG_FAN_SPIN_STATUS `0x26u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan_stall_status","title":"define EMC2305_REG_FAN_STALL_STATUS","text":"<pre><code>#define EMC2305_REG_FAN_STALL_STATUS `0x25u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_fan_status","title":"define EMC2305_REG_FAN_STATUS","text":"<pre><code>#define EMC2305_REG_FAN_STATUS `0x24u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_gain1","title":"define EMC2305_REG_GAIN1","text":"<pre><code>#define EMC2305_REG_GAIN1 `0x35u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_manufacturer_id","title":"define EMC2305_REG_MANUFACTURER_ID","text":"<pre><code>#define EMC2305_REG_MANUFACTURER_ID `0xFEu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_product_feat","title":"define EMC2305_REG_PRODUCT_FEAT","text":"<pre><code>#define EMC2305_REG_PRODUCT_FEAT `0xFCu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_product_id","title":"define EMC2305_REG_PRODUCT_ID","text":"<pre><code>#define EMC2305_REG_PRODUCT_ID `0xFDu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_pwm1_divide","title":"define EMC2305_REG_PWM1_DIVIDE","text":"<pre><code>#define EMC2305_REG_PWM1_DIVIDE `0x31u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_pwm_basef123","title":"define EMC2305_REG_PWM_BASEF123","text":"<pre><code>#define EMC2305_REG_PWM_BASEF123 `0x2Du`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_pwm_basef45","title":"define EMC2305_REG_PWM_BASEF45","text":"<pre><code>#define EMC2305_REG_PWM_BASEF45 `0x2Cu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_pwm_output_config","title":"define EMC2305_REG_PWM_OUTPUT_CONFIG","text":"<pre><code>#define EMC2305_REG_PWM_OUTPUT_CONFIG `0x2Bu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_pwm_polarity","title":"define EMC2305_REG_PWM_POLARITY","text":"<pre><code>#define EMC2305_REG_PWM_POLARITY `0x2Au`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_revision","title":"define EMC2305_REG_REVISION","text":"<pre><code>#define EMC2305_REG_REVISION `0xFFu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_reg_sw_lock","title":"define EMC2305_REG_SW_LOCK","text":"<pre><code>#define EMC2305_REG_SW_LOCK `0xEFu`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_semaphore_pool_size","title":"define EMC2305_SEMAPHORE_POOL_SIZE","text":"<pre><code>#define EMC2305_SEMAPHORE_POOL_SIZE `EMC2305_QUEUE_LENGTH`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_stat_drvfail","title":"define EMC2305_STAT_DRVFAIL","text":"<pre><code>#define EMC2305_STAT_DRVFAIL `(1u &lt;&lt; 2)  /* Drive fail summary */`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_stat_fnspin","title":"define EMC2305_STAT_FNSPIN","text":"<pre><code>#define EMC2305_STAT_FNSPIN `(1u &lt;&lt; 1)  /* spin-up failure summary */`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_stat_fnstl","title":"define EMC2305_STAT_FNSTL","text":"<pre><code>#define EMC2305_STAT_FNSTL `(1u &lt;&lt; 0)  /* stall summary */`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_stat_watch","title":"define EMC2305_STAT_WATCH","text":"<pre><code>#define EMC2305_STAT_WATCH `(1u &lt;&lt; 7)  /* WATCH - watchdog fired (read-to-clear) */`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_swl","title":"define EMC2305_SWL","text":"<pre><code>#define EMC2305_SWL `(1u &lt;&lt; 0)`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_tach_mult","title":"define EMC2305_TACH_MULT","text":"<pre><code>#define EMC2305_TACH_MULT `2u`\n</code></pre>"},{"location":"Drivers/EMC2305_8h/#define-emc2305_tach_rpm_conv","title":"define EMC2305_TACH_RPM_CONV","text":"<pre><code>#define EMC2305_TACH_RPM_CONV `3932160u`\n</code></pre> <p>The documentation for this class was generated from the following file <code>driver/Inc/EMC2305.h</code></p>"},{"location":"Drivers/EMC2305_8h_source/","title":"File EMC2305.h","text":"<p>File List &gt; driver &gt; Inc &gt; EMC2305.h</p> <p>Go to the documentation of this file</p> <pre><code>// Driver for Microchip EMC2305 PWM Fan Controller\n\n#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"stm32xx_hal.h\"\n#include \"FreeRTOS.h\"\n\n// Device handle\ntypedef struct {\n    I2C_HandleTypeDef* hi2c;        // STM32 HAL I2C handle\n    uint16_t dev_addr;              // HAL convention: 7-bit address &lt;&lt; 1\n    SemaphoreHandle_t i2c_complete; // Semaphore to signal I2C transaction complete\n} EMC2305_HandleTypeDef;\n\n// I2C Response Timeout\n#ifndef EMC2305_I2C_TIMEOUT\n#define EMC2305_I2C_TIMEOUT 100u // 100ms default\n#endif\n\n// I2C Operation Types\ntypedef enum {\n    EMC2305_OP_WRITE,\n    EMC2305_OP_READ\n} EMC2305_I2C_OP;\n\n// I2C Message Struct\ntypedef struct {\n    EMC2305_HandleTypeDef* chip;    // Chip to send to\n    EMC2305_I2C_OP operation;       // Read/Write operation\n    uint8_t reg_addr;               // Register address\n    uint8_t write_data;             // Data to write (only used for write operations)\n    uint8_t* read_data;             // Pointer for storing read data (only used for read operations)\n    uint8_t semaphore_index;        // Index of semaphore handle in pool\n} EMC2305_I2C_Message;\n\n#ifndef EMC2305_QUEUE_LENGTH\n#define EMC2305_QUEUE_LENGTH 10                             // Message queue length\n#endif\n\n#define EMC2305_QUEUE_ITEM_SIZE sizeof(EMC2305_I2C_Message) // Size of queue item (message)\n#define EMC2305_SEMAPHORE_POOL_SIZE EMC2305_QUEUE_LENGTH    // Number of caller semaphores (max concurrent I2C requests)\n\n// Device status\ntypedef enum {\n    EMC2305_OK,\n    EMC2305_ERR,\n} EMC2305_Status;\n\n// Device configuration\ntypedef struct {\n    bool alert_mask;                // Blocks the alert pin from being asserted\n    bool disable_smbus_timeout;     // Disables the SMBus Time-Out function for the SMBus client (if enabled)\n    bool watchdog_enable;           // Enables the Watchdog Timer (see Section 4.11 \u201cWatchdog Timer\u201d) to operate in Continuous Mode\n    bool drive_ext_clk;             // Enables the internal tachometer clock to be driven out on the CLK pin so that multiple devices can be synced to the same source\n    bool use_ext_clk;               // Enables the device to use a clock present on the CLK pin as the tachometer clock. If the DR_EXT_CLK bit is set, then this bit is ignored and the device will use the internal oscillator.\n} EMC2305_Global_Config;\n\n// Fans\ntypedef enum {\n    EMC2305_FAN1,\n    EMC2305_FAN2,\n    EMC2305_FAN3,\n    EMC2305_FAN4,\n    EMC2305_FAN5,\n} EMC2305_Fan;\n\n// PWM Base Frequency\ntypedef enum {\n    EMC2305_PWM_2k441 = 0b11, // 2.441 kHz\n    EMC2305_PWM_4k882 = 0b10, // 4.882 kHz\n    EMC2305_PWM_19k53 = 0b01, // 19.53 kHz\n    EMC2305_PWM_26k00 = 0b00, // 26.00 kHz\n} EMC2305_PWM_BaseFreq;\n\n// Range - Sets the minimum fan speed measured and reported\ntypedef enum {\n    EMC2305_RNG_4000 = 0b11, // 4000 RPM minimum, TACH count multiplier = 8\n    EMC2305_RNG_2000 = 0b10, // 2000 RPM minimum, TACH count multiplier = 4\n    EMC2305_RNG_1000 = 0b01, // 1000 RPM minimum, TACH count multiplier = 2\n    EMC2305_RNG_500 = 0b00,  // 500 RPM minimum, TACH count multiplier = 1\n} EMC2305_RNG;\n\n// Edges - Sets the number of edges to sample when calculating RPM\ntypedef enum {\n    EMC2305_EDG_9 = 0b11, // 9 edges sampled (4 poles) - effective Tach multiplier is 2, based on two pole fans\n    EMC2305_EDG_7 = 0b10, // 7 edges sampled (3 poles) - effective Tach multiplier is 1.5, based on two pole fans\n    EMC2305_EDG_5 = 0b01, // 5 edges sampled (2 poles) - effective Tach multiplier is 1, based on two pole fans\n    EMC2305_EDG_3 = 0b00, // 3 edges sampled (1 pole) - effective Tach multiplier is 0.5, based on two pole fans\n} EMC2305_EDG;\n\n// Update Time - Sets the PID update rate for closed loop control\ntypedef enum {\n    EMC2305_UDT_100 = 0b000,  // 100 ms update interval\n    EMC2305_UDT_200 = 0b001,  // 200 ms update interval\n    EMC2305_UDT_300 = 0b010,  // 300 ms update interval\n    EMC2305_UDT_400 = 0b011,  // 400 ms update interval\n    EMC2305_UDT_500 = 0b100,  // 500 ms update interval\n    EMC2305_UDT_800 = 0b101,  // 800 ms update interval\n    EMC2305_UDT_1200 = 0b110,  // 1200 ms update interval\n    EMC2305_UDT_1600 = 0b111,  // 1600 ms update interval\n} EMC2305_UDT;\n\n// Fan Configuration 1\ntypedef struct {\n    bool enable_closed_loop;\n    EMC2305_RNG range;\n    EMC2305_EDG edges;\n    EMC2305_UDT update_time;\n} EMC2305_Fan_Config1;\n\n// Derivative Options - Selects form of derivative used in PID\ntypedef enum {\n    EMC2305_DPT_NONE = 0b00,  // No derivative term\n    EMC2305_DPT_BASIC = 0b01, // Basic derivative\n    EMC2305_DPT_STEP = 0b10,  // Step derivative\n    EMC2305_DPT_BOTH = 0b11,  // Both basic + step\n} EMC2305_DPT;\n\n// Error Window - Acceptable RPM deviation around target\ntypedef enum {\n    EMC2305_ERG_0RPM = 0b00,   // 0 RPM window\n    EMC2305_ERG_50RPM = 0b01,  // \u00b150 RPM\n    EMC2305_ERG_100RPM = 0b10, // \u00b1100 RPM\n    EMC2305_ERG_200RPM = 0b11, // \u00b1200 RPM\n} EMC2305_ERG;\n\n// Fan Configuration 2\ntypedef struct {\n    bool enable_ramp_rate_ctl;\n    bool enable_glitch_filter;\n    EMC2305_DPT derivative_options;\n    EMC2305_ERG error_window;\n} EMC2305_Fan_Config2;\n\ntypedef enum {\n    EMC2305_PID_8X = 0b11, // 8x gain\n    EMC2305_PID_4X = 0b10, // 4x gain\n    EMC2305_PID_2X = 0b01, // 2x gain\n    EMC2305_PID_1X = 0b00, // 1x gain\n} EMC2305_PID_Gain;\n\ntypedef struct {\n    bool watchdog_fired; // Indicates that the Watchdog Timer has expired. When this bit is set, each fan is driven to 100% duty cycle and will remain at 100% duty cycle until they are programmed. This bit is cleared when it is read.\n    bool drive_failed;   // Indicates that one or more fan drivers cannot meet the programmed fan speed at maximum PWM duty cycle.\n    bool spin_failed;    // Indicates that one or more fan drivers cannot spin up.\n    bool stalled;        // Indicates that one or more fan drivers have stalled.\n} EMC2305_Fan_Status;\n\n// Register map from EMC2305 datasheet\n// https://ww1.microchip.com/downloads/aemDocuments/documents/MSLD/ProductDocuments/DataSheets/EMC2301-2-3-5-Data-Sheet-DS20006532A.pdf\n\n// Device Configuration\n#define EMC2305_REG_CONFIGURATION           0x20u // The Configuration register controls the basic functionality of the EMC2301/2/3/5. The Configuration Register is software locked.\n#define EMC2305_REG_FAN_INTERRUPT_ENABLE    0x29u // The Fan Interrupt Enable register controls the masking for each fan channel. When a channel is enabled, it will cause the ALERT pin to be asserted when an Error condition is detected. \u2022 \u20181\u2019 - An Error condition (Stall, Spin Up, Drive Fail) on fan X will cause the ALERT pin to be asserted. \u2022 \u20180\u2019 (default) - An Error condition on fan X will not cause the ALERT pin to be asserted; however, the status registers will be updated normally.\n#define EMC2305_REG_PWM_POLARITY            0x2Au // The PWM Polarity Configuration registers control the output type and polarity of all PWM outputs.\n#define EMC2305_REG_PWM_OUTPUT_CONFIG       0x2Bu // The PWM Output Configuration register controls the PWM output type as push-pull or open drain.\n#define EMC2305_REG_PWM_BASEF45             0x2Cu // The PWM BASEF45 Register controls the base frequency of PWM drivers 4 and 5.\n#define EMC2305_REG_PWM_BASEF123            0x2Du // The PWM BaseF123 Register controls the base frequency of PWM drivers 1, 2 and 3.\n#define EMC2305_REG_SW_LOCK                 0xEFu // Software Lock Register - bit 0 LOCK Enables the SWL function: 1 = All SWL registers are locked and read-only. Unlock occurs on power cycle. 0 = All SWL registers are writable.\n#define EMC2305_REG_PRODUCT_FEAT            0xFCu // Product Features Register - bit 5-3: ADR[2:0]: SMBus address determined by the ADDR_SEL pin decode. bit 2-0:  FSP[2:0]: Default Fan Speed determined by the CLK pin decode. This is conditional on ADDR_SEL.\n#define EMC2305_REG_PRODUCT_ID              0xFDu // Production Identification Register - bit 1-0: PID[1:0]: Product Identification Register. Device defines bit pattern. 00 for EMC2305\n#define EMC2305_REG_MANUFACTURER_ID         0xFEu // Manufacturer Identification Register - Hard coded fixed value of 0x5D\n#define EMC2305_REG_REVISION                0xFFu // Silicon Revision Register - Hard coded fixed value of 0x80\n\n// Device Status\n#define EMC2305_REG_FAN_STATUS              0x24u // The Fan Status register indicates that the fan driver has stalled or failed or that the Watchdog Timer has expired (see Section 4.11 \u201cWatchdog Timer\u201d).\n#define EMC2305_REG_FAN_STALL_STATUS        0x25u // The Fan Stall Status register indicates which fan driver has detected a stalled condition (see Section 4.4.3 \u201cStalled Fan\u201d). All bits are cleared upon a read if the Error condition has been removed.\n#define EMC2305_REG_FAN_SPIN_STATUS         0x26u // The Fan Spin Status register indicates which fan driver has failed to spin-up (see Section 4.8 \u201cSpin Up Rou tine\u201d). All bits are cleared upon a read if the Error condition has been removed.\n#define EMC2305_REG_DRIVE_FAIL_STATUS       0x27u // The Fan Drive Fail Status register indicates which fan driver cannot drive to the programmed speed even at 100% duty cycle (see Section 4.4.4 \u201cAging Fan or Invalid Drive Detection\u201d and Register 6-16). All bits are cleared upon a read if the Error condition has been removed.\n\n// Fan 1 Registers (base registers for all fans)\n#define EMC2305_REG_FAN1_SETTING            0x30u // Fan 1 Drive Setting Register - The Fan Drive Setting register always displays the current setting of the respective fan driver\n#define EMC2305_REG_PWM1_DIVIDE             0x31u // Fan 1 PWM Divide Register - The PWM Divide registers determine the final frequency of the respective PWM Fan Driver. Each driver base frequency is divided by the value of the respective PWM Divide Register to determine the final frequency.\n#define EMC2305_REG_FAN1_CONFIG1            0x32u // Fan 1 Configuration Register 1 - The Fan Configuration 1 registers control the general operation of the RPM-based Fan Speed Control algorithm used for the respective Fan Driver (see Section 4.3 \u201cRPM-Based Fan Speed Control Algorithm\u201d).\n#define EMC2305_REG_FAN1_CONFIG2            0x33u // Fan 1 Configuration Register 2 - The Fan Configuration 2 registers control the tachometer measurement and advanced features of the RPM based Fan Speed Control algorithm (see Section 4.3 \u201cRPM-Based Fan Speed Control Algorithm\u201d)\n#define EMC2305_REG_GAIN1                   0x35u // Fan 1 PID Gain Register - See Section 4.3.3.2 \u201cSetting the PID Gains\u201d.\n#define EMC2305_REG_FAN1_SPIN               0x36u // Fan 1 Spin Up Configuration Registers - The Fan Spin Up Configuration registers control the settings of the Spin Up Routine. These registers are software locked (see Section 4.8 \u201cSpin Up Routine\u201d)\n#define EMC2305_REG_FAN1_MAX_STEP           0x37u // Fan 1 Maximum Step Size Register - This register determines the maximum step size for the ramp rate control (see Section 4.3.3.3 \u201cFan Drive Max Step\u201d and Section 4.10 \u201cRamp Rate Control\u201d).\n#define EMC2305_REG_FAN1_MIN_DRIVE          0x38u // Fan 1 Minimum Drive Register - The Fan Minimum Drive Register (see Section 4.3.3.4 \u201cMinimum Drive Setting\u201d) stores the minimum drive setting for each RPM-based Fan Speed Control algorithm.\n#define EMC2305_REG_FAN1_VALID_TACH         0x39u // Fan 1 Valid TACH Count Register - The Valid TACH Count registers store the maximum TACH Reading register value to indicate that each fan is spinning properly (see Section 4.4.2 \u201cValid Tachometer Readings\u201d). \n#define EMC2305_REG_FAN1_DRVFAIL_L          0x3Au // Fan 1 Drive Fail Band Low Byte Register - The Drive Fail Band registers store the number of tach counts used by the Fan Drive Fail detection circuitry.\n#define EMC2305_REG_FAN1_DRVFAIL_H          0x3Bu // Fan 1 Drive Fail Band High Byte Register - The Drive Fail Band registers store the number of tach counts used by the Fan Drive Fail detection circuitry.\n#define EMC2305_REG_FAN1_TACH_TARGET_L      0x3Cu // Fan 1 Tachometer Closed Loop Target Low Byte Register - The TACH Target Registers hold the target tachometer value that is maintained by the RPM-based Fan Speed Control algorithm.\n#define EMC2305_REG_FAN1_TACH_TARGET_H      0x3Du // Fan 1 Tachometer Closed Loop Target High Byte Register - The TACH Target Registers hold the target tachometer value that is maintained by the RPM-based Fan Speed Control algorithm.\n#define EMC2305_REG_FAN1_TACH_READING_H     0x3Eu // Fan 1 Tachometer Reading High Byte Register - The TACH Reading Registers describe the current tachometer reading for each of the fans (see Section 4.4 \u201cTachometer Measurement\u201d). \n#define EMC2305_REG_FAN1_TACH_READING_L     0x3Fu // Fan 1 Tachometer Reading Low Byte Register - The TACH Reading Registers describe the current tachometer reading for each of the fans (see Section 4.4 \u201cTachometer Measurement\u201d). \n\n// Address offset per fan register block\n#define EMC2305_FAN_ADDRESS_OFFSET         0x10u\n\n#define EMC2305_FAN_REG_ADDR(fan_num, fan1_reg_addr) ((fan1_reg_addr) + ((fan_num) * EMC2305_FAN_ADDRESS_OFFSET))\n\n // Bitmasks\n // Config (0x20) bits\n#define EMC2305_CFG_MASK_ALERT              (1u &lt;&lt; 7)  /* MASK - mask ALERT pin when set */\n#define EMC2305_CFG_DIS_TO                  (1u &lt;&lt; 6)  /* DIS_TO - SMBus timeout disable (I2C compat) */\n#define EMC2305_CFG_WD_EN                   (1u &lt;&lt; 5)  /* WD_EN - enable watchdog continuous mode */\n#define EMC2305_CFG_DRECK                   (1u &lt;&lt; 1)  /* DRECK - CLK pin drives internal clock when set (output) */\n#define EMC2305_CFG_USECK                   (1u &lt;&lt; 0)  /* USECK - use external CLK pin as tach clock when set */\n\n// Fan Status (0x24) bits\n#define EMC2305_STAT_WATCH                  (1u &lt;&lt; 7)  /* WATCH - watchdog fired (read-to-clear) */\n#define EMC2305_STAT_DRVFAIL                (1u &lt;&lt; 2)  /* Drive fail summary */\n#define EMC2305_STAT_FNSPIN                 (1u &lt;&lt; 1)  /* spin-up failure summary */\n#define EMC2305_STAT_FNSTL                  (1u &lt;&lt; 0)  /* stall summary */\n\n// Bitmasks for Fan 1-5\n#define EMC2305_FAN1_MASK                   (1u &lt;&lt; 0)\n#define EMC2305_FAN2_MASK                   (1u &lt;&lt; 1)\n#define EMC2305_FAN3_MASK                   (1u &lt;&lt; 2)\n#define EMC2305_FAN4_MASK                   (1u &lt;&lt; 3)\n#define EMC2305_FAN5_MASK                   (1u &lt;&lt; 4)\n\n// Software Lock (0xEF)\n#define EMC2305_SWL                         (1u &lt;&lt; 0)\n\n// Bit masks for PWM Base Freq\n#define EMC2305_PWM_FAN1_MASK               0x03u\n#define EMC2305_PWM_FAN2_MASK               0x0Cu\n#define EMC2305_PWM_FAN3_MASK               0x30u\n#define EMC2305_PWM_FAN4_MASK               0x03u\n#define EMC2305_PWM_FAN5_MASK               0x0Cu\n\n// Bit shifts for PWM Base Freq\n#define EMC2305_PWM_FAN1_SHIFT              0u\n#define EMC2305_PWM_FAN2_SHIFT              2u\n#define EMC2305_PWM_FAN3_SHIFT              4u\n#define EMC2305_PWM_FAN4_SHIFT              0u\n#define EMC2305_PWM_FAN5_SHIFT              2u\n\n// Bit shifts for fan configuration 1 register\n#define EMC2305_CONFIG1_ENAG_SHIFT          7u\n#define EMC2305_CONFIG1_RNG_SHIFT           5u\n#define EMC2305_CONFIG1_EDG_SHIFT           3u\n#define EMC2305_CONFIG1_UDT_SHIFT           0u\n\n// Bit shifts for fan configuration 2 register\n#define EMC2305_CONFIG2_ENRC_SHIFT          6u\n#define EMC2305_CONFIG2_GHEN_SHIFT          5u\n#define EMC2305_CONFIG2_DPT_SHIFT           3u\n#define EMC2305_CONFIG2_ERG_SHIFT           1u\n\n// Conversion from RPM to tach counts (Equation 2 in SMSC AN 17.4)\n#define EMC2305_TACH_RPM_CONV               3932160u\n#define EMC2305_TACH_MULT                   2u\n\n// Minimum RPM to set\n#define EMC2305_MIN_RPM                     500\n// Maximum RPM to set\n#define EMC2305_MAX_RPM                     16000\n\n#define EMC2305_INVALID_FAN(fan_num) (fan &lt; EMC2305_FAN1 || fan &gt; EMC2305_FAN5)\n\n// Device Management Functions\n\nEMC2305_Status EMC2305_Init(EMC2305_HandleTypeDef* chip, I2C_HandleTypeDef* hi2c, uint16_t dev_addr);\n\nEMC2305_Status EMC2305_EnableSWLock(EMC2305_HandleTypeDef* chip);\n\nEMC2305_Status EMC2305_SetGlobalConfig(EMC2305_HandleTypeDef* chip, EMC2305_Global_Config* config);\n\n// Fan Configuration Functions\n\nEMC2305_Status EMC2305_SetPWMBaseFrequency(EMC2305_HandleTypeDef* chip, EMC2305_Fan fan, EMC2305_PWM_BaseFreq freq);\n\nEMC2305_Status EMC2305_SetFanConfig(EMC2305_HandleTypeDef* chip, EMC2305_Fan fan, EMC2305_Fan_Config1* config1, EMC2305_Fan_Config2* config2);\n\nEMC2305_Status EMC2305_SetPWMOutputMode(EMC2305_HandleTypeDef* chip, EMC2305_Fan fan, bool open_drain);\n\n// Fan Control Functions\n\nEMC2305_Status EMC2305_SetFanPWM(EMC2305_HandleTypeDef* chip, EMC2305_Fan fan, uint8_t duty_cycle);\n\nEMC2305_Status EMC2305_SetFanRPM(EMC2305_HandleTypeDef* chip, EMC2305_Fan fan, uint16_t rpm_target);\n\n// Status &amp; Measurement Functions\n\nuint16_t EMC2305_GetFanRPM(EMC2305_HandleTypeDef* chip, EMC2305_Fan fan);\n\nuint8_t EMC2305_GetFanPWM(EMC2305_HandleTypeDef* chip, EMC2305_Fan fan);\n\nEMC2305_Fan_Status EMC2305_GetFanStatus(EMC2305_HandleTypeDef* chip);\n\n// Register Read/Write Functions\n\nEMC2305_Status EMC2305_ReadReg(EMC2305_HandleTypeDef* chip, uint8_t reg, uint8_t* data);\n\nEMC2305_Status EMC2305_WriteReg(EMC2305_HandleTypeDef* chip, uint8_t reg, uint8_t data);\n\n// Worker task to consume messages from the queue and send on I2C bus\nvoid EMC2305_I2C_Worker_Task(void* pvParameters);\n\n// I2C Transmit Interrupt Callback (Internal)\nvoid EMC2305_I2C_MasterTxCpltCallback(I2C_HandleTypeDef* hi2c);\n\n// I2C Receive Interrupt Callback (Internal)\nvoid EMC2305_I2C_MasterRxCpltCallback(I2C_HandleTypeDef* hi2c);\n</code></pre>"},{"location":"Drivers/SevenSegment_8h/","title":"File SevenSegment.h","text":"<p>FileList &gt; driver &gt; Inc &gt; SevenSegment.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"stm32xx_hal.h\"</code></li> </ul>"},{"location":"Drivers/SevenSegment_8h/#classes","title":"Classes","text":"Type Name struct led_pins"},{"location":"Drivers/SevenSegment_8h/#public-types","title":"Public Types","text":"Type Name enum display typedef enum display display_t typedef struct led_pins led_t"},{"location":"Drivers/SevenSegment_8h/#public-functions","title":"Public Functions","text":"Type Name void SevenSegment_Init ()  uint8_t displayNum_SevenSegment (display_t display, uint8_t number)  uint8_t displayTwoNum_SevenSegment (uint8_t number)  void off_SevenSegment (uint8_t display)"},{"location":"Drivers/SevenSegment_8h/#macros","title":"Macros","text":"Type Name define MAX_NUM <code>99</code> define NUMBER_SEGMENTS <code>7</code> define NUMBER_SEVEN_SEGMENTS <code>2</code>"},{"location":"Drivers/SevenSegment_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Drivers/SevenSegment_8h/#enum-display","title":"enum display","text":"<pre><code>enum display {\n    display_0 = 0,\n    display_1 = 1,\n    display_off = 2\n};\n</code></pre>"},{"location":"Drivers/SevenSegment_8h/#typedef-display_t","title":"typedef display_t","text":"<pre><code>typedef enum display display_t;\n</code></pre>"},{"location":"Drivers/SevenSegment_8h/#typedef-led_t","title":"typedef led_t","text":"<pre><code>typedef struct led_pins led_t;\n</code></pre>"},{"location":"Drivers/SevenSegment_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Drivers/SevenSegment_8h/#function-sevensegment_init","title":"function SevenSegment_Init","text":"<pre><code>void SevenSegment_Init () \n</code></pre>"},{"location":"Drivers/SevenSegment_8h/#function-displaynum_sevensegment","title":"function displayNum_SevenSegment","text":"<pre><code>uint8_t displayNum_SevenSegment (\n    display_t display,\n    uint8_t number\n) \n</code></pre>"},{"location":"Drivers/SevenSegment_8h/#function-displaytwonum_sevensegment","title":"function displayTwoNum_SevenSegment","text":"<pre><code>uint8_t displayTwoNum_SevenSegment (\n    uint8_t number\n) \n</code></pre>"},{"location":"Drivers/SevenSegment_8h/#function-off_sevensegment","title":"function off_SevenSegment","text":"<pre><code>void off_SevenSegment (\n    uint8_t display\n) \n</code></pre>"},{"location":"Drivers/SevenSegment_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Drivers/SevenSegment_8h/#define-max_num","title":"define MAX_NUM","text":"<pre><code>#define MAX_NUM `99`\n</code></pre>"},{"location":"Drivers/SevenSegment_8h/#define-number_segments","title":"define NUMBER_SEGMENTS","text":"<pre><code>#define NUMBER_SEGMENTS `7`\n</code></pre>"},{"location":"Drivers/SevenSegment_8h/#define-number_seven_segments","title":"define NUMBER_SEVEN_SEGMENTS","text":"<pre><code>#define NUMBER_SEVEN_SEGMENTS `2`\n</code></pre> <p>The documentation for this class was generated from the following file <code>driver/Inc/SevenSegment.h</code></p>"},{"location":"Drivers/SevenSegment_8h_source/","title":"File SevenSegment.h","text":"<p>File List &gt; driver &gt; Inc &gt; SevenSegment.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef SEVENSEGMENTHEADER_H  \n#define SEVENSEGMENTHEADER_H  \n\n#include \"stm32xx_hal.h\"\n\n#define NUMBER_SEVEN_SEGMENTS 2\n#define NUMBER_SEGMENTS 7\n#define MAX_NUM 99\n\nstruct led_pins { \n   uint32_t Pin;\n   GPIO_TypeDef *Port;\n}; \n\nenum display {\n   display_0 = 0,\n   display_1 = 1,\n   display_off = 2\n}; \n\ntypedef struct led_pins led_t;\ntypedef enum display display_t;\n\n\n//Initializes the LEDs for the Seven Segment LED.\nvoid SevenSegment_Init();\n\n\n/*Displays a number on the Seven Segment LEDs. Display refers to display_0 or display_1 \n and number is the number 0-99 that the LEDs will display. \n If the number is larger than 10, display input does not matter since it will use both displays. \n Returns 1 for success and 0 for failure.*/\nuint8_t displayNum_SevenSegment(display_t display, uint8_t number);\n\n//Displays a 2 number input and returns 0 for failure and 1 for success\nuint8_t displayTwoNum_SevenSegment(uint8_t number);\n\n/* This function turns off the LEDs in one or both displays. \nInput is display_0, display_1, or display_off */\nvoid off_SevenSegment(uint8_t display);\n\n#endif // SEVEN_SEGMENT_H\n</code></pre>"},{"location":"Drivers/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct EMC2305_Fan_Config1 </li> <li>struct EMC2305_Fan_Config2 </li> <li>struct EMC2305_Fan_Status </li> <li>struct EMC2305_Global_Config </li> <li>struct EMC2305_HandleTypeDef </li> <li>struct EMC2305_I2C_Message </li> <li>struct led_pins </li> </ul>"},{"location":"Drivers/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Drivers/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"Drivers/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Drivers/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Drivers/class_member_variables/#a","title":"a","text":"<ul> <li>alert_mask (EMC2305_Global_Config)</li> </ul>"},{"location":"Drivers/class_member_variables/#c","title":"c","text":"<ul> <li>chip (EMC2305_I2C_Message)</li> </ul>"},{"location":"Drivers/class_member_variables/#d","title":"d","text":"<ul> <li>derivative_options (EMC2305_Fan_Config2)</li> <li>drive_failed (EMC2305_Fan_Status)</li> <li>disable_smbus_timeout (EMC2305_Global_Config)</li> <li>drive_ext_clk (EMC2305_Global_Config)</li> <li>dev_addr (EMC2305_HandleTypeDef)</li> </ul>"},{"location":"Drivers/class_member_variables/#e","title":"e","text":"<ul> <li>edges (EMC2305_Fan_Config1)</li> <li>enable_closed_loop (EMC2305_Fan_Config1)</li> <li>enable_glitch_filter (EMC2305_Fan_Config2)</li> <li>enable_ramp_rate_ctl (EMC2305_Fan_Config2)</li> <li>error_window (EMC2305_Fan_Config2)</li> </ul>"},{"location":"Drivers/class_member_variables/#h","title":"h","text":"<ul> <li>hi2c (EMC2305_HandleTypeDef)</li> </ul>"},{"location":"Drivers/class_member_variables/#i","title":"i","text":"<ul> <li>i2c_complete (EMC2305_HandleTypeDef)</li> </ul>"},{"location":"Drivers/class_member_variables/#o","title":"o","text":"<ul> <li>operation (EMC2305_I2C_Message)</li> </ul>"},{"location":"Drivers/class_member_variables/#p","title":"p","text":"<ul> <li>Pin (led_pins)</li> <li>Port (led_pins)</li> </ul>"},{"location":"Drivers/class_member_variables/#r","title":"r","text":"<ul> <li>range (EMC2305_Fan_Config1)</li> <li>read_data (EMC2305_I2C_Message)</li> <li>reg_addr (EMC2305_I2C_Message)</li> </ul>"},{"location":"Drivers/class_member_variables/#s","title":"s","text":"<ul> <li>spin_failed (EMC2305_Fan_Status)</li> <li>stalled (EMC2305_Fan_Status)</li> <li>semaphore_index (EMC2305_I2C_Message)</li> </ul>"},{"location":"Drivers/class_member_variables/#u","title":"u","text":"<ul> <li>update_time (EMC2305_Fan_Config1)</li> <li>use_ext_clk (EMC2305_Global_Config)</li> </ul>"},{"location":"Drivers/class_member_variables/#w","title":"w","text":"<ul> <li>watchdog_fired (EMC2305_Fan_Status)</li> <li>watchdog_enable (EMC2305_Global_Config)</li> <li>write_data (EMC2305_I2C_Message)</li> </ul>"},{"location":"Drivers/class_members/","title":"Class Members","text":""},{"location":"Drivers/class_members/#a","title":"a","text":"<ul> <li>alert_mask (EMC2305_Global_Config)</li> </ul>"},{"location":"Drivers/class_members/#c","title":"c","text":"<ul> <li>chip (EMC2305_I2C_Message)</li> </ul>"},{"location":"Drivers/class_members/#d","title":"d","text":"<ul> <li>derivative_options (EMC2305_Fan_Config2)</li> <li>drive_failed (EMC2305_Fan_Status)</li> <li>disable_smbus_timeout (EMC2305_Global_Config)</li> <li>drive_ext_clk (EMC2305_Global_Config)</li> <li>dev_addr (EMC2305_HandleTypeDef)</li> </ul>"},{"location":"Drivers/class_members/#e","title":"e","text":"<ul> <li>edges (EMC2305_Fan_Config1)</li> <li>enable_closed_loop (EMC2305_Fan_Config1)</li> <li>enable_glitch_filter (EMC2305_Fan_Config2)</li> <li>enable_ramp_rate_ctl (EMC2305_Fan_Config2)</li> <li>error_window (EMC2305_Fan_Config2)</li> </ul>"},{"location":"Drivers/class_members/#h","title":"h","text":"<ul> <li>hi2c (EMC2305_HandleTypeDef)</li> </ul>"},{"location":"Drivers/class_members/#i","title":"i","text":"<ul> <li>i2c_complete (EMC2305_HandleTypeDef)</li> </ul>"},{"location":"Drivers/class_members/#o","title":"o","text":"<ul> <li>operation (EMC2305_I2C_Message)</li> </ul>"},{"location":"Drivers/class_members/#p","title":"p","text":"<ul> <li>Pin (led_pins)</li> <li>Port (led_pins)</li> </ul>"},{"location":"Drivers/class_members/#r","title":"r","text":"<ul> <li>range (EMC2305_Fan_Config1)</li> <li>read_data (EMC2305_I2C_Message)</li> <li>reg_addr (EMC2305_I2C_Message)</li> </ul>"},{"location":"Drivers/class_members/#s","title":"s","text":"<ul> <li>spin_failed (EMC2305_Fan_Status)</li> <li>stalled (EMC2305_Fan_Status)</li> <li>semaphore_index (EMC2305_I2C_Message)</li> </ul>"},{"location":"Drivers/class_members/#u","title":"u","text":"<ul> <li>update_time (EMC2305_Fan_Config1)</li> <li>use_ext_clk (EMC2305_Global_Config)</li> </ul>"},{"location":"Drivers/class_members/#w","title":"w","text":"<ul> <li>watchdog_fired (EMC2305_Fan_Status)</li> <li>watchdog_enable (EMC2305_Global_Config)</li> <li>write_data (EMC2305_I2C_Message)</li> </ul>"},{"location":"Drivers/classes/","title":"Class Index","text":""},{"location":"Drivers/classes/#e","title":"e","text":"<ul> <li>EMC2305_Fan_Config1</li> <li>EMC2305_Fan_Config2</li> <li>EMC2305_Fan_Status</li> <li>EMC2305_Global_Config</li> <li>EMC2305_HandleTypeDef</li> <li>EMC2305_I2C_Message</li> </ul>"},{"location":"Drivers/classes/#l","title":"l","text":"<ul> <li>led_pins</li> </ul>"},{"location":"Drivers/dir_1284b95147afa48b330f502c8bbc0529/","title":"Dir driver","text":"<p>FileList &gt; driver</p>"},{"location":"Drivers/dir_1284b95147afa48b330f502c8bbc0529/#directories","title":"Directories","text":"Type Name dir Inc <p>The documentation for this class was generated from the following file <code>driver/</code></p>"},{"location":"Drivers/dir_63ffe06a04b97e03324a2ad2f10a5002/","title":"Dir driver/Inc","text":"<p>FileList &gt; driver &gt; Inc</p>"},{"location":"Drivers/dir_63ffe06a04b97e03324a2ad2f10a5002/#files","title":"Files","text":"Type Name file EMC2305.h file SevenSegment.h file printf.h <p>The documentation for this class was generated from the following file <code>driver/Inc/</code></p>"},{"location":"Drivers/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir driver <ul> <li>dir Inc <ul> <li>file EMC2305.h </li> <li>file SevenSegment.h </li> <li>file printf.h </li> </ul> </li> </ul> </li> </ul>"},{"location":"Drivers/functions/","title":"Functions","text":""},{"location":"Drivers/functions/#d","title":"d","text":"<ul> <li>displayNum_SevenSegment (SevenSegment.h)</li> <li>displayTwoNum_SevenSegment (SevenSegment.h)</li> </ul>"},{"location":"Drivers/functions/#e","title":"e","text":"<ul> <li>EMC2305_EnableSWLock (EMC2305.h)</li> <li>EMC2305_GetFanPWM (EMC2305.h)</li> <li>EMC2305_GetFanRPM (EMC2305.h)</li> <li>EMC2305_GetFanStatus (EMC2305.h)</li> <li>EMC2305_I2C_MasterRxCpltCallback (EMC2305.h)</li> <li>EMC2305_I2C_MasterTxCpltCallback (EMC2305.h)</li> <li>EMC2305_I2C_Worker_Task (EMC2305.h)</li> <li>EMC2305_Init (EMC2305.h)</li> <li>EMC2305_ReadReg (EMC2305.h)</li> <li>EMC2305_SetFanConfig (EMC2305.h)</li> <li>EMC2305_SetFanPWM (EMC2305.h)</li> <li>EMC2305_SetFanRPM (EMC2305.h)</li> <li>EMC2305_SetGlobalConfig (EMC2305.h)</li> <li>EMC2305_SetPWMBaseFrequency (EMC2305.h)</li> <li>EMC2305_SetPWMOutputMode (EMC2305.h)</li> <li>EMC2305_WriteReg (EMC2305.h)</li> </ul>"},{"location":"Drivers/functions/#o","title":"o","text":"<ul> <li>off_SevenSegment (SevenSegment.h)</li> </ul>"},{"location":"Drivers/functions/#p","title":"p","text":"<ul> <li>printf (printf.h)</li> <li>printf_init (printf.h)</li> </ul>"},{"location":"Drivers/functions/#s","title":"s","text":"<ul> <li>SevenSegment_Init (SevenSegment.h)</li> <li>scanf (printf.h)</li> </ul>"},{"location":"Drivers/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>struct EMC2305_Fan_Config1 </li> <li>struct EMC2305_Fan_Config2 </li> <li>struct EMC2305_Fan_Status </li> <li>struct EMC2305_Global_Config </li> <li>struct EMC2305_HandleTypeDef </li> <li>struct EMC2305_I2C_Message </li> <li>struct led_pins </li> </ul>"},{"location":"Drivers/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Drivers/macros/","title":"Macros","text":""},{"location":"Drivers/macros/#e","title":"e","text":"<ul> <li>EMC2305_CFG_DIS_TO (EMC2305.h)</li> <li>EMC2305_CFG_DRECK (EMC2305.h)</li> <li>EMC2305_CFG_MASK_ALERT (EMC2305.h)</li> <li>EMC2305_CFG_USECK (EMC2305.h)</li> <li>EMC2305_CFG_WD_EN (EMC2305.h)</li> <li>EMC2305_CONFIG1_EDG_SHIFT (EMC2305.h)</li> <li>EMC2305_CONFIG1_ENAG_SHIFT (EMC2305.h)</li> <li>EMC2305_CONFIG1_RNG_SHIFT (EMC2305.h)</li> <li>EMC2305_CONFIG1_UDT_SHIFT (EMC2305.h)</li> <li>EMC2305_CONFIG2_DPT_SHIFT (EMC2305.h)</li> <li>EMC2305_CONFIG2_ENRC_SHIFT (EMC2305.h)</li> <li>EMC2305_CONFIG2_ERG_SHIFT (EMC2305.h)</li> <li>EMC2305_CONFIG2_GHEN_SHIFT (EMC2305.h)</li> <li>EMC2305_FAN1_MASK (EMC2305.h)</li> <li>EMC2305_FAN2_MASK (EMC2305.h)</li> <li>EMC2305_FAN3_MASK (EMC2305.h)</li> <li>EMC2305_FAN4_MASK (EMC2305.h)</li> <li>EMC2305_FAN5_MASK (EMC2305.h)</li> <li>EMC2305_FAN_ADDRESS_OFFSET (EMC2305.h)</li> <li>EMC2305_FAN_REG_ADDR (EMC2305.h)</li> <li>EMC2305_I2C_TIMEOUT (EMC2305.h)</li> <li>EMC2305_INVALID_FAN (EMC2305.h)</li> <li>EMC2305_MAX_RPM (EMC2305.h)</li> <li>EMC2305_MIN_RPM (EMC2305.h)</li> <li>EMC2305_PWM_FAN1_MASK (EMC2305.h)</li> <li>EMC2305_PWM_FAN1_SHIFT (EMC2305.h)</li> <li>EMC2305_PWM_FAN2_MASK (EMC2305.h)</li> <li>EMC2305_PWM_FAN2_SHIFT (EMC2305.h)</li> <li>EMC2305_PWM_FAN3_MASK (EMC2305.h)</li> <li>EMC2305_PWM_FAN3_SHIFT (EMC2305.h)</li> <li>EMC2305_PWM_FAN4_MASK (EMC2305.h)</li> <li>EMC2305_PWM_FAN4_SHIFT (EMC2305.h)</li> <li>EMC2305_PWM_FAN5_MASK (EMC2305.h)</li> <li>EMC2305_PWM_FAN5_SHIFT (EMC2305.h)</li> <li>EMC2305_QUEUE_ITEM_SIZE (EMC2305.h)</li> <li>EMC2305_QUEUE_LENGTH (EMC2305.h)</li> <li>EMC2305_REG_CONFIGURATION (EMC2305.h)</li> <li>EMC2305_REG_DRIVE_FAIL_STATUS (EMC2305.h)</li> <li>EMC2305_REG_FAN1_CONFIG1 (EMC2305.h)</li> <li>EMC2305_REG_FAN1_CONFIG2 (EMC2305.h)</li> <li>EMC2305_REG_FAN1_DRVFAIL_H (EMC2305.h)</li> <li>EMC2305_REG_FAN1_DRVFAIL_L (EMC2305.h)</li> <li>EMC2305_REG_FAN1_MAX_STEP (EMC2305.h)</li> <li>EMC2305_REG_FAN1_MIN_DRIVE (EMC2305.h)</li> <li>EMC2305_REG_FAN1_SETTING (EMC2305.h)</li> <li>EMC2305_REG_FAN1_SPIN (EMC2305.h)</li> <li>EMC2305_REG_FAN1_TACH_READING_H (EMC2305.h)</li> <li>EMC2305_REG_FAN1_TACH_READING_L (EMC2305.h)</li> <li>EMC2305_REG_FAN1_TACH_TARGET_H (EMC2305.h)</li> <li>EMC2305_REG_FAN1_TACH_TARGET_L (EMC2305.h)</li> <li>EMC2305_REG_FAN1_VALID_TACH (EMC2305.h)</li> <li>EMC2305_REG_FAN_INTERRUPT_ENABLE (EMC2305.h)</li> <li>EMC2305_REG_FAN_SPIN_STATUS (EMC2305.h)</li> <li>EMC2305_REG_FAN_STALL_STATUS (EMC2305.h)</li> <li>EMC2305_REG_FAN_STATUS (EMC2305.h)</li> <li>EMC2305_REG_GAIN1 (EMC2305.h)</li> <li>EMC2305_REG_MANUFACTURER_ID (EMC2305.h)</li> <li>EMC2305_REG_PRODUCT_FEAT (EMC2305.h)</li> <li>EMC2305_REG_PRODUCT_ID (EMC2305.h)</li> <li>EMC2305_REG_PWM1_DIVIDE (EMC2305.h)</li> <li>EMC2305_REG_PWM_BASEF123 (EMC2305.h)</li> <li>EMC2305_REG_PWM_BASEF45 (EMC2305.h)</li> <li>EMC2305_REG_PWM_OUTPUT_CONFIG (EMC2305.h)</li> <li>EMC2305_REG_PWM_POLARITY (EMC2305.h)</li> <li>EMC2305_REG_REVISION (EMC2305.h)</li> <li>EMC2305_REG_SW_LOCK (EMC2305.h)</li> <li>EMC2305_SEMAPHORE_POOL_SIZE (EMC2305.h)</li> <li>EMC2305_STAT_DRVFAIL (EMC2305.h)</li> <li>EMC2305_STAT_FNSPIN (EMC2305.h)</li> <li>EMC2305_STAT_FNSTL (EMC2305.h)</li> <li>EMC2305_STAT_WATCH (EMC2305.h)</li> <li>EMC2305_SWL (EMC2305.h)</li> <li>EMC2305_TACH_MULT (EMC2305.h)</li> <li>EMC2305_TACH_RPM_CONV (EMC2305.h)</li> </ul>"},{"location":"Drivers/macros/#m","title":"m","text":"<ul> <li>MAX_NUM (SevenSegment.h)</li> </ul>"},{"location":"Drivers/macros/#n","title":"n","text":"<ul> <li>NUMBER_SEGMENTS (SevenSegment.h)</li> <li>NUMBER_SEVEN_SEGMENTS (SevenSegment.h)</li> </ul>"},{"location":"Drivers/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Drivers/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"Drivers/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"Drivers/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Drivers/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Drivers/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"Drivers/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"Drivers/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Drivers/printf_8h/","title":"File printf.h","text":"<p>FileList &gt; driver &gt; Inc &gt; printf.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include \"UART.h\"</code></li> </ul>"},{"location":"Drivers/printf_8h/#public-functions","title":"Public Functions","text":"Type Name int printf (const char * format, ...)  bool printf_init (UART_HandleTypeDef * huart)  int scanf (const char * format, ...)"},{"location":"Drivers/printf_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Drivers/printf_8h/#function-printf","title":"function printf","text":"<pre><code>int printf (\n    const char * format,\n    ...\n) \n</code></pre>"},{"location":"Drivers/printf_8h/#function-printf_init","title":"function printf_init","text":"<pre><code>bool printf_init (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"Drivers/printf_8h/#function-scanf","title":"function scanf","text":"<pre><code>int scanf (\n    const char * format,\n    ...\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>driver/Inc/printf.h</code></p>"},{"location":"Drivers/printf_8h_source/","title":"File printf.h","text":"<p>File List &gt; driver &gt; Inc &gt; printf.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;stdbool.h&gt;\n#include \"UART.h\"\n\nextern int printf ( const char * format, ... );\nextern int scanf  ( const char * format, ... );\n\nbool printf_init(UART_HandleTypeDef *huart);\n</code></pre>"},{"location":"Drivers/structEMC2305__Fan__Config1/","title":"Struct EMC2305_Fan_Config1","text":"<p>ClassList &gt; EMC2305_Fan_Config1</p> <ul> <li><code>#include &lt;EMC2305.h&gt;</code></li> </ul>"},{"location":"Drivers/structEMC2305__Fan__Config1/#public-attributes","title":"Public Attributes","text":"Type Name EMC2305_EDG edges bool enable_closed_loop EMC2305_RNG range EMC2305_UDT update_time"},{"location":"Drivers/structEMC2305__Fan__Config1/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Drivers/structEMC2305__Fan__Config1/#variable-edges","title":"variable edges","text":"<pre><code>EMC2305_EDG EMC2305_Fan_Config1::edges;\n</code></pre>"},{"location":"Drivers/structEMC2305__Fan__Config1/#variable-enable_closed_loop","title":"variable enable_closed_loop","text":"<pre><code>bool EMC2305_Fan_Config1::enable_closed_loop;\n</code></pre>"},{"location":"Drivers/structEMC2305__Fan__Config1/#variable-range","title":"variable range","text":"<pre><code>EMC2305_RNG EMC2305_Fan_Config1::range;\n</code></pre>"},{"location":"Drivers/structEMC2305__Fan__Config1/#variable-update_time","title":"variable update_time","text":"<pre><code>EMC2305_UDT EMC2305_Fan_Config1::update_time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>driver/Inc/EMC2305.h</code></p>"},{"location":"Drivers/structEMC2305__Fan__Config2/","title":"Struct EMC2305_Fan_Config2","text":"<p>ClassList &gt; EMC2305_Fan_Config2</p> <ul> <li><code>#include &lt;EMC2305.h&gt;</code></li> </ul>"},{"location":"Drivers/structEMC2305__Fan__Config2/#public-attributes","title":"Public Attributes","text":"Type Name EMC2305_DPT derivative_options bool enable_glitch_filter bool enable_ramp_rate_ctl EMC2305_ERG error_window"},{"location":"Drivers/structEMC2305__Fan__Config2/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Drivers/structEMC2305__Fan__Config2/#variable-derivative_options","title":"variable derivative_options","text":"<pre><code>EMC2305_DPT EMC2305_Fan_Config2::derivative_options;\n</code></pre>"},{"location":"Drivers/structEMC2305__Fan__Config2/#variable-enable_glitch_filter","title":"variable enable_glitch_filter","text":"<pre><code>bool EMC2305_Fan_Config2::enable_glitch_filter;\n</code></pre>"},{"location":"Drivers/structEMC2305__Fan__Config2/#variable-enable_ramp_rate_ctl","title":"variable enable_ramp_rate_ctl","text":"<pre><code>bool EMC2305_Fan_Config2::enable_ramp_rate_ctl;\n</code></pre>"},{"location":"Drivers/structEMC2305__Fan__Config2/#variable-error_window","title":"variable error_window","text":"<pre><code>EMC2305_ERG EMC2305_Fan_Config2::error_window;\n</code></pre> <p>The documentation for this class was generated from the following file <code>driver/Inc/EMC2305.h</code></p>"},{"location":"Drivers/structEMC2305__Fan__Status/","title":"Struct EMC2305_Fan_Status","text":"<p>ClassList &gt; EMC2305_Fan_Status</p> <ul> <li><code>#include &lt;EMC2305.h&gt;</code></li> </ul>"},{"location":"Drivers/structEMC2305__Fan__Status/#public-attributes","title":"Public Attributes","text":"Type Name bool drive_failed bool spin_failed bool stalled bool watchdog_fired"},{"location":"Drivers/structEMC2305__Fan__Status/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Drivers/structEMC2305__Fan__Status/#variable-drive_failed","title":"variable drive_failed","text":"<pre><code>bool EMC2305_Fan_Status::drive_failed;\n</code></pre>"},{"location":"Drivers/structEMC2305__Fan__Status/#variable-spin_failed","title":"variable spin_failed","text":"<pre><code>bool EMC2305_Fan_Status::spin_failed;\n</code></pre>"},{"location":"Drivers/structEMC2305__Fan__Status/#variable-stalled","title":"variable stalled","text":"<pre><code>bool EMC2305_Fan_Status::stalled;\n</code></pre>"},{"location":"Drivers/structEMC2305__Fan__Status/#variable-watchdog_fired","title":"variable watchdog_fired","text":"<pre><code>bool EMC2305_Fan_Status::watchdog_fired;\n</code></pre> <p>The documentation for this class was generated from the following file <code>driver/Inc/EMC2305.h</code></p>"},{"location":"Drivers/structEMC2305__Global__Config/","title":"Struct EMC2305_Global_Config","text":"<p>ClassList &gt; EMC2305_Global_Config</p> <ul> <li><code>#include &lt;EMC2305.h&gt;</code></li> </ul>"},{"location":"Drivers/structEMC2305__Global__Config/#public-attributes","title":"Public Attributes","text":"Type Name bool alert_mask bool disable_smbus_timeout bool drive_ext_clk bool use_ext_clk bool watchdog_enable"},{"location":"Drivers/structEMC2305__Global__Config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Drivers/structEMC2305__Global__Config/#variable-alert_mask","title":"variable alert_mask","text":"<pre><code>bool EMC2305_Global_Config::alert_mask;\n</code></pre>"},{"location":"Drivers/structEMC2305__Global__Config/#variable-disable_smbus_timeout","title":"variable disable_smbus_timeout","text":"<pre><code>bool EMC2305_Global_Config::disable_smbus_timeout;\n</code></pre>"},{"location":"Drivers/structEMC2305__Global__Config/#variable-drive_ext_clk","title":"variable drive_ext_clk","text":"<pre><code>bool EMC2305_Global_Config::drive_ext_clk;\n</code></pre>"},{"location":"Drivers/structEMC2305__Global__Config/#variable-use_ext_clk","title":"variable use_ext_clk","text":"<pre><code>bool EMC2305_Global_Config::use_ext_clk;\n</code></pre>"},{"location":"Drivers/structEMC2305__Global__Config/#variable-watchdog_enable","title":"variable watchdog_enable","text":"<pre><code>bool EMC2305_Global_Config::watchdog_enable;\n</code></pre> <p>The documentation for this class was generated from the following file <code>driver/Inc/EMC2305.h</code></p>"},{"location":"Drivers/structEMC2305__HandleTypeDef/","title":"Struct EMC2305_HandleTypeDef","text":"<p>ClassList &gt; EMC2305_HandleTypeDef</p> <ul> <li><code>#include &lt;EMC2305.h&gt;</code></li> </ul>"},{"location":"Drivers/structEMC2305__HandleTypeDef/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t dev_addr I2C_HandleTypeDef * hi2c SemaphoreHandle_t i2c_complete"},{"location":"Drivers/structEMC2305__HandleTypeDef/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Drivers/structEMC2305__HandleTypeDef/#variable-dev_addr","title":"variable dev_addr","text":"<pre><code>uint16_t EMC2305_HandleTypeDef::dev_addr;\n</code></pre>"},{"location":"Drivers/structEMC2305__HandleTypeDef/#variable-hi2c","title":"variable hi2c","text":"<pre><code>I2C_HandleTypeDef* EMC2305_HandleTypeDef::hi2c;\n</code></pre>"},{"location":"Drivers/structEMC2305__HandleTypeDef/#variable-i2c_complete","title":"variable i2c_complete","text":"<pre><code>SemaphoreHandle_t EMC2305_HandleTypeDef::i2c_complete;\n</code></pre> <p>The documentation for this class was generated from the following file <code>driver/Inc/EMC2305.h</code></p>"},{"location":"Drivers/structEMC2305__I2C__Message/","title":"Struct EMC2305_I2C_Message","text":"<p>ClassList &gt; EMC2305_I2C_Message</p> <ul> <li><code>#include &lt;EMC2305.h&gt;</code></li> </ul>"},{"location":"Drivers/structEMC2305__I2C__Message/#public-attributes","title":"Public Attributes","text":"Type Name EMC2305_HandleTypeDef * chip EMC2305_I2C_OP operation uint8_t * read_data uint8_t reg_addr uint8_t semaphore_index uint8_t write_data"},{"location":"Drivers/structEMC2305__I2C__Message/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Drivers/structEMC2305__I2C__Message/#variable-chip","title":"variable chip","text":"<pre><code>EMC2305_HandleTypeDef* EMC2305_I2C_Message::chip;\n</code></pre>"},{"location":"Drivers/structEMC2305__I2C__Message/#variable-operation","title":"variable operation","text":"<pre><code>EMC2305_I2C_OP EMC2305_I2C_Message::operation;\n</code></pre>"},{"location":"Drivers/structEMC2305__I2C__Message/#variable-read_data","title":"variable read_data","text":"<pre><code>uint8_t* EMC2305_I2C_Message::read_data;\n</code></pre>"},{"location":"Drivers/structEMC2305__I2C__Message/#variable-reg_addr","title":"variable reg_addr","text":"<pre><code>uint8_t EMC2305_I2C_Message::reg_addr;\n</code></pre>"},{"location":"Drivers/structEMC2305__I2C__Message/#variable-semaphore_index","title":"variable semaphore_index","text":"<pre><code>uint8_t EMC2305_I2C_Message::semaphore_index;\n</code></pre>"},{"location":"Drivers/structEMC2305__I2C__Message/#variable-write_data","title":"variable write_data","text":"<pre><code>uint8_t EMC2305_I2C_Message::write_data;\n</code></pre> <p>The documentation for this class was generated from the following file <code>driver/Inc/EMC2305.h</code></p>"},{"location":"Drivers/structled__pins/","title":"Struct led_pins","text":"<p>ClassList &gt; led_pins</p> <ul> <li><code>#include &lt;SevenSegment.h&gt;</code></li> </ul>"},{"location":"Drivers/structled__pins/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t Pin GPIO_TypeDef * Port"},{"location":"Drivers/structled__pins/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Drivers/structled__pins/#variable-pin","title":"variable Pin","text":"<pre><code>uint32_t led_pins::Pin;\n</code></pre>"},{"location":"Drivers/structled__pins/#variable-port","title":"variable Port","text":"<pre><code>GPIO_TypeDef* led_pins::Port;\n</code></pre> <p>The documentation for this class was generated from the following file <code>driver/Inc/SevenSegment.h</code></p>"},{"location":"Drivers/variables/","title":"Variables","text":""},{"location":"Drivers/variables/#d","title":"d","text":"<ul> <li>display (SevenSegment.h)</li> <li>display_t (SevenSegment.h)</li> </ul>"},{"location":"Drivers/variables/#e","title":"e","text":"<ul> <li>EMC2305_DPT (EMC2305.h)</li> <li>EMC2305_EDG (EMC2305.h)</li> <li>EMC2305_ERG (EMC2305.h)</li> <li>EMC2305_Fan (EMC2305.h)</li> <li>EMC2305_I2C_OP (EMC2305.h)</li> <li>EMC2305_PID_Gain (EMC2305.h)</li> <li>EMC2305_PWM_BaseFreq (EMC2305.h)</li> <li>EMC2305_RNG (EMC2305.h)</li> <li>EMC2305_Status (EMC2305.h)</li> <li>EMC2305_UDT (EMC2305.h)</li> </ul>"},{"location":"Drivers/variables/#l","title":"l","text":"<ul> <li>led_t (SevenSegment.h)</li> </ul>"},{"location":"Middleware/annotated/","title":"Class List","text":"<p>No classes, structs, unions or interfaces found.</p>"},{"location":"Middleware/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Middleware/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"Middleware/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Middleware/class_member_variables/","title":"Class Member Variables","text":"<p>Nothing related to Class Member Variables found.</p>"},{"location":"Middleware/class_members/","title":"Class Members","text":"<p>Nothing related to Class Members found.</p>"},{"location":"Middleware/classes/","title":"Class Index","text":""},{"location":"Middleware/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p>"},{"location":"Middleware/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Middleware/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p>"},{"location":"Middleware/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Middleware/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"Middleware/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Middleware/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"Middleware/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"Middleware/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Middleware/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Middleware/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"Middleware/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"Middleware/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Middleware/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"}]}