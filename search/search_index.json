{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Embedded Sharepoint Documentation","text":"<p>Welcome to the Embedded Sharepoint! Embedded-Sharepoint contains the shared embedded files to build and develop for our custom STM32 PCBs.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#directory-structure","title":"Directory Structure","text":""},{"location":"#command-usage","title":"Command Usage","text":""},{"location":"#running-tests","title":"Running tests","text":""},{"location":"#adding-sharepoint-to-your-project","title":"Adding Sharepoint To Your Project","text":"<p>Embedded-Sharepoint contains common files so it should be stored as a submodule inside your repository.  </p>"},{"location":"#examples","title":"Examples:","text":"<ul> <li>BPS-Leader</li> <li>Activ-Precharge Board</li> </ul>"},{"location":"#contributing","title":"Contributing","text":""},{"location":"#wsl","title":"WSL","text":""},{"location":"#usb-passthrough","title":"USB PassThrough","text":""},{"location":"#pass-usb-devices","title":"Pass USB Devices","text":"<p>In PowerShell administrator: </p> <pre><code>usbipd list\nusbipd bind --busid &lt;busid&gt;\nusbipd attach --wsl --busid &lt;busid&gt;\n</code></pre>"},{"location":"#porting","title":"Porting","text":"<p>A valid port of an STM requires three things:</p> <ol> <li>A directory under stm/stm32f4xx or stm/stm32l4xx must be generated with the generic name of the microcontroller. This is typically stm32 followed by four characters specifying the series and line (stm32f413, stm32l431, etc.)</li> <li>A linker script under the aforementioned directory. This can be autogenerated by STM32CubeMX or grabbed from the internet. The name should take the form of STM32*_FLASH.ld, and should include the full name of the processor (STM32F413RHTx_FLASH.ld, STM32L431CBTx_FLASH.ld, etc.)</li> <li>A startup assembly file including the vector table and some basic handlers (most important being Reset_Handler). This can be autogenerated by STM32CubeMX or grabbed from the internet. The name should take the form of startup_stm32 followed by the four characters specifying the series and line and then xx (startup_stm32f413xx.s, startup_stm32l431xx.s)</li> </ol> <p>The Makefile will expect this exact naming structure, so please ensure you've set it up properly. If everything goes to plan, you should be able to build with PROJECT_TARGET set to the full name of the port.</p>"},{"location":"DBC/","title":"Table of Contents","text":"<ul> <li>Bps (daybreak)</li> <li>Contactor</li> <li>Controls</li> <li>Prohelion Wavesculptor22</li> <li>Tpee Mppt[a]</li> <li>Tpee Mppt[b]</li> </ul>"},{"location":"DBC/#bps-daybreakdbc","title":"bps (Daybreak).dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages","title":"Messages","text":"ID Name DLC Signals 0x2 BPS_Trip 1 BPS_Trip 0x101 BPS_All_Clea 1 BPS_All_Clear 0x102 BPS_Contactor_State 1 HV_Contactor, Array_Contactor 0x103 BPS_Current 4 Current 0x104 BPS_Voltage_Array 5 Voltage_idx, Voltage_Value 0x105 BPS_Temperature_Array 5 Temperature_idx, Temperature_Value 0x106 BPS_SOC 4 SoC 0x107 BPS_WDog_Trigger 1 WDog_Trig 0x108 BPS_CAN_Error 1 BPS_CAN_Error 0x109 BPS_Command 8 BPS_Command 0x10B BPS_Supplemental_Voltage 2 Supplemental_Voltage 0x10C BPS_Charge_Enabled 1 Charge_Enabled 0x10D BPS_Voltage_Summary 8 Pack_Voltage, Voltage_Range, Voltage_Timestamp 0x10E BPS_Temperature_Summary 8 Average_Temp, Temperature_Range, Temperature_Timestamp 0x10F BPS_Fault_State 1 BPS_Fault_State"},{"location":"DBC/#signals","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit BPS_Trip BPS_Trip [0:0] 1 1 0 0 1 BPS_All_Clear BPS_All_Clea [0:0] 1 1 0 0 1 HV_Contactor BPS_Contactor_State [2:2] 1 1 0 0 1 Array_Contactor BPS_Contactor_State [0:0] 1 1 0 0 1 Current BPS_Current [0:31] 32 1 0 -20000 100000 mA Voltage_idx BPS_Voltage_Array [0:7] 8 1 0 0 31 Voltage_Value BPS_Voltage_Array [8:39] 32 1 0 0 1000000 mV Temperature_idx BPS_Temperature_Array [0:7] 8 1 0 0 31 Temperature_Value BPS_Temperature_Array [8:39] 32 1 0 0 1000000 mC SoC BPS_SOC [0:31] 32 1 0 0 100 % WDog_Trig BPS_WDog_Trigger [0:0] 1 1 0 0 1 BPS_CAN_Error BPS_CAN_Error [0:0] 1 1 0 0 1 BPS_Command BPS_Command [0:31] 32 1 0 None None Supplemental_Voltage BPS_Supplemental_Voltage [0:15] 16 1 0 0 65535 mV Charge_Enabled BPS_Charge_Enabled [0:0] 1 1 0 0 1 Pack_Voltage BPS_Voltage_Summary [0:23] 24 1 0 0 16777215 mV Voltage_Range BPS_Voltage_Summary [24:47] 24 1 0 0 16777215 mV Voltage_Timestamp BPS_Voltage_Summary [48:63] 16 1 0 0 65535 ms Average_Temp BPS_Temperature_Summary [0:23] 24 1 0 None None mC Temperature_Range BPS_Temperature_Summary [24:47] 24 1 0 None None mC Temperature_Timestamp BPS_Temperature_Summary [48:63] 16 1 0 None None ms BPS_Fault_State BPS_Fault_State [0:7] 8 1 0 0 12"},{"location":"DBC/#contactordbc","title":"contactor.dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_1","title":"Messages","text":"ID Name DLC Signals 0x401 Precharge_Timeout 1 Motor_Precharge_Timeout, Array_Precharge_Timeout 0x400 Contactor_Sense 2 Actual_Motor_Sense, Expected_Motor_Sense, Motor_Sense_Fault, Motor_Precharge_Sense, Expected_Motor_Precharge_Sense, Motor_Precharge_Sense_Fault, Array_Precharge_Sense, Expected_Array_Precharge_Sense, Array_Prechage_Sense_Fault"},{"location":"DBC/#signals_1","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit Motor_Precharge_Timeout Precharge_Timeout [0:0] 1 1 0 0 1 Array_Precharge_Timeout Precharge_Timeout [1:1] 1 1 0 None None Actual_Motor_Sense Contactor_Sense [0:0] 1 1 0 0 1 Expected_Motor_Sense Contactor_Sense [1:1] 1 1 0 None None Motor_Sense_Fault Contactor_Sense [2:2] 1 1 0 0 1 Motor_Precharge_Sense Contactor_Sense [3:3] 1 1 0 0 1 Expected_Motor_Precharge_Sense Contactor_Sense [4:4] 1 1 0 0 1 Motor_Precharge_Sense_Fault Contactor_Sense [5:5] 1 1 0 0 1 Array_Precharge_Sense Contactor_Sense [6:6] 1 1 0 0 1 Expected_Array_Precharge_Sense Contactor_Sense [7:7] 1 1 0 0 1 Array_Prechage_Sense_Fault Contactor_Sense [8:8] 1 1 0 0 1"},{"location":"DBC/#controlsdbc","title":"controls.dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_2","title":"Messages","text":"ID Name DLC Signals 0x581 IO_State 3 Acceleration_Percentage, Brake_Percentage, IGN_Array, IGN_Motor, Regen_SW, Forward_Gear, Reverse_Gear, Cruz_EN, Cruz_Set, Brake_Light 0x583 Controls_Fault 1 Controls_Fault, Motor_Controller_Fault, BPS_Fault, Pedals_Fault, CarCAN_Fault, Internal_Controls_Fault, OS_Fault, Lakshay_Fault 0x584 Motor_Controller_Safe 1 Motor_Safe, Motor_Controller_Error 0x221 Motor_Drive_Command 8 Motor_Velocity_Setpoint, Motor_Current_Setpoint 0x222 Motor_Power_Command 8 Motor_Power_Setpoint 0x585 Pedals_Raw_Voltage 4 Brake_Raw, Accel_Raw"},{"location":"DBC/#signals_2","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit Acceleration_Percentage IO_State [0:7] 8 1 0 0 100 Percentage Brake_Percentage IO_State [8:15] 8 1 0 0 100 Percentage the brake is pressed IGN_Array IO_State [16:16] 1 1 0 0 1 Array Ignition On IGN_Motor IO_State [17:17] 1 1 0 0 1 Motor Ignition On Regen_SW IO_State [18:18] 1 1 0 0 1 Regen Switched On Forward_Gear IO_State [19:19] 1 1 0 0 1 Forward switch Reverse_Gear IO_State [20:20] 1 1 0 0 1 Reverse switch Cruz_EN IO_State [21:21] 1 1 0 0 1 Cruise Enable Cruz_Set IO_State [22:22] 1 1 0 0 1 Cruise Set Brake_Light IO_State [23:23] 1 1 0 0 1 Brakelight state Controls_Fault Controls_Fault [0:0] 1 1 0 0 1 Motor_Controller_Fault Controls_Fault [1:1] 1 1 0 0 1 BPS_Fault Controls_Fault [2:2] 1 1 0 0 1 Pedals_Fault Controls_Fault [3:3] 1 1 0 None None CarCAN_Fault Controls_Fault [4:4] 1 1 0 0 1 Internal_Controls_Fault Controls_Fault [5:5] 1 1 0 0 1 OS_Fault Controls_Fault [6:6] 1 1 0 0 1 Lakshay_Fault Controls_Fault [7:7] 1 1 0 0 1 Motor_Safe Motor_Controller_Safe [0:0] 1 1 0 0 1 Motor_Controller_Error Motor_Controller_Safe [1:1] 1 1 0 0 1 Motor_Velocity_Setpoint Motor_Drive_Command [0:31] 32 1 0 None None rpm Motor_Current_Setpoint Motor_Drive_Command [32:63] 32 1 0 None None % Motor_Power_Setpoint Motor_Power_Command [32:63] 32 1 0 None None % Brake_Raw Pedals_Raw_Voltage [0:14] 15 1 0 0 3300 mV Accel_Raw Pedals_Raw_Voltage [16:30] 15 1 0 0 3300 mV"},{"location":"DBC/#prohelion_wavesculptor22dbc","title":"prohelion_wavesculptor22.dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_3","title":"Messages","text":"ID Name DLC Signals 0x240 IDInfo 8 TritiumID, SerialNumber 0x241 Status 8 LimitOutputVoltagePWM, LimitMotorCurrent, LimitVelocity, LimitBusCurrent, LimitBusVoltageUpper, LimitBusVoltageLower, LimitIpmOrMotorTemp, LimitReserved, ErrorHardwareOverCurrent, ErrorSoftwareOverCurrent, ErrorDcBusOverVoltage, ErrorBadMotorPositionHallSeq, ErrorWatchdogCausedLastReset, ErrorConfigRead, Error15vRailUnderVoltage, ErrorDesaturationFault, ErrorMotorOverSpeed, ErrorReserved, ActiveMotor, TxErrorCount, RxErrorCount 0x242 BusMeasurement 8 BusVoltage, BusCurrent 0x243 VelocityMeasurement 8 MotorVelocity, VehicleVelocity 0x244 PhaseCurrentMeasurement 8 PhaseCurrentB, PhaseCurrentC 0x245 MotorVoltageVectorMeasurement 8 Vq, Vd 0x246 MotorCurrentVectorMeasurement 8 Iq, Id 0x247 BackEMFMeasurementPrediction 8 BEMFq, BEMFd 0x248 VoltageRail15VMeasurement 8 ReservedSupply15V, Supply15V 0x249 VoltageRail3V31V9Measurement 8 Supply1V9, Supply3V3 0x24A Reserved0A 8 Reserved0A0, Reserved0A1 0x24B HeatsinkMotorTempMeasurement 8 MotorTemp, HeatsinkTemp 0x24C DspBoardTempMeasurement 8 DspBoardTemp, ReservedDspBoardTemp 0x24D Reserved0D 8 Reserved0D0, Reserved0D1 0x24E OdometerBusAhMeasurement 8 Odometer, DCBusAh 0x257 SlipSpeedMeasurement 8 SlipSpeed, ReservedSlipSpeed"},{"location":"DBC/#signals_3","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit TritiumID IDInfo [0:31] 32 1 0 None None SerialNumber IDInfo [32:63] 32 1 0 None None LimitOutputVoltagePWM Status [0:0] 1 1 0 0 1 On / Off LimitMotorCurrent Status [1:1] 1 1 0 0 1 On / Off LimitVelocity Status [2:2] 1 1 0 0 1 On / Off LimitBusCurrent Status [3:3] 1 1 0 0 1 On / Off LimitBusVoltageUpper Status [4:4] 1 1 0 0 1 On / Off LimitBusVoltageLower Status [5:5] 1 1 0 0 1 On / Off LimitIpmOrMotorTemp Status [6:6] 1 1 0 0 1 On / Off LimitReserved Status [7:15] 9 1 0 0 511 On / Off ErrorHardwareOverCurrent Status [16:16] 1 1 0 0 1 On / Off ErrorSoftwareOverCurrent Status [17:17] 1 1 0 0 1 On / Off ErrorDcBusOverVoltage Status [18:18] 1 1 0 0 1 On / Off ErrorBadMotorPositionHallSeq Status [19:19] 1 1 0 0 1 On / Off ErrorWatchdogCausedLastReset Status [20:20] 1 1 0 0 1 On / Off ErrorConfigRead Status [21:21] 1 1 0 0 1 On / Off Error15vRailUnderVoltage Status [22:22] 1 1 0 0 1 On / Off ErrorDesaturationFault Status [23:23] 1 1 0 0 1 On / Off ErrorMotorOverSpeed Status [24:24] 1 1 0 0 1 On / Off ErrorReserved Status [25:31] 7 1 0 None None On / Off ActiveMotor Status [32:47] 16 1 0 None None TxErrorCount Status [48:55] 8 1 0 None None RxErrorCount Status [56:63] 8 1 0 None None BusVoltage BusMeasurement [0:31] 32 1 0 0 100 V BusCurrent BusMeasurement [32:63] 32 1 0 0 1000 A MotorVelocity VelocityMeasurement [0:31] 32 1 0 None None rpm VehicleVelocity VelocityMeasurement [32:63] 32 2.237 0 None None mph PhaseCurrentB PhaseCurrentMeasurement [0:31] 32 1 0 None None A_rms PhaseCurrentC PhaseCurrentMeasurement [32:63] 32 1 0 None None A_rms Vq MotorVoltageVectorMeasurement [0:31] 32 1 0 None None V Vd MotorVoltageVectorMeasurement [32:63] 32 1 0 None None V Iq MotorCurrentVectorMeasurement [0:31] 32 1 0 None None A Id MotorCurrentVectorMeasurement [32:63] 32 1 0 None None A BEMFq BackEMFMeasurementPrediction [0:31] 32 1 0 None None V BEMFd BackEMFMeasurementPrediction [32:63] 32 1 0 None None V ReservedSupply15V VoltageRail15VMeasurement [0:31] 32 1 0 None None Supply15V VoltageRail15VMeasurement [32:63] 32 1 0 None None V Supply1V9 VoltageRail3V31V9Measurement [0:31] 32 1 0 None None V Supply3V3 VoltageRail3V31V9Measurement [32:63] 32 1 0 None None V Reserved0A0 Reserved0A [0:31] 32 1 0 None None Reserved0A1 Reserved0A [32:63] 32 1 0 None None MotorTemp HeatsinkMotorTempMeasurement [0:31] 32 1 0 None None C HeatsinkTemp HeatsinkMotorTempMeasurement [32:63] 32 1 0 None None C DspBoardTemp DspBoardTempMeasurement [0:31] 32 1 0 None None C ReservedDspBoardTemp DspBoardTempMeasurement [32:63] 32 1 0 None None Reserved0D0 Reserved0D [0:31] 32 1 0 None None Reserved0D1 Reserved0D [32:63] 32 1 0 None None Odometer OdometerBusAhMeasurement [0:31] 32 1 0 None None m DCBusAh OdometerBusAhMeasurement [32:63] 32 1 0 None None Ah SlipSpeed SlipSpeedMeasurement [0:31] 32 1 0 None None Hz ReservedSlipSpeed SlipSpeedMeasurement [32:63] 32 1 0 None None"},{"location":"DBC/#tpee_mpptadbc","title":"tpee_mppt[A].dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_4","title":"Messages","text":"ID Name DLC Signals 0x201 MPPT_32_0_Status 5 MPPT_Mode, MPPT_Fault, MPPT_Enabled, MPPT_AmbientTemperature, MPPT_HeatsinkTemperature 0x200 MPPT_32_0_Power 8 MPPT_Vin, MPPT_Iin, MPPT_Vout, MPPT_Iout 0x209 MPPT_32_0_SetMode 1 Boost_Enable"},{"location":"DBC/#signals_4","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit MPPT_Mode MPPT_32_0_Status [0:7] 8 1 0 None None MPPT_Fault MPPT_32_0_Status [8:15] 8 1 0 None None MPPT_Enabled MPPT_32_0_Status [16:23] 8 1 0 None None MPPT_AmbientTemperature MPPT_32_0_Status [31:38] 8 1 0 -128 127 C MPPT_HeatsinkTemperature MPPT_32_0_Status [39:46] 8 1 0 -128 127 C MPPT_Vin MPPT_32_0_Power [7:22] 16 0.01 0 -327.68 327.67 V MPPT_Iin MPPT_32_0_Power [23:38] 16 0.0005 0 -16.384 16.3835 A MPPT_Vout MPPT_32_0_Power [39:54] 16 0.01 0 -327.68 327.67 V MPPT_Iout MPPT_32_0_Power [55:70] 16 0.0005 0 None None A Boost_Enable MPPT_32_0_SetMode [0:0] 1 1 0 0 1"},{"location":"DBC/#tpee_mpptbdbc","title":"tpee_mppt[B].dbc","text":"<p>GitHub</p>"},{"location":"DBC/#messages_5","title":"Messages","text":"ID Name DLC Signals 0x211 MPPT_33_0_Status 5 MPPT_Mode, MPPT_Fault, MPPT_Enabled, MPPT_AmbientTemperature, MPPT_HeatsinkTemperature 0x210 MPPT_33_0_Power 8 MPPT_Vin, MPPT_Iin, MPPT_Vout, MPPT_Iout 0x219 MPPT_33_0_SetMode 1 Boost_Enable"},{"location":"DBC/#signals_5","title":"Signals","text":"Name Message Bits [start:end] Length Factor Offset Min Max Unit MPPT_Mode MPPT_33_0_Status [0:7] 8 1 0 None None MPPT_Fault MPPT_33_0_Status [8:15] 8 1 0 None None MPPT_Enabled MPPT_33_0_Status [16:23] 8 1 0 None None MPPT_AmbientTemperature MPPT_33_0_Status [31:38] 8 1 0 -128 127 C MPPT_HeatsinkTemperature MPPT_33_0_Status [39:46] 8 1 0 -128 127 C MPPT_Vin MPPT_33_0_Power [7:22] 16 0.01 0 -327.68 327.67 V MPPT_Iin MPPT_33_0_Power [23:38] 16 0.0005 0 -16.384 16.3835 A MPPT_Vout MPPT_33_0_Power [39:54] 16 0.01 0 -327.68 327.67 V MPPT_Iout MPPT_33_0_Power [55:70] 16 0.0005 0 None None A Boost_Enable MPPT_33_0_SetMode [0:0] 1 1 0 0 1"},{"location":"Installation/","title":"Installation Instructions","text":"<p>Development for Embedded-Sharepoint requires a linux-based environment. Running linux natively yields the best results, but there are workarounds through UTM virtual machine on Mac OS or Windows Subsystem for Linux (WSL) on Windows.  </p> <p>Please ensure you've done the following before moving on: 1. Follow the instructions here to create your github SSH key 2. Install Visual Studio Code</p>"},{"location":"Installation/#linux","title":"Linux","text":"<p>Thanks for making our lives easy :)    </p> <ol> <li>Follow the instructions here to create your github SSH key</li> <li>Run the steps in Nix next</li> </ol>"},{"location":"Installation/#windows","title":"Windows","text":""},{"location":"Installation/#windows-subsystem-for-linux-wsl","title":"Windows Subsystem for Linux (WSL)","text":"<p>Windows Subsystem for Linux allows you to run a linux terminal on your windows machine. We specifically use WSL2 since it allows USB passthrough for flashing our microcontrollers. To install WSL follow this guide. Make sure to install WSL2 and not WSL1. It will take time to fully install it, but once installed you can open WSL and it will ask you to create a username and password.</p>"},{"location":"Installation/#usbipd","title":"USBIPD","text":"<p>In order to see a USB device in WSL, we need to pass access of a USB device from windows to WSL. You can do this through USBIPD. In an administrator Powershell terminal run:</p> <pre><code>winget install usbipd\n</code></pre>"},{"location":"Installation/#mac","title":"Mac","text":"<p>To develop on a Mac we will use UTM, which is an apple application to emulate other operating systems. The following instructions have been tested on an M2 Macbook.</p>"},{"location":"Installation/#utm","title":"UTM","text":""},{"location":"Installation/#download","title":"Download","text":"<p>Download the UTM app here.  Download Ubuntu 24 here. </p>"},{"location":"Installation/#configuring-utm","title":"Configuring UTM","text":"<p>Next we will use the Ubuntu iso image we just downloaded to create a new Ubuntu VM</p> <ol> <li>Open UTM and click on Create a New Virtual Machine.</li> <li>Select Virtualize and then choose Linux.</li> <li>Press browse and select the downloaded ARM-based ISO file.</li> <li>Adjust hardware settings:<ul> <li>Memory: Default is 4000 MB (adjust based on Mac capacity).</li> <li>Storage: Default is 64 GB (adjust as necessary).</li> </ul> </li> <li>No shared directory necessary so press Continue here</li> <li>Name the VM (e.g., Ubuntu 24.04 LTS).</li> <li> <p>Click Save to create the VM.</p> </li> <li> <p>Click on Run to start the installation.</p> </li> <li>Use arrow keys to select Try or Install Ubuntu Server. </li> <li>Select language (e.g., English). </li> <li>Choose keyboard layout </li> <li>For installation type, ensure Ubuntu Server is selected. </li> <li>Enable Search for third-party drivers.</li> <li>Accept default for network configuration and proxy settings.</li> <li>Choose storage configuration: Use entire disk.</li> <li>Set up profile: Machine name (e.g., CodeBind). Username (e.g., CodeBind) and password.</li> <li>Choose to install OpenSSH for remote access.</li> <li>Continue through prompts to complete installation.</li> </ol>"},{"location":"Installation/#configuring-ssh","title":"Configuring SSH","text":"<p>The Ubuntu VM we created is pretty slow and can't run graphical applications easily, so it'll be hard to develop code here. What we will do instead is SSH into the VM we created from regular MacOS so we can develop our linux code while also being in MacOS.  </p> <p>Open the Ubuntu VM and run <code>hostname -I</code> This will output your Ubuntu VM's IP address to SSH into.  Note the ip address, everything before the letters (192.168.64.8 from the image above) </p> <p>Open Visual Studio Code in MacOS.  Install the folowing extensions from the extensions marketplace:  </p> <ol> <li>In VSCode press <code>command + shift + p</code></li> <li>Type Remote-SSH: Open SSH Configuration File</li> <li>Select the one that's in /.ssh/config</li> <li>This file contains all your possible SSH targets, we will add the Ubuntu VM as an SSH target. Type this into your ssh config and the IP address of your VM you got earlier.</li> </ol> <pre><code>Host [Name of SSH, can be anything]\nHostName [IP Address]\nUser [Your user name]\n</code></pre> <p>For example mine could be: </p> <pre><code>Host Ubuntu-UTM-VM\nHostName 192.169.42.0\nUser laksh \n</code></pre> <ol> <li>Press <code>command + shift + p</code> and type Remote-SSH: Connect to Host</li> <li>Select the hostname you just added</li> <li>Congrats! You are now SSH'd into your Ubuntu VM. </li> </ol> <p>Run the steps in Nix next</p>"},{"location":"Installation/#nix","title":"Nix","text":"<p>Nix is a package manger that lets you write out all the packages you want to install in a human readable format. This simplifies development since I can write out a list of dependencies needed to compile. Run the following scripts in your linux terminal: Make the nix_install script runnable</p> <pre><code>chmod +x ./nix_install.sh\n</code></pre> <p>Run the script to install the needed nix dependencies</p> <pre><code>./nix_install.sh\n</code></pre> <p>Enter the nix shell and download dependencies for Embedded-Sharepoint</p> <pre><code>nix develop\n</code></pre> <p>In this nix shell all the dependencies needed for Embedded-Sharepoint should be installed, anytime you want to develop code you will need to run nix develop. Test if installation is succesful by compiling a test </p> <pre><code>cd test\nmake TEST=blinky\n</code></pre>"},{"location":"BSP/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct recv_entry_t </li> <li>struct rx_payload_t </li> <li>struct tx_payload_t </li> </ul>"},{"location":"BSP/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir bsp <ul> <li>dir Src <ul> <li>file ADC.c </li> <li>file CAN.c </li> <li>file UART.c </li> </ul> </li> </ul> </li> </ul>"},{"location":"BSP/structrecv__entry__t/","title":"Struct recv_entry_t","text":"<p>ClassList &gt; recv_entry_t</p>"},{"location":"BSP/structrecv__entry__t/#public-attributes","title":"Public Attributes","text":"Type Name StaticQueue_t buffer bool circular uint16_t id QueueHandle_t queue uint16_t size uint8_t * storage"},{"location":"BSP/structrecv__entry__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BSP/structrecv__entry__t/#variable-buffer","title":"variable buffer","text":"<pre><code>StaticQueue_t recv_entry_t::buffer;\n</code></pre>"},{"location":"BSP/structrecv__entry__t/#variable-circular","title":"variable circular","text":"<pre><code>bool recv_entry_t::circular;\n</code></pre>"},{"location":"BSP/structrecv__entry__t/#variable-id","title":"variable id","text":"<pre><code>uint16_t recv_entry_t::id;\n</code></pre>"},{"location":"BSP/structrecv__entry__t/#variable-queue","title":"variable queue","text":"<pre><code>QueueHandle_t recv_entry_t::queue;\n</code></pre>"},{"location":"BSP/structrecv__entry__t/#variable-size","title":"variable size","text":"<pre><code>uint16_t recv_entry_t::size;\n</code></pre>"},{"location":"BSP/structrecv__entry__t/#variable-storage","title":"variable storage","text":"<pre><code>uint8_t* recv_entry_t::storage;\n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Src/CAN.c</code></p>"},{"location":"BSP/structrx__payload__t/","title":"Struct rx_payload_t","text":"<p>ClassList &gt; rx_payload_t</p>"},{"location":"BSP/structrx__payload__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t data CAN_RxHeaderTypeDef header"},{"location":"BSP/structrx__payload__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BSP/structrx__payload__t/#variable-data","title":"variable data","text":"<pre><code>uint8_t rx_payload_t::data;\n</code></pre>"},{"location":"BSP/structrx__payload__t/#variable-header","title":"variable header","text":"<pre><code>CAN_RxHeaderTypeDef rx_payload_t::header;\n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Src/CAN.c</code></p>"},{"location":"BSP/structtx__payload__t/","title":"Struct tx_payload_t","text":"<p>ClassList &gt; tx_payload_t</p>"},{"location":"BSP/structtx__payload__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t data CAN_TxHeaderTypeDef header"},{"location":"BSP/structtx__payload__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BSP/structtx__payload__t/#variable-data","title":"variable data","text":"<pre><code>uint8_t tx_payload_t::data;\n</code></pre>"},{"location":"BSP/structtx__payload__t/#variable-header","title":"variable header","text":"<pre><code>CAN_TxHeaderTypeDef tx_payload_t::header;\n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Src/CAN.c</code></p>"},{"location":"BSP/dir_3c5459f7c179b79c90e2565474bb2856/","title":"Dir bsp","text":"<p>FileList &gt; bsp</p>"},{"location":"BSP/dir_3c5459f7c179b79c90e2565474bb2856/#directories","title":"Directories","text":"Type Name dir Src <p>The documentation for this class was generated from the following file <code>bsp/</code></p>"},{"location":"BSP/dir_160128b01eb7e6b2a554f83ab5d45f5a/","title":"Dir bsp/Src","text":"<p>FileList &gt; bsp &gt; Src</p>"},{"location":"BSP/dir_160128b01eb7e6b2a554f83ab5d45f5a/#files","title":"Files","text":"Type Name file ADC.c file CAN.c file UART.c <p>The documentation for this class was generated from the following file <code>bsp/Src/</code></p>"},{"location":"BSP/_a_d_c_8c/","title":"File ADC.c","text":"<p>FileList &gt; bsp &gt; Src &gt; ADC.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ADC.h\"</code></li> </ul>"},{"location":"BSP/_a_d_c_8c/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t adc_err_code   = <code>0</code>"},{"location":"BSP/_a_d_c_8c/#public-functions","title":"Public Functions","text":"Type Name void HAL_ADC_ConvCpltCallback (ADC_HandleTypeDef * h)  void HAL_ADC_ErrorCallback (ADC_HandleTypeDef * h)  void HAL_ADC_MspDeInit (ADC_HandleTypeDef * h)  __weak void HAL_ADC_MspGPIOInit ()  void HAL_ADC_MspInit (ADC_HandleTypeDef * h)  adc_status_t adc_deinit (ADC_HandleTypeDef * h)  adc_status_t adc_init (ADC_InitTypeDef init, ADC_HandleTypeDef * h)  adc_status_t adc_read (uint32_t channel, uint32_t samplingTime, ADC_HandleTypeDef * h, QueueHandle_t * q)"},{"location":"BSP/_a_d_c_8c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BSP/_a_d_c_8c/#variable-adc_err_code","title":"variable adc_err_code","text":"<pre><code>uint32_t adc_err_code;\n</code></pre>"},{"location":"BSP/_a_d_c_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/_a_d_c_8c/#function-hal_adc_convcpltcallback","title":"function HAL_ADC_ConvCpltCallback","text":"<pre><code>void HAL_ADC_ConvCpltCallback (\n    ADC_HandleTypeDef * h\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-hal_adc_errorcallback","title":"function HAL_ADC_ErrorCallback","text":"<pre><code>void HAL_ADC_ErrorCallback (\n    ADC_HandleTypeDef * h\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-hal_adc_mspdeinit","title":"function HAL_ADC_MspDeInit","text":"<pre><code>void HAL_ADC_MspDeInit (\n    ADC_HandleTypeDef * h\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-hal_adc_mspgpioinit","title":"function HAL_ADC_MspGPIOInit","text":"<pre><code>__weak void HAL_ADC_MspGPIOInit () \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-hal_adc_mspinit","title":"function HAL_ADC_MspInit","text":"<pre><code>void HAL_ADC_MspInit (\n    ADC_HandleTypeDef * h\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-adc_deinit","title":"function adc_deinit","text":"<pre><code>adc_status_t adc_deinit (\n    ADC_HandleTypeDef * h\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-adc_init","title":"function adc_init","text":"<pre><code>adc_status_t adc_init (\n    ADC_InitTypeDef init,\n    ADC_HandleTypeDef * h\n) \n</code></pre>"},{"location":"BSP/_a_d_c_8c/#function-adc_read","title":"function adc_read","text":"<pre><code>adc_status_t adc_read (\n    uint32_t channel,\n    uint32_t samplingTime,\n    ADC_HandleTypeDef * h,\n    QueueHandle_t * q\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Src/ADC.c</code></p>"},{"location":"BSP/_a_d_c_8c_source/","title":"File ADC.c","text":"<p>File List &gt; bsp &gt; Src &gt; ADC.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"ADC.h\"\n\n// Define Queue Handles\n#ifdef ADC1\nstatic ADC_HandleTypeDef hadc1_ = {.Instance = ADC1};\nADC_HandleTypeDef* hadc1 = &amp;hadc1_;\nQueueHandle_t* adc1_q;\n#endif\n\n#ifdef ADC2\nstatic ADC_HandleTypeDef hadc2_ = {.Instance = ADC2};\nADC_HandleTypeDef* hadc2 = &amp;hadc2_;\nQueueHandle_t* adc2_q;\n#endif\n\n#ifdef ADC3\nstatic ADC_HandleTypeDef hadc3_ = {.Instance = ADC3};\nADC_HandleTypeDef* hadc3 = &amp;hadc3_;\nQueueHandle_t* adc3_q;\n#endif\n\n#ifdef STM32F4xx\n#ifndef ADC_PRIO\n#define ADC_PRIO 5\n#endif\n#endif\n\n#ifdef STM32L4xx\n#ifndef ADC1_PRIO\n#define ADC1_PRIO 5\n#endif\n\n#ifndef ADC2_PRIO\n#define ADC2_PRIO 5\n#endif\n\n#ifndef ADC3_PRIO\n#define ADC3_PRIO 5\n#endif\n#endif\n\n// Hardware ADC error code\nuint32_t adc_err_code = 0;\n\nadc_status_t adc_init(ADC_InitTypeDef init, ADC_HandleTypeDef* h) {\n    // Initalize ADC\n    h-&gt;Init = init;\n    if (HAL_ADC_Init(h) != HAL_OK) return ADC_INIT_FAIL;\n\n    return ADC_OK;\n}\n\nadc_status_t adc_deinit(ADC_HandleTypeDef *h) {\n    // Deinit ADC at specific handle\n    if (HAL_ADC_DeInit(h) != HAL_OK) return ADC_DEINIT_FAIL;\n\n    return ADC_OK;\n} \n\n\nadc_status_t adc_read(uint32_t channel, uint32_t samplingTime, ADC_HandleTypeDef *h, QueueHandle_t *q) {\n    ADC_ChannelConfTypeDef sConfig = {\n        .Channel = channel,\n        .Rank = 1,\n        .SamplingTime = samplingTime\n    }; \n\n    // Queue Arbitration for later\n    #ifdef ADC1\n    if (h-&gt;Instance == ADC1) adc1_q = q;\n    #endif\n    #ifdef ADC2\n    if (h-&gt;Instance == ADC2) adc2_q = q;\n    #endif\n    #ifdef ADC3\n    if (h-&gt;Instance == ADC3) adc3_q = q;\n    #endif\n\n    // Check Queue Full\n    if (uxQueueSpacesAvailable(*q) == 0) {\n        return ADC_QUEUE_FULL;\n    }\n    // Configure Channel\n    if (HAL_ADC_ConfigChannel(h, &amp;sConfig) != HAL_OK) {\n        return ADC_CHANNEL_CONFIG_FAIL;\n    }\n    // Trigger Interrupt\n    HAL_StatusTypeDef adc_it_stat = HAL_ADC_Start_IT(h);\n\n    // Handling\n    switch (adc_it_stat) {\n        case HAL_BUSY:\n            return ADC_INTERRUPT_BUSY;\n            break;\n        case HAL_TIMEOUT:\n            return ADC_INTERRUPT_TIMEOUT;\n            break;\n        case HAL_ERROR:\n            return ADC_INTERRUPT_ERROR;\n            break;\n        default: break;\n    }\n\n    return ADC_OK; \n}\n\n\nvoid HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *h) {\n    /*\n    Interrupt triggers this callback when the conversion is complete\n    */ \n    BaseType_t higherPriorityTaskWoken = pdFALSE;\n    QueueHandle_t* q = NULL; // Queue will never be null by the call [placeholder]\n    int rawVal;\n\n    if (h-&gt;Instance == ADC1) q = adc1_q;\n    #ifdef ADC2\n    if (h-&gt;Instance == ADC2) q = adc2_q;\n    #endif\n    #ifdef ADC3\n    if (h-&gt;Instance == ADC3) q = adc3_q;\n    #endif\n\n    rawVal = HAL_ADC_GetValue(h);\n    xQueueSendFromISR(*q, &amp;rawVal, &amp;higherPriorityTaskWoken);\n\n    portYIELD_FROM_ISR(higherPriorityTaskWoken);\n}\n\n__weak void HAL_ADC_MspGPIOInit() {\n    // GPIO --- Instanstiate PA3\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    GPIO_InitTypeDef input =  {\n        .Pin = GPIO_PIN_3,\n        .Mode = GPIO_MODE_ANALOG,\n        .Pull = GPIO_NOPULL,\n    };\n\n    HAL_GPIO_Init(GPIOA, &amp;input);\n}\n\n#if defined(STM32L4xx)\nstatic inline void HAL_ADC_MspL4Init(ADC_HandleTypeDef *h) {\n    HAL_ADC_MspGPIOInit();\n\n    // L4 Clock\n    __HAL_RCC_ADC_CLK_ENABLE();\n\n    // L4 w/ one ADC\n    #if !defined(ADC2) &amp;&amp; !defined(ADC3)\n    HAL_NVIC_SetPriority(ADC1_IRQn, ADC1_PRIO, 0);\n    HAL_NVIC_EnableIRQ(ADC1_IRQn);\n\n    // L4 w/ more than one ADC\n    #elif defined(ADC2)\n    HAL_NVIC_SetPriority(ADC1_2_IRQn, ADC2_PRIO, 0);\n    HAL_NVIC_EnableIRQ(ADC1_2_IRQn);\n\n    // L4 w/ more than one ADC\n    #elif defined(ADC3)\n    HAL_NVIC_SetPriority(ADC3_IRQn, ADC3_PRIO, 0);\n    HAL_NVIC_EnableIRQ(ADC3_IRQn);\n\n    #endif\n}\n#endif\n\n#if defined(STM32F4xx)\nstatic inline void HAL_ADC_MspF4Init(ADC_HandleTypeDef *h) {\n    // GPIO Init\n    HAL_ADC_MspGPIOInit();\n\n    // F4 Clock\n    if (h-&gt;Instance == ADC1) __HAL_RCC_ADC1_CLK_ENABLE();\n\n    #ifdef ADC2\n    if (h-&gt;Instance == ADC2) __HAL_RCC_ADC2_CLK_ENABLE();\n    #endif\n\n    #ifdef ADC3\n    if (h-&gt;Instance == ADC3)__HAL_RCC_ADC3_CLK_ENABLE();\n    #endif\n\n    HAL_NVIC_SetPriority(ADC_IRQn, ADC_PRIO, 0);\n    HAL_NVIC_EnableIRQ(ADC_IRQn);\n}\n#endif\n\n#if defined(STM32L4xx)\nstatic inline void HAL_ADC_MspL4DeInit(ADC_HandleTypeDef *h) {\n    // GPIO Init\n\n\n    // L4 Clock\n    __HAL_RCC_ADC_CLK_DISABLE();\n\n    // L4 w/ one ADC\n    #if !defined(ADC2) &amp;&amp; !defined(ADC3)\n    HAL_NVIC_DisableIRQ(ADC1_IRQn);\n\n    // L4 w/ more than one ADC\n    #elif defined(ADC2)\n    HAL_NVIC_DisableIRQ(ADC1_2_IRQn);\n\n    // L4 w/ more than one ADC\n    #elif defined(ADC3)\n    HAL_NVIC_DisableIRQ(ADC3_IRQn);\n\n    #endif\n}\n#endif\n\n#if defined(STM32F4xx)\nstatic inline void HAL_ADC_MspF4DeInit(ADC_HandleTypeDef *h) {\n    if (h-&gt;Instance == ADC1) __HAL_RCC_ADC1_CLK_DISABLE();\n\n    #ifdef ADC2\n    if (h-&gt;Instance == ADC2) __HAL_RCC_ADC2_CLK_DISABLE();\n    #endif\n\n    #ifdef ADC3\n    if (h-&gt;Instance == ADC3)__HAL_RCC_ADC3_CLK_DISABLE();\n    #endif\n\n    HAL_NVIC_DisableIRQ(ADC_IRQn);\n}\n#endif\n\nvoid HAL_ADC_MspInit(ADC_HandleTypeDef *h) {\n    // L4\n    #ifdef STM32L4xx\n    HAL_ADC_MspL4Init(h);\n    #endif\n\n    // F4\n    #ifdef STM32F4xx\n    HAL_ADC_MspF4Init(h);\n    #endif\n}\n\nvoid HAL_ADC_MspDeInit(ADC_HandleTypeDef *h) {\n    // L4\n    #ifdef STM32L4xx\n    HAL_ADC_MspL4DeInit(h);\n    #endif\n\n    // F4\n    #ifdef STM32F4xx\n    HAL_ADC_MspF4DeInit(h);\n    #endif\n}\n\n#if defined(STM32L4xx)\n#ifdef ADC1_2_IRQHandler\nvoid ADC1_2_IRQHandler() {\n    if (ADC_FLAG_EOC &amp; ADC1-&gt;ISR) {\n        HAL_ADC_IRQHandler(hadc1);\n    }\n    #ifdef ADC2\n    else if (ADC_FLAG_EOC &amp; ADC2-&gt;ISR) {\n        HAL_ADC_IRQHandler(hadc2);\n    }\n    #endif\n}\n#endif\n\n#ifdef ADC1_IRQHandler\nvoid ADC1_IRQHandler() {\n    // L4 IRQ Handler\n\n    if (ADC_FLAG_EOC &amp; ADC1-&gt;ISR) {\n        HAL_ADC_IRQHandler(hadc1);\n    }\n}\n#endif\n\n#ifdef ADC3\nvoid ADC3_IRQHandler() {\n    if (ADC_FLAG_EOC &amp; ADC3-&gt;ISR) {\n        HAL_ADC_IRQHandler(hadc3);\n    }\n}\n#endif\n#endif\n\n#if defined(STM32F4xx)\nvoid ADC_IRQHandler() {\n    // F4 IRQ Handler \n\n    if (ADC_FLAG_EOC &amp; ADC1-&gt;SR) {\n        HAL_ADC_IRQHandler(hadc1);\n    }\n    #ifdef ADC2\n    else if (ADC_FLAG_EOC &amp; ADC2-&gt;SR) {\n        HAL_ADC_IRQHandler(hadc2);\n    }\n    #endif\n    #ifdef ADC3\n    if (ADC_FLAG_EOC &amp; ADC3-&gt;SR) {\n        HAL_ADC_IRQHandler(hadc3);\n    }\n    #endif\n}\n#endif\n\nvoid HAL_ADC_ErrorCallback(ADC_HandleTypeDef *h) {\n    adc_err_code = HAL_ADC_GetError(h);\n\n    // retry \n    HAL_ADC_Stop_IT(h);\n    HAL_ADC_Start_IT(h);\n}\n</code></pre>"},{"location":"BSP/_c_a_n_8c/","title":"File CAN.c","text":"<p>FileList &gt; bsp &gt; Src &gt; CAN.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CAN.h\"</code></li> <li><code>#include \"queue_ex.h\"</code></li> </ul>"},{"location":"BSP/_c_a_n_8c/#classes","title":"Classes","text":"Type Name struct recv_entry_t struct rx_payload_t struct tx_payload_t"},{"location":"BSP/_c_a_n_8c/#public-functions","title":"Public Functions","text":"Type Name void HAL_CAN_MspDeInit (CAN_HandleTypeDef * hcan)  void HAL_CAN_MspInit (CAN_HandleTypeDef * hcan)  void HAL_CAN_RxFifo0MsgPendingCallback (CAN_HandleTypeDef * hcan)  void HAL_CAN_TxMailbox0CompleteCallback (CAN_HandleTypeDef * hcan)  void HAL_CAN_TxMailbox1CompleteCallback (CAN_HandleTypeDef * hcan)  void HAL_CAN_TxMailbox2CompleteCallback (CAN_HandleTypeDef * hcan)  can_status_t can_deinit (CAN_HandleTypeDef * handle)  can_status_t can_init (CAN_HandleTypeDef * handle, CAN_FilterTypeDef * filter)  can_status_t can_recv (CAN_HandleTypeDef * handle, uint16_t id, CAN_RxHeaderTypeDef * header, uint8_t data, TickType_t delay_ticks)  can_status_t can_send (CAN_HandleTypeDef * handle, const CAN_TxHeaderTypeDef * header, const uint8_t data, TickType_t delay_ticks)  can_status_t can_start (CAN_HandleTypeDef * handle)  can_status_t can_stop (CAN_HandleTypeDef * handle)"},{"location":"BSP/_c_a_n_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name void HAL_CAN_MspF4Init (CAN_HandleTypeDef * hcan)  void HAL_CAN_MspL4Init (CAN_HandleTypeDef * hcan)  void transmit (CAN_HandleTypeDef * handle)"},{"location":"BSP/_c_a_n_8c/#macros","title":"Macros","text":"Type Name define DATA_SIZE <code>(8)</code>"},{"location":"BSP/_c_a_n_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/_c_a_n_8c/#function-hal_can_mspdeinit","title":"function HAL_CAN_MspDeInit","text":"<pre><code>void HAL_CAN_MspDeInit (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_mspinit","title":"function HAL_CAN_MspInit","text":"<pre><code>void HAL_CAN_MspInit (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_rxfifo0msgpendingcallback","title":"function HAL_CAN_RxFifo0MsgPendingCallback","text":"<pre><code>void HAL_CAN_RxFifo0MsgPendingCallback (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_txmailbox0completecallback","title":"function HAL_CAN_TxMailbox0CompleteCallback","text":"<pre><code>void HAL_CAN_TxMailbox0CompleteCallback (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_txmailbox1completecallback","title":"function HAL_CAN_TxMailbox1CompleteCallback","text":"<pre><code>void HAL_CAN_TxMailbox1CompleteCallback (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_txmailbox2completecallback","title":"function HAL_CAN_TxMailbox2CompleteCallback","text":"<pre><code>void HAL_CAN_TxMailbox2CompleteCallback (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_deinit","title":"function can_deinit","text":"<pre><code>can_status_t can_deinit (\n    CAN_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_init","title":"function can_init","text":"<pre><code>can_status_t can_init (\n    CAN_HandleTypeDef * handle,\n    CAN_FilterTypeDef * filter\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_recv","title":"function can_recv","text":"<pre><code>can_status_t can_recv (\n    CAN_HandleTypeDef * handle,\n    uint16_t id,\n    CAN_RxHeaderTypeDef * header,\n    uint8_t data,\n    TickType_t delay_ticks\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_send","title":"function can_send","text":"<pre><code>can_status_t can_send (\n    CAN_HandleTypeDef * handle,\n    const CAN_TxHeaderTypeDef * header,\n    const uint8_t data,\n    TickType_t delay_ticks\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_start","title":"function can_start","text":"<pre><code>can_status_t can_start (\n    CAN_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-can_stop","title":"function can_stop","text":"<pre><code>can_status_t can_stop (\n    CAN_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"BSP/_c_a_n_8c/#function-hal_can_mspf4init","title":"function HAL_CAN_MspF4Init","text":"<pre><code>static inline void HAL_CAN_MspF4Init (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-hal_can_mspl4init","title":"function HAL_CAN_MspL4Init","text":"<pre><code>static inline void HAL_CAN_MspL4Init (\n    CAN_HandleTypeDef * hcan\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#function-transmit","title":"function transmit","text":"<pre><code>static void transmit (\n    CAN_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_c_a_n_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"BSP/_c_a_n_8c/#define-data_size","title":"define DATA_SIZE","text":"<pre><code>#define DATA_SIZE `(8)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Src/CAN.c</code></p>"},{"location":"BSP/_c_a_n_8c_source/","title":"File CAN.c","text":"<p>File List &gt; bsp &gt; Src &gt; CAN.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"CAN.h\"\n#include \"queue_ex.h\"\n\n// 8 for now unless extended payload is supported\n#define DATA_SIZE (8)\n\n// entries in queues\ntypedef struct {\n  CAN_TxHeaderTypeDef header;\n  uint8_t data[DATA_SIZE];\n} tx_payload_t;\n\ntypedef struct {\n  CAN_RxHeaderTypeDef header;\n  uint8_t data[DATA_SIZE];\n} rx_payload_t;\n\n// metadata for recieve queues\ntypedef struct {\n  uint16_t id;\n  uint16_t size;\n  QueueHandle_t queue;\n  uint8_t* storage;\n  bool circular;\n  StaticQueue_t buffer;\n} recv_entry_t;\n\n#ifdef CAN1\n// fallback can1 send queue size\n#ifndef CAN1_SEND_QUEUE_SIZE\n#define CAN1_SEND_QUEUE_SIZE (10)\n#endif\n\n// can1 handle\nstatic CAN_HandleTypeDef hcan1_ = {.Instance = CAN1};\nCAN_HandleTypeDef* hcan1 = &amp;hcan1_;\n\n// can1 send queue\nstatic QueueHandle_t can1_send_queue = NULL;\nstatic StaticQueue_t can1_send_queue_buffer;\nstatic uint8_t\n    can1_send_queue_storage[CAN1_SEND_QUEUE_SIZE * sizeof(tx_payload_t)];\n\n#if __has_include(\"can1_recv_entries.h\")\n// create can1 recv queue storage\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_) \\\n  static uint8_t can1_recv_queue_storage_##ID_[SIZE_ * sizeof(rx_payload_t)];\n\n#include \"can1_recv_entries.h\"\n\n#undef CAN_RECV_ENTRY\n\n// create can1 recv queue array\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_)      \\\n  {.id = (ID_),                         \\\n   .size = (SIZE_),                     \\\n   .queue = NULL,                       \\\n   .storage = can1_recv_queue_storage_##ID_, \\\n   .circular = (CIRCULAR_), \\\n   .buffer = {{0}}},\n\nstatic recv_entry_t can1_recv_entries[] = {\n#include \"can1_recv_entries.h\"\n};\n#undef CAN_RECV_ENTRY\n\n// calculate amount of can1 recv entries\nstatic const uint32_t can1_recv_entry_count =\n    sizeof(can1_recv_entries) / sizeof(can1_recv_entries[0]);\n\n#else /* can1_recv_entries.h */\n// create can1 recv queue array\nstatic recv_entry_t can1_recv_entries[] = {};\n// calculate amount of can1 recv entries\nstatic const uint32_t can1_recv_entry_count = 0;\n#endif /* can1_recv_entries.h */\n#endif /* CAN1 */\n\n#ifdef CAN2\n// fallback can2 send queue size\n#ifndef CAN2_SEND_QUEUE_SIZE\n#define CAN2_SEND_QUEUE_SIZE (10)\n#endif\n\n// can2 handle\nstatic CAN_HandleTypeDef hcan2_ = {.Instance = CAN2};\nCAN_HandleTypeDef* hcan2 = &amp;hcan2_;\n\n// can2 send queue\nstatic QueueHandle_t can2_send_queue = NULL;\nstatic StaticQueue_t can2_send_queue_buffer;\nstatic uint8_t\n    can2_send_queue_storage[CAN2_SEND_QUEUE_SIZE * sizeof(tx_payload_t)];\n\n#if __has_include(\"can2_recv_entries.h\")\n// create can2 recv queue storage\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_) \\\n  static uint8_t can2_recv_queue_storage_##ID_[SIZE_ * sizeof(rx_payload_t)];\n\n#include \"can2_recv_entries.h\"\n\n#undef CAN_RECV_ENTRY\n\n// create can2 recv queue array\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_)      \\\n  {.id = (ID_),                         \\\n   .size = (SIZE_),                     \\\n   .queue = NULL,                       \\\n   .storage = can2_recv_queue_storage_##ID_, \\\n   .circular = (CIRCULAR_), \\\n   .buffer = {{0}}},\n\nstatic recv_entry_t can2_recv_entries[] = {\n#include \"can2_recv_entries.h\"\n};\n#undef CAN_RECV_ENTRY\n\n// calculate amount of can2 recv entries\nstatic const uint32_t can2_recv_entry_count =\n    sizeof(can2_recv_entries) / sizeof(can2_recv_entries[0]);\n\n#else /* can2_recv_entries.h */\n// create can2 recv queue array\nstatic recv_entry_t can2_recv_entries[] = {};\n// calculate amount of can2 recv entries\nstatic const uint32_t can2_recv_entry_count = 0;\n#endif /* can2_recv_entries.h */\n#endif /* CAN2 */\n\n#ifdef CAN3\n// fallback can3 send queue size\n#ifndef CAN3_SEND_QUEUE_SIZE\n#define CAN3_SEND_QUEUE_SIZE (10)\n#endif\n\n// can3 handle\nstatic CAN_HandleTypeDef hcan3_ = {.Instance = CAN3};\nCAN_HandleTypeDef* hcan3 = &amp;hcan3_;\n\n// can3 send queue\nstatic QueueHandle_t can3_send_queue = NULL;\nstatic StaticQueue_t can3_send_queue_buffer;\nstatic uint8_t\n    can3_send_queue_storage[CAN3_SEND_QUEUE_SIZE * sizeof(tx_payload_t)];\n\n#if __has_include(\"can3_recv_entries.h\")\n// create recv queue storage\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_) \\\n  static uint8_t recv_queue_storage_##ID_[SIZE_ * sizeof(rx_payload_t)];\n\n#include \"can3_recv_entries.h\"\n\n#undef CAN_RECV_ENTRY\n\n// create can3 recv queue array\n#define CAN_RECV_ENTRY(ID_, SIZE_, CIRCULAR_)      \\\n  {.id = (ID_),                         \\\n   .size = (SIZE_),                     \\\n   .queue = NULL,                       \\\n   .storage = recv_queue_storage_##ID_, \\\n   .circular = (CIRCULAR_), \\\n   .buffer = {{0}}},\n\nstatic recv_entry_t can3_recv_entries[] = {\n#include \"can3_recv_entries.h\"\n};\n#undef CAN_RECV_ENTRY\n\n// calculate amount of can3 recv entries\nstatic const uint32_t can3_recv_entry_count =\n    sizeof(can3_recv_entries) / sizeof(can3_recv_entries[0]);\n\n#else /* can3_recv_entries.h */\n// create can3 recv queue array\nstatic recv_entry_t can3_recv_entries[] = {};\n// calculate amount of can3 recv entries\nstatic const uint32_t can3_recv_entry_count = 0;\n#endif /* can3_recv_entries.h */\n#endif /* CAN3 */\n\nstatic inline void HAL_CAN_MspF4Init(CAN_HandleTypeDef* hcan){\n  GPIO_InitTypeDef init = {0};\n\n  // CAN1\n  if (hcan-&gt;Instance == CAN1) {\n    // enable clocks\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    /* enable gpio\n    PA11 -&gt; CAN1_RX\n    PA12 -&gt; CAN1_TX\n    */\n    init.Pin = GPIO_PIN_11;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_PULLUP;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN1;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n\n    init.Pin = GPIO_PIN_12;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_NOPULL;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN1;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n  }\n\n  // CAN2\n  #ifdef CAN2\n  else if (hcan-&gt;Instance == CAN2) {\n    // enable clocks\n    __HAL_RCC_GPIOB_CLK_ENABLE();\n\n    /* enable gpio\n    PB12 -&gt; CAN2_RX\n    PB13 -&gt; CAN2_TX\n    */\n    init.Pin = GPIO_PIN_12;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_PULLUP;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN2;\n    HAL_GPIO_Init(GPIOB, &amp;init);\n\n    init.Pin = GPIO_PIN_13;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_NOPULL;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN2;\n    HAL_GPIO_Init(GPIOB, &amp;init);\n  }\n  #endif /* CAN2 */\n\n  // CAN3\n  #ifdef CAN3\n  else if (hcan-&gt;Instance == CAN3) {\n    // enable clocks\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    /* enable gpio\n    PA8  -&gt; CAN3_RX\n    PA15 -&gt; CAN3_TX\n    */\n    init.Pin = GPIO_PIN_8;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_PULLUP;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF11_CAN3;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n\n    init.Pin = GPIO_PIN_15;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_NOPULL;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF11_CAN3;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n  }\n  #endif /* CAN3 */\n}\n\n// CAN MSP deinit\nvoid HAL_CAN_MspDeInit(CAN_HandleTypeDef* hcan) {\n  // CAN1\n  if (hcan-&gt;Instance == CAN1) {\n    // disable clocks\n    __HAL_RCC_CAN1_CLK_DISABLE();\n\n    /* disable gpio\n    PA11 -&gt; CAN1_RX\n    PA12 -&gt; CAN1_TX\n    */\n    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_11);\n    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_12);\n\n    // disable interrupts\n    HAL_NVIC_DisableIRQ(CAN1_TX_IRQn);\n    HAL_NVIC_DisableIRQ(CAN1_RX0_IRQn);\n  }\n\n  // CAN2\n  #ifdef CAN2\n  else if (hcan-&gt;Instance == CAN2) {\n    // disable clocks\n    __HAL_RCC_CAN2_CLK_DISABLE();\n\n    /* disable gpio\n    PB12 -&gt; CAN2_RX\n    PB13 -&gt; CAN2_TX\n    */\n    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_12);\n    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_13);\n\n    // disable interrupts\n    HAL_NVIC_DisableIRQ(CAN2_TX_IRQn);\n    HAL_NVIC_DisableIRQ(CAN2_RX0_IRQn);\n  }\n  #endif /* CAN2 */\n\n  // CAN3\n  #ifdef CAN3\n  else if (hcan-&gt;Instance == CAN3) {\n    // disable clocks\n    __HAL_RCC_CAN3_CLK_DISABLE();\n\n    /* disable gpio\n    PA8  -&gt; CAN3_RX\n    PB15 -&gt; CAN3_TX\n    */\n    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_8);\n    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_15);\n\n    // disable interrupts\n    HAL_NVIC_DisableIRQ(CAN3_TX_IRQn);\n    HAL_NVIC_DisableIRQ(CAN3_RX0_IRQn);\n  }\n  #endif /* CAN3 */\n}\n\nstatic inline void HAL_CAN_MspL4Init(CAN_HandleTypeDef* hcan){\n  GPIO_InitTypeDef init = {0};\n  // CAN1\n  if (hcan-&gt;Instance == CAN1) {\n    // enable clocks\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    /* enable gpio\n    PA11 -&gt; CAN1_RX\n    PA12 -&gt; CAN1_TX\n    */\n    init.Pin = GPIO_PIN_11;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_PULLUP;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN1;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n\n    init.Pin = GPIO_PIN_12;\n    init.Mode = GPIO_MODE_AF_PP;\n    init.Pull = GPIO_NOPULL;\n    init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    init.Alternate = GPIO_AF9_CAN1;\n    HAL_GPIO_Init(GPIOA, &amp;init);\n  }\n}\n\n// CAN MSP init\nvoid HAL_CAN_MspInit(CAN_HandleTypeDef* hcan) {\n  IRQn_Type txIRQ = 0;\n  IRQn_Type rxIRQ = 0;\n  if (hcan-&gt;Instance == CAN1) {\n    __HAL_RCC_CAN1_CLK_ENABLE();\n    txIRQ = CAN1_TX_IRQn;\n    rxIRQ = CAN1_RX0_IRQn;\n  }\n  #ifdef CAN2\n  else if(hcan-&gt;Instance == CAN2){\n    __HAL_RCC_CAN2_CLK_ENABLE();\n    txIRQ = CAN2_TX_IRQn;\n    rxIRQ = CAN2_RX0_IRQn;\n  }\n  #endif\n  #ifdef CAN3\n  else if(hcan-&gt;Instance == CAN3){\n    __HAL_RCC_CAN3_CLK_ENABLE();\n    txIRQ = CAN3_TX_IRQn;\n    rxIRQ = CAN3_RX0_IRQn;\n  }\n  #endif\n\n  // configure GPIO pins for CAN\n  #if defined(STM32F4xx)\n  HAL_CAN_MspF4Init(hcan);\n  #elif defined(STM32L4xx)\n  HAL_CAN_MspL4Init(hcan);\n  #endif\n\n  // enable can interrupts\n  if(txIRQ !=0 &amp;&amp; rxIRQ !=0){\n    HAL_NVIC_SetPriority(txIRQ, 5, 0);\n    HAL_NVIC_EnableIRQ(txIRQ);\n    HAL_NVIC_SetPriority(rxIRQ, 5, 0);\n    HAL_NVIC_EnableIRQ(rxIRQ);\n  }\n}\n\ncan_status_t can_init(CAN_HandleTypeDef* handle, CAN_FilterTypeDef* filter) {\n  // CAN1\n  if (handle-&gt;Instance == CAN1) {\n    // init queues\n    can1_send_queue =\n        xQueueCreateStatic(CAN1_SEND_QUEUE_SIZE, sizeof(tx_payload_t),\n                           can1_send_queue_storage, &amp;can1_send_queue_buffer);\n    for (int i = 0; i &lt; can1_recv_entry_count; i++) {\n      can1_recv_entries[i].queue = xQueueCreateStatic(\n          can1_recv_entries[i].size, sizeof(rx_payload_t),\n          can1_recv_entries[i].storage, &amp;can1_recv_entries[i].buffer);\n    }\n  }\n\n  // CAN2\n  #ifdef CAN2\n  else if (handle-&gt;Instance == CAN2) {\n    // init queues\n    can2_send_queue =\n        xQueueCreateStatic(CAN2_SEND_QUEUE_SIZE, sizeof(tx_payload_t),\n                           can2_send_queue_storage, &amp;can2_send_queue_buffer);\n    for (int i = 0; i &lt; can2_recv_entry_count; i++) {\n      can2_recv_entries[i].queue = xQueueCreateStatic(\n          can2_recv_entries[i].size, sizeof(rx_payload_t),\n          can2_recv_entries[i].storage, &amp;can2_recv_entries[i].buffer);\n    }\n  }\n  #endif /* CAN2 */\n\n  // CAN3\n  #ifdef CAN3\n  else if (handle-&gt;Instance == CAN3) {\n    // init queues\n    can3_send_queue =\n        xQueueCreateStatic(CAN3_SEND_QUEUE_SIZE, sizeof(tx_payload_t),\n                           can3_send_queue_storage, &amp;can3_send_queue_buffer);\n    for (int i = 0; i &lt; can3_recv_entry_count; i++) {\n      can3_recv_entries[i].queue = xQueueCreateStatic(\n          can3_recv_entries[i].size, sizeof(rx_payload_t),\n          can3_recv_entries[i].storage, &amp;can3_recv_entries[i].buffer);\n    }\n  }\n  #endif /* CAN3 */\n\n  else {\n    return CAN_ERR;\n  }\n\n  // init HAL\n  if (HAL_CAN_Init(handle) != HAL_OK) {\n    return CAN_ERR;\n  }\n\n  // init filter\n  if (HAL_CAN_ConfigFilter(handle, filter) != HAL_OK) {\n    return CAN_ERR;\n  }\n\n  // enable interrupts\n  if (HAL_CAN_ActivateNotification(handle, CAN_IT_TX_MAILBOX_EMPTY) != HAL_OK) {\n    return CAN_ERR;\n  }\n  if (HAL_CAN_ActivateNotification(handle, CAN_IT_RX_FIFO0_MSG_PENDING) !=\n      HAL_OK) {\n    return CAN_ERR;\n  }\n\n  return CAN_OK;\n}\n\ncan_status_t can_deinit(CAN_HandleTypeDef* handle) {\n  // deinit HAL\n  if (HAL_CAN_DeInit(handle) != HAL_OK) {\n    return CAN_ERR;\n  }\n\n  // disable interrupts\n  if (HAL_CAN_DeactivateNotification(handle, CAN_IT_TX_MAILBOX_EMPTY) != HAL_OK) {\n    return CAN_ERR;\n  }\n  if (HAL_CAN_DeactivateNotification(handle, CAN_IT_RX_FIFO0_MSG_PENDING) !=\n      HAL_OK) {\n    return CAN_ERR;\n  }\n\n  return CAN_OK;\n}\n\ncan_status_t can_start(CAN_HandleTypeDef* handle) {\n  if (HAL_CAN_Start(handle) != HAL_OK) {\n    return CAN_ERR;\n  }\n\n  return CAN_OK;\n}\n\ncan_status_t can_stop(CAN_HandleTypeDef* handle) {\n  if (HAL_CAN_Stop(handle) != HAL_OK) {\n    return CAN_ERR;\n  }\n\n  return CAN_OK;\n}\n\ncan_status_t can_recv(CAN_HandleTypeDef* handle, uint16_t id,\n                      CAN_RxHeaderTypeDef* header, uint8_t data[],\n                      TickType_t delay_ticks) {\n  // recieve from queue matching id\n  rx_payload_t payload = {0};\n  bool valid_id = false;\n  // CAN1\n  if (handle-&gt;Instance == CAN1) {\n    for (int i = 0; i &lt; can1_recv_entry_count; i++) {\n      if (can1_recv_entries[i].id == id) {\n        valid_id = true;\n\n        // if delay_ticks == portMAX_DELAY thread blocks, \n        // other values of delay_ticks are delays\n        if (xQueueReceive(can1_recv_entries[i].queue, &amp;payload, delay_ticks) ==\n            errQUEUE_EMPTY) {\n          return CAN_EMPTY;\n        }\n\n        break;\n      }\n    }\n  }\n\n  // CAN2\n  #ifdef CAN2\n  else if (handle-&gt;Instance == CAN2) {\n    for (int i = 0; i &lt; can2_recv_entry_count; i++) {\n      if (can2_recv_entries[i].id == id) {\n        valid_id = true;\n\n        // if delay_ticks == portMAX_DELAY thread blocks, \n        // other values of delay_ticks are delays\n        if (xQueueReceive(can2_recv_entries[i].queue, &amp;payload, delay_ticks) ==\n            errQUEUE_EMPTY) {\n          return CAN_EMPTY;\n        }\n\n        break;\n      }\n    }\n  }\n  #endif /* CAN2 */\n\n  // CAN3\n  #ifdef CAN3\n  else if (handle-&gt;Instance == CAN3) {\n    for (int i = 0; i &lt; can3_recv_entry_count; i++) {\n      if (can3_recv_entries[i].id == id) {\n        valid_id = true;\n\n        // if delay_ticks == portMAX_DELAY thread blocks, \n        // other values of delay_ticks are delays\n        if (xQueueReceive(can3_recv_entries[i].queue, &amp;payload, delay_ticks) ==\n            errQUEUE_EMPTY) {\n          return CAN_EMPTY;\n        }\n\n        break;\n      }\n    }\n  }\n  #endif /* CAN3 */\n\n  else {\n    return CAN_ERR;\n  }\n\n  // decode payload if it is valid and message recieved\n  if (valid_id) {\n    *header = payload.header;\n    for (int i = 0; i &lt; DATA_SIZE; i++) {\n      data[i] = payload.data[i];\n    }\n\n    return CAN_RECV;\n\n  } else {\n    return CAN_ERR;\n  }\n}\n\ncan_status_t can_send(CAN_HandleTypeDef* handle,\n                      const CAN_TxHeaderTypeDef* header, const uint8_t data[],\n                      TickType_t delay_ticks) {\n\n  // disable interrupts (do not want race conditions\n  // on shared resource (mailbox) between threads and\n  // interrupt routines (TxComplete))\n  portENTER_CRITICAL();\n\n  // if transmit is inactive, put payload into mailbox\n  if (HAL_CAN_GetTxMailboxesFreeLevel(handle) &gt;= 1) {\n    uint32_t mailbox;\n    if (HAL_CAN_AddTxMessage(handle, header, data, &amp;mailbox) != HAL_OK) {\n      // disable interrupts\n      portEXIT_CRITICAL();\n\n      return CAN_ERR;\n    }\n\n    // disable interrupts\n    portEXIT_CRITICAL();\n  }\n  // otherwise, put into send queue\n  else {\n    // disable interrupts\n    portEXIT_CRITICAL();\n\n    tx_payload_t payload = {0};\n    payload.header = *header;\n    for (int i = 0; i &lt; DATA_SIZE; i++) {\n      payload.data[i] = data[i];\n    }\n\n    // CAN1\n    if (handle-&gt;Instance == CAN1) {\n      if (xQueueSend(can1_send_queue, &amp;payload, delay_ticks) != pdTRUE) {\n        return CAN_ERR;\n      }\n    }\n\n    // CAN2\n    #ifdef CAN2\n    else if (handle-&gt;Instance == CAN2) {\n      if (xQueueSend(can2_send_queue, &amp;payload, delay_ticks) != pdTRUE) {\n        return CAN_ERR;\n      }\n    }\n    #endif /* CAN2 */\n\n    // CAN3\n    #ifdef CAN3\n    else if (handle-&gt;Instance == CAN3) {\n      if (xQueueSend(can3_send_queue, &amp;payload, delay_ticks) != pdTRUE) {\n        return CAN_ERR;\n      }\n    }\n    #endif /* CAN3 */\n  }\n\n  return CAN_SENT;\n}\n\nstatic void transmit(CAN_HandleTypeDef* handle) {\n  tx_payload_t payload = {0};\n  BaseType_t higherPriorityTaskWoken = pdFALSE;\n\n  // receive data from send queue\n  bool success = false;\n  // CAN1\n  if (handle-&gt;Instance == CAN1) {\n    if (xQueueReceiveFromISR(can1_send_queue, &amp;payload,\n                             &amp;higherPriorityTaskWoken) == pdTRUE) {\n      success = true;\n    }\n  }\n\n  // CAN2\n  #ifdef CAN2\n  else if (handle-&gt;Instance == CAN2) {\n    if (xQueueReceiveFromISR(can2_send_queue, &amp;payload,\n                             &amp;higherPriorityTaskWoken) == pdTRUE) {\n      success = true;\n    }\n  }\n  #endif /* CAN2 */\n\n  // CAN3\n  #ifdef CAN3\n  else if (handle-&gt;Instance == CAN3) {\n    if (xQueueReceiveFromISR(can3_send_queue, &amp;payload,\n                             &amp;higherPriorityTaskWoken) == pdTRUE) {\n      success = true;\n    }\n  }\n  #endif /* CAN3 */\n\n  // add payload to mailbox\n  if (success) {\n    uint32_t mailbox;\n    if (HAL_CAN_AddTxMessage(handle, &amp;payload.header, payload.data, &amp;mailbox) != HAL_OK) {\n      // Handle transmission error (optional: log or retry mechanism)\n      // treated as lost packet for now\n    }\n  }\n\n  portYIELD_FROM_ISR(higherPriorityTaskWoken);\n}\n\nvoid HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef* hcan) {\n  transmit(hcan);\n}\n\nvoid HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef* hcan) {\n  transmit(hcan);\n}\n\nvoid HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef* hcan) {\n  transmit(hcan);\n}\n\nvoid HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef* hcan) {\n  rx_payload_t payload = {0};\n  BaseType_t higherPriorityTaskWoken = pdFALSE;\n\n  // recieve messages from queue till empty and put into recieve queues\n  while (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &amp;payload.header,\n                              payload.data) == HAL_OK) {\n    // CAN1\n    if (hcan-&gt;Instance == CAN1) {\n      for (int i = 0; i &lt; can1_recv_entry_count; i++) {\n        if (can1_recv_entries[i].id == payload.header.StdId) {\n          if (can1_recv_entries[i].circular){\n            xQueueSendCircularBufferFromISR(\n              can1_recv_entries[i].queue, \n              &amp;payload, \n              &amp;higherPriorityTaskWoken, \n              sizeof(rx_payload_t)\n            );\n          } else {\n            xQueueSendFromISR(can1_recv_entries[i].queue, &amp;payload,\n                            &amp;higherPriorityTaskWoken);\n          }\n      break;\n        }\n      }\n    }\n\n    // CAN2\n    #ifdef CAN2\n    else if (hcan-&gt;Instance == CAN2) {\n      for (int i = 0; i &lt; can2_recv_entry_count; i++) {\n        if (can2_recv_entries[i].id == payload.header.StdId) {\n          if (can2_recv_entries[i].circular){\n            xQueueSendCircularBufferFromISR(\n              can2_recv_entries[i].queue, \n              &amp;payload, \n              &amp;higherPriorityTaskWoken, \n              sizeof(rx_payload_t)\n            );\n          } else {\n            xQueueSendFromISR(can2_recv_entries[i].queue, &amp;payload,\n                            &amp;higherPriorityTaskWoken);\n          }\n      break;\n        }\n      }\n    }\n    #endif /* CAN2 */\n\n    // CAN3\n    #ifdef CAN3\n    if (hcan-&gt;Instance == CAN3) {\n      for (int i = 0; i &lt; can3_recv_entry_count; i++) {\n        if (can3_recv_entries[i].id == payload.header.StdId) {\n          if (can3_recv_entries[i].circular){\n            xQueueSendCircularBufferFromISR(\n              can3_recv_entries[i].queue, \n              &amp;payload, \n              &amp;higherPriorityTaskWoken, \n              sizeof(rx_payload_t)\n            );\n          } else {\n            xQueueSendFromISR(can3_recv_entries[i].queue, &amp;payload,\n                            &amp;higherPriorityTaskWoken);\n          }\n      break;\n        }\n      }\n    }\n    #endif /* CAN3 */\n  }\n\n  portYIELD_FROM_ISR(higherPriorityTaskWoken);\n}\n\n// CAN1\n#ifdef CAN1\nvoid CAN1_TX_IRQHandler(void) { HAL_CAN_IRQHandler(hcan1); }\nvoid CAN1_RX0_IRQHandler(void) { HAL_CAN_IRQHandler(hcan1); }\n#endif /* CAN1 */\n\n// CAN2\n#ifdef CAN2\nvoid CAN2_TX_IRQHandler(void) { HAL_CAN_IRQHandler(hcan2); }\nvoid CAN2_RX0_IRQHandler(void) { HAL_CAN_IRQHandler(hcan2); }\n#endif /* CAN2 */\n\n// CAN3\n#ifdef CAN3\nvoid CAN3_TX_IRQHandler(void) { HAL_CAN_IRQHandler(hcan3); }\nvoid CAN3_RX0_IRQHandler(void) { HAL_CAN_IRQHandler(hcan3); }\n#endif /* CAN3 */\n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/","title":"File UART.c","text":"<p>FileList &gt; bsp &gt; Src &gt; UART.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"UART.h\"</code></li> <li><code>#include &lt;string.h&gt;</code></li> </ul>"},{"location":"BSP/_u_a_r_t_8c/#classes","title":"Classes","text":"Type Name struct rx_payload_t struct tx_payload_t"},{"location":"BSP/_u_a_r_t_8c/#public-functions","title":"Public Functions","text":"Type Name void HAL_UART_MspDeInit (UART_HandleTypeDef * huart)  __weak void HAL_UART_MspGPIODeInit (UART_HandleTypeDef * huart)  __weak void HAL_UART_MspGPIOInit (UART_HandleTypeDef * huart)  void HAL_UART_MspInit (UART_HandleTypeDef * huart)  void HAL_UART_RxCpltCallback (UART_HandleTypeDef * huart)  void HAL_UART_TxCpltCallback (UART_HandleTypeDef * huart)  uart_status_t uart_deinit (UART_HandleTypeDef * handle) Deinitializes the UART peripheral. uart_status_t uart_init (UART_HandleTypeDef * handle) Initializes the UART peripheral. uart_status_t uart_recv (UART_HandleTypeDef * handle, uint8_t * data, uint8_t length, TickType_t delay_ticks) Reads data from the user-provided RX queue. uart_status_t uart_send (UART_HandleTypeDef * handle, const uint8_t * data, uint8_t length, TickType_t delay_ticks) Transmits data over UART. If transmission is in progress, data will be queued in internal TX queue."},{"location":"BSP/_u_a_r_t_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name bool is_uart_initialized (UART_HandleTypeDef * handle)"},{"location":"BSP/_u_a_r_t_8c/#macros","title":"Macros","text":"Type Name define DATA_SIZE <code>(1)</code> define UART_NVIC_PREEMPT_PRIO <code>(5)</code>"},{"location":"BSP/_u_a_r_t_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_mspdeinit","title":"function HAL_UART_MspDeInit","text":"<pre><code>void HAL_UART_MspDeInit (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_mspgpiodeinit","title":"function HAL_UART_MspGPIODeInit","text":"<pre><code>__weak void HAL_UART_MspGPIODeInit (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_mspgpioinit","title":"function HAL_UART_MspGPIOInit","text":"<pre><code>__weak void HAL_UART_MspGPIOInit (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_mspinit","title":"function HAL_UART_MspInit","text":"<pre><code>void HAL_UART_MspInit (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_rxcpltcallback","title":"function HAL_UART_RxCpltCallback","text":"<pre><code>void HAL_UART_RxCpltCallback (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-hal_uart_txcpltcallback","title":"function HAL_UART_TxCpltCallback","text":"<pre><code>void HAL_UART_TxCpltCallback (\n    UART_HandleTypeDef * huart\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#function-uart_deinit","title":"function uart_deinit","text":"<p>Deinitializes the UART peripheral. </p> <pre><code>uart_status_t uart_deinit (\n    UART_HandleTypeDef * handle\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>handle</code> pointer to the UART handle </li> </ul> <p>Returns:</p> <p>uart_status_t </p>"},{"location":"BSP/_u_a_r_t_8c/#function-uart_init","title":"function uart_init","text":"<p>Initializes the UART peripheral. </p> <pre><code>uart_status_t uart_init (\n    UART_HandleTypeDef * handle\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>handle</code> pointer to the UART handle </li> </ul> <p>Returns:</p> <p>uart_status_t </p>"},{"location":"BSP/_u_a_r_t_8c/#function-uart_recv","title":"function uart_recv","text":"<p>Reads data from the user-provided RX queue. </p> <pre><code>uart_status_t uart_recv (\n    UART_HandleTypeDef * handle,\n    uint8_t * data,\n    uint8_t length,\n    TickType_t delay_ticks\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>huart</code> pointer to the UART handle </li> <li><code>data</code> pointer to the data buffer that will be read into </li> <li><code>length</code> of the buffer that will be read </li> <li><code>delay_ticks</code> number of ticks to wait for data to be received </li> </ul> <p>Returns:</p> <p>uart_status_t </p>"},{"location":"BSP/_u_a_r_t_8c/#function-uart_send","title":"function uart_send","text":"<p>Transmits data over UART. If transmission is in progress, data will be queued in internal TX queue. </p> <pre><code>uart_status_t uart_send (\n    UART_HandleTypeDef * handle,\n    const uint8_t * data,\n    uint8_t length,\n    TickType_t delay_ticks\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>data</code> pointer to the data buffer that will be written/transmitted </li> <li><code>length</code> of the buffer that will be written/transmitted </li> <li><code>delay_ticks</code> number of ticks to wait for data to be transmitted </li> </ul> <p>Returns:</p> <p>uart_status_t </p>"},{"location":"BSP/_u_a_r_t_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"BSP/_u_a_r_t_8c/#function-is_uart_initialized","title":"function is_uart_initialized","text":"<pre><code>static bool is_uart_initialized (\n    UART_HandleTypeDef * handle\n) \n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"BSP/_u_a_r_t_8c/#define-data_size","title":"define DATA_SIZE","text":"<pre><code>#define DATA_SIZE `(1)`\n</code></pre>"},{"location":"BSP/_u_a_r_t_8c/#define-uart_nvic_preempt_prio","title":"define UART_NVIC_PREEMPT_PRIO","text":"<pre><code>#define UART_NVIC_PREEMPT_PRIO `(5)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>bsp/Src/UART.c</code></p>"},{"location":"BSP/_u_a_r_t_8c_source/","title":"File UART.c","text":"<p>File List &gt; bsp &gt; Src &gt; UART.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"UART.h\"\n#include &lt;string.h&gt;\n\n// Define the size of the data to be transmitted\n// Currently not used, as we send uint8_t directly\n// may need to be configured for support for packets less more than 8 bits\n#ifndef DATA_SIZE\n#define DATA_SIZE (1) // fallback to 1 byte\n#endif\n\n// Define the preemption priority for the interrupt\n#ifndef UART_NVIC_PREEMPT_PRIO\n#define UART_NVIC_PREEMPT_PRIO (5)\n#endif\n\ntypedef struct {\n    uint8_t data[DATA_SIZE]; // data to be transmitted, 1 byte\n} tx_payload_t;\n\ntypedef struct {\n    uint8_t data[DATA_SIZE]; // data received, 1 byte\n} rx_payload_t;\n\n#ifdef UART4\n// fallback UART4 TX queue size\n#ifndef UART4_TX_QUEUE_SIZE\n#define UART4_TX_QUEUE_SIZE (10)\n#endif\n\n// fallback UART4 RX queue size\n#ifndef UART4_RX_QUEUE_SIZE\n#define UART4_RX_QUEUE_SIZE (10)\n#endif\n\n//UART4 handle\nstatic UART_HandleTypeDef huart4_ = {.Instance = UART4};\nUART_HandleTypeDef* huart4 = &amp;huart4_;\n\n// UART4 TX queue\nstatic QueueHandle_t uart4_tx_queue = NULL;\nstatic StaticQueue_t uart4_tx_queue_buffer;\nstatic uint8_t uart4_tx_queue_storage[UART4_TX_QUEUE_SIZE * sizeof(tx_payload_t)]; \n\n\n// UART4 RX queue\nstatic QueueHandle_t uart4_rx_queue = NULL;\nstatic StaticQueue_t uart4_rx_queue_buffer;\nstatic uint8_t uart4_rx_queue_storage[UART4_RX_QUEUE_SIZE * sizeof(rx_payload_t)];  // Will be allocated based on queue_size in uart_init\n\n// UART4 RX buffer\n// An intermediate buffer of DATA_SIZE bytes to store received data before it is copied to the queue\nstatic rx_payload_t uart4_rx_buffer;\n\n#endif /* UART4 */\n\n#ifdef UART5\n// fallback UART5 TX queue size\n#ifndef UART5_TX_QUEUE_SIZE\n#define UART5_TX_QUEUE_SIZE (10)\n#endif\n\n// fallback UART5 RX queue size\n#ifndef UART5_RX_QUEUE_SIZE\n#define UART5_RX_QUEUE_SIZE (10)\n#endif\n\n// UART5 handle\nstatic UART_HandleTypeDef huart5_ = {.Instance = UART5};\nUART_HandleTypeDef* huart5 = &amp;huart5_;\n\n// UART5 TX queue\nstatic QueueHandle_t uart5_tx_queue = NULL;\nstatic StaticQueue_t uart5_tx_queue_buffer;\nstatic uint8_t uart5_tx_queue_storage[UART5_TX_QUEUE_SIZE * sizeof(tx_payload_t)];\n\n// UART5 RX queue\nstatic QueueHandle_t uart5_rx_queue = NULL;\nstatic StaticQueue_t uart5_rx_queue_buffer;\nstatic uint8_t uart5_rx_queue_storage[UART5_RX_QUEUE_SIZE * sizeof(rx_payload_t)];  // Will be allocated based on queue_size\n\n// UART5 RX buffer\n// An intermediate buffer of DATA_SIZE bytes to store received data before it is copied to the queue\nstatic rx_payload_t uart5_rx_buffer;\n\n#endif /* UART5 */\n\n#ifdef USART1\n// fallback USART1 TX queue size\n#ifndef USART1_TX_QUEUE_SIZE\n#define USART1_TX_QUEUE_SIZE (10)\n#endif\n\n// fallback USART1 RX queue size\n#ifndef USART1_RX_QUEUE_SIZE\n#define USART1_RX_QUEUE_SIZE (10)\n#endif\n\n//USART1 handle\nstatic UART_HandleTypeDef husart1_ = {.Instance = USART1};\nUART_HandleTypeDef* husart1 = &amp;husart1_;\n\n// USART1 TX queue\nstatic QueueHandle_t usart1_tx_queue = NULL;\nstatic StaticQueue_t usart1_tx_queue_buffer;\nstatic uint8_t usart1_tx_queue_storage[USART1_TX_QUEUE_SIZE * sizeof(tx_payload_t)]; \n\n\n// USART1 RX queue\nstatic QueueHandle_t usart1_rx_queue = NULL;\nstatic StaticQueue_t usart1_rx_queue_buffer;\nstatic uint8_t usart1_rx_queue_storage[USART1_RX_QUEUE_SIZE * sizeof(rx_payload_t)];  // Will be allocated based on queue_size in uart_init\n\n// USART1 RX buffer\n// An intermediate buffer of DATA_SIZE bytes to store received data before it is copied to the queue\nstatic rx_payload_t usart1_rx_buffer;\n\n#endif /* USART1 */\n\n#ifdef USART2\n// fallback USART2 TX queue size\n#ifndef USART2_TX_QUEUE_SIZE\n#define USART2_TX_QUEUE_SIZE (10)\n#endif\n\n// fallback USART2 RX queue size\n#ifndef USART2_RX_QUEUE_SIZE\n#define USART2_RX_QUEUE_SIZE (10)\n#endif\n\n//USART2 handle\nstatic UART_HandleTypeDef husart2_ = {.Instance = USART2};\nUART_HandleTypeDef* husart2 = &amp;husart2_;\n\n// USART2 TX queue\nstatic QueueHandle_t usart2_tx_queue = NULL;\nstatic StaticQueue_t usart2_tx_queue_buffer;\nstatic uint8_t usart2_tx_queue_storage[USART2_TX_QUEUE_SIZE * sizeof(tx_payload_t)]; \n\n\n// USART2 RX queue\nstatic QueueHandle_t usart2_rx_queue = NULL;\nstatic StaticQueue_t usart2_rx_queue_buffer;\nstatic uint8_t usart2_rx_queue_storage[USART2_RX_QUEUE_SIZE * sizeof(rx_payload_t)];  // Will be allocated based on queue_size in uart_init\n\n// USART2 RX buffer\n// An intermediate buffer of DATA_SIZE bytes to store received data before it is copied to the queue\nstatic rx_payload_t usart2_rx_buffer;\n\n#endif /* USART2 */\n\n#ifdef USART3\n// fallback USART3 TX queue size\n#ifndef USART3_TX_QUEUE_SIZE\n#define USART3_TX_QUEUE_SIZE (10)\n#endif\n\n// fallback USART3 RX queue size\n#ifndef USART3_RX_QUEUE_SIZE\n#define USART3_RX_QUEUE_SIZE (10)\n#endif\n\n//USART3 handle\nstatic UART_HandleTypeDef husart3_ = {.Instance = USART3};\nUART_HandleTypeDef* husart3 = &amp;husart3_;\n\n// USART3 TX queue\nstatic QueueHandle_t usart3_tx_queue = NULL;\nstatic StaticQueue_t usart3_tx_queue_buffer;\nstatic uint8_t usart3_tx_queue_storage[USART3_TX_QUEUE_SIZE * sizeof(tx_payload_t)]; \n\n\n// USART3 RX queue\nstatic QueueHandle_t usart3_rx_queue = NULL;\nstatic StaticQueue_t usart3_rx_queue_buffer;\nstatic uint8_t usart3_rx_queue_storage[USART3_RX_QUEUE_SIZE * sizeof(rx_payload_t)];  // Will be allocated based on queue_size in uart_init\n\n// USART3 RX buffer\n// An intermediate buffer of DATA_SIZE bytes to store received data before it is copied to the queue\nstatic rx_payload_t usart3_rx_buffer;\n\n#endif /* USART3 */\n\nstatic bool is_uart_initialized(UART_HandleTypeDef* handle) {\n    // Check if the UART is in a valid state\n    // HAL_UART_STATE_RESET indicates the UART is not initialized\n    return (handle-&gt;gState != HAL_UART_STATE_RESET);\n}\n\n// Redefine me!\n__weak void HAL_UART_MspGPIOInit(UART_HandleTypeDef *huart){ \n    GPIO_InitTypeDef init = {0};\n    // Same sets of pins for L4/F4\n    #ifdef UART4\n    if(huart-&gt;Instance == UART4) {\n        //enable port A clock\n        __HAL_RCC_GPIOA_CLK_ENABLE();\n\n        /* enable port A UART4 gpio\n        PA0 -&gt; UART4_TX\n        PA1 -&gt; UART4_RX    \n        */\n        init.Pin = GPIO_PIN_0|GPIO_PIN_1;\n        init.Mode = GPIO_MODE_AF_PP;\n        init.Pull = GPIO_NOPULL;\n        init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n        init.Alternate = GPIO_AF8_UART4;\n        HAL_GPIO_Init(GPIOA, &amp;init);\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if (huart-&gt;Instance == UART5) {\n        __HAL_RCC_GPIOC_CLK_ENABLE();\n\n    __HAL_RCC_GPIOD_CLK_ENABLE();\n\n        /* enable UART5 gpio   \n        PC12 -&gt; UART5_TX\n        PD2 -&gt; UART5_RX\n        */\n        init.Pin = GPIO_PIN_12;\n        init.Mode = GPIO_MODE_AF_PP;\n        init.Pull = GPIO_NOPULL;\n        init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n        init.Alternate = GPIO_AF8_UART5;\n        HAL_GPIO_Init(GPIOC, &amp;init);\n\n        init.Pin = GPIO_PIN_2;\n\n    HAL_GPIO_Init(GPIOD, &amp;init);\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(huart-&gt;Instance == USART1) {\n        //enable port A clock\n        __HAL_RCC_GPIOA_CLK_ENABLE();\n\n        /* enable port A USART1 gpio\n        PA9 -&gt; USART1_TX\n        PA10 -&gt; USART1_RX    \n        */\n        init.Pin = GPIO_PIN_9|GPIO_PIN_10;\n        init.Mode = GPIO_MODE_AF_PP;\n        init.Pull = GPIO_NOPULL;\n        init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n        init.Alternate = GPIO_AF7_USART1;\n        HAL_GPIO_Init(GPIOA, &amp;init);\n    }\n    #endif /* USART1 */\n\n    #if defined(USART2) &amp;&amp; defined(GPIOD)\n    if(huart-&gt;Instance == USART2) {\n        //enable port D clock\n        __HAL_RCC_GPIOD_CLK_ENABLE();\n\n        /* enable port D USART2 gpio\n        PD5 -&gt; USART2_TX\n        PD6 -&gt; USART2_RX    \n        */\n        init.Pin = GPIO_PIN_5|GPIO_PIN_6;\n        init.Mode = GPIO_MODE_AF_PP;\n        init.Pull = GPIO_NOPULL;\n        init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n        init.Alternate = GPIO_AF7_USART2;\n        HAL_GPIO_Init(GPIOD, &amp;init);\n    }\n    #endif /* USART2 &amp;&amp; GPIOD*/\n\n    #ifdef USART3\n    if(huart-&gt;Instance == USART3) {\n        //enable port C clock\n        __HAL_RCC_GPIOC_CLK_ENABLE();\n\n        /* enable port C USART3 gpio\n        PC10 -&gt; USART3_TX\n        PC11 -&gt; USART3_RX    \n        */\n        init.Pin = GPIO_PIN_10|GPIO_PIN_11;\n        init.Mode = GPIO_MODE_AF_PP;\n        init.Pull = GPIO_NOPULL;\n        init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n        init.Alternate = GPIO_AF7_USART3;\n        HAL_GPIO_Init(GPIOC, &amp;init);\n    }\n    #endif /* USART3 */    \n}\n\nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart) {\n    IRQn_Type uart_IRQ = NonMaskableInt_IRQn; // IRQn_Type for UART interrupts\n\n    #ifdef UART4\n    if (huart-&gt;Instance == UART4) {\n        __HAL_RCC_UART4_CLK_ENABLE(); // enable UART4 clock\n        uart_IRQ = UART4_IRQn;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if (huart-&gt;Instance == UART5) {\n        __HAL_RCC_UART5_CLK_ENABLE(); // enable UART5 clock\n        uart_IRQ = UART5_IRQn;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if (huart-&gt;Instance == USART1) {\n        __HAL_RCC_USART1_CLK_ENABLE(); // enable USART1 clock\n        uart_IRQ = USART1_IRQn;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if (huart-&gt;Instance == USART2) {\n        __HAL_RCC_USART2_CLK_ENABLE(); // enable USART2 clock\n        uart_IRQ = USART2_IRQn;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if (huart-&gt;Instance == USART3) {\n        __HAL_RCC_USART3_CLK_ENABLE(); // enable USART3 clock\n        uart_IRQ = USART3_IRQn;\n    }\n    #endif /* USART3 */\n\n    // configure GPIO pins for UART\n    HAL_UART_MspGPIOInit(huart); \n\n    // enable uart interrupts\n    HAL_NVIC_SetPriority(uart_IRQ, UART_NVIC_PREEMPT_PRIO, 0);\n    HAL_NVIC_EnableIRQ(uart_IRQ); \n}\n\n// Redefine me!\n__weak void HAL_UART_MspGPIODeInit(UART_HandleTypeDef *huart){ \n}\n\nvoid HAL_UART_MspDeInit(UART_HandleTypeDef *huart) {\n    // UART4\n    #ifdef UART4\n    if (huart-&gt;Instance == UART4) {\n        //disable clocks\n        __HAL_RCC_UART4_CLK_DISABLE();\n\n        // disable interrupts\n        HAL_NVIC_DisableIRQ(UART4_IRQn);\n    }\n    #endif /* UART4 */\n\n    // UART5\n    #ifdef UART5\n    if (huart-&gt;Instance == UART5) {\n        // disable clocks\n        __HAL_RCC_UART5_CLK_DISABLE();\n\n        // disable interrupts\n        HAL_NVIC_DisableIRQ(UART5_IRQn);        //disable interrupts\n    }\n    #endif /* UART5 */\n\n    // USART1\n    #ifdef USART1\n    if (huart-&gt;Instance == USART1) {\n        // disable clocks\n        __HAL_RCC_USART1_CLK_DISABLE();\n\n        // disable interrupts\n        HAL_NVIC_DisableIRQ(USART1_IRQn);        //disable interrupts\n    }\n    #endif /* USART1 */\n\n    // USART2\n    #ifdef USART2\n    if (huart-&gt;Instance == USART2) {\n        // disable clocks\n        __HAL_RCC_USART2_CLK_DISABLE();\n\n        // disable interrupts\n        HAL_NVIC_DisableIRQ(USART2_IRQn);        //disable interrupts\n    }\n    #endif /* USART2 */\n\n    // USART3\n    #ifdef USART3\n    if (huart-&gt;Instance == USART3) {\n        // disable clocks\n        __HAL_RCC_USART3_CLK_DISABLE();\n\n        // disable interrupts\n        HAL_NVIC_DisableIRQ(USART3_IRQn);        //disable interrupts\n    }\n    #endif /* USART3 */\n\n    HAL_UART_MspGPIODeInit(huart);\n}\n\nuart_status_t uart_init(UART_HandleTypeDef* handle) {\n    uint8_t *rx_buffer = NULL;\n\n    #ifdef UART4\n    if (handle-&gt;Instance == UART4) {\n        // Create TX queue\n        uart4_tx_queue = xQueueCreateStatic(UART4_TX_QUEUE_SIZE, \n                                            sizeof(tx_payload_t), \n                                            uart4_tx_queue_storage, \n                                            &amp;uart4_tx_queue_buffer);\n\n\n        // Create RX queue\n        uart4_rx_queue = xQueueCreateStatic(UART4_RX_QUEUE_SIZE,\n                                            sizeof(rx_payload_t),\n                                            uart4_rx_queue_storage,\n                                            &amp;uart4_rx_queue_buffer);\n\n        rx_buffer = uart4_rx_buffer.data;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if(handle-&gt;Instance == UART5) {\n\n        // Allocate static storage for TX queue\n        uart5_tx_queue = xQueueCreateStatic(UART5_TX_QUEUE_SIZE, \n                                          sizeof(tx_payload_t), \n                                          uart5_tx_queue_storage, \n                                          &amp;uart5_tx_queue_buffer);\n\n        // Create RX queue\n        uart5_rx_queue = xQueueCreateStatic(UART5_RX_QUEUE_SIZE,\n                                          sizeof(rx_payload_t),\n                                          uart5_rx_queue_storage,\n                                          &amp;uart5_rx_queue_buffer);\n\n        rx_buffer = uart5_rx_buffer.data;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(handle-&gt;Instance == USART1) {\n\n        // Allocate static storage for TX queue\n        usart1_tx_queue = xQueueCreateStatic(USART1_TX_QUEUE_SIZE, \n                                          sizeof(tx_payload_t), \n                                          usart1_tx_queue_storage, \n                                          &amp;usart1_tx_queue_buffer);\n\n        // Create RX queue\n        usart1_rx_queue = xQueueCreateStatic(USART1_RX_QUEUE_SIZE,\n                                          sizeof(rx_payload_t),\n                                          usart1_rx_queue_storage,\n                                          &amp;usart1_rx_queue_buffer);\n\n        rx_buffer = usart1_rx_buffer.data;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if(handle-&gt;Instance == USART2) {\n\n        // Allocate static storage for TX queue\n        usart2_tx_queue = xQueueCreateStatic(USART2_TX_QUEUE_SIZE, \n                                          sizeof(tx_payload_t), \n                                          usart2_tx_queue_storage, \n                                          &amp;usart2_tx_queue_buffer);\n\n        // Create RX queue\n        usart2_rx_queue = xQueueCreateStatic(USART2_RX_QUEUE_SIZE,\n                                          sizeof(rx_payload_t),\n                                          usart2_rx_queue_storage,\n                                          &amp;usart2_rx_queue_buffer);\n\n        rx_buffer = usart2_rx_buffer.data;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if(handle-&gt;Instance == USART3) {\n\n        // Allocate static storage for TX queue\n        usart3_tx_queue = xQueueCreateStatic(USART3_TX_QUEUE_SIZE, \n                                          sizeof(tx_payload_t), \n                                          usart3_tx_queue_storage, \n                                          &amp;usart3_tx_queue_buffer);\n\n        // Create RX queue\n        usart3_rx_queue = xQueueCreateStatic(USART3_RX_QUEUE_SIZE,\n                                          sizeof(rx_payload_t),\n                                          usart3_rx_queue_storage,\n                                          &amp;usart3_rx_queue_buffer);\n\n        rx_buffer = usart3_rx_buffer.data;\n    }\n    #endif /* USART3 */\n\n    // init HAL\n    if (HAL_UART_Init(handle) != HAL_OK ||\n    !IS_UART_INSTANCE(handle-&gt;Instance) ||\n    !IS_USART_INSTANCE(handle-&gt;Instance)){\n    return UART_ERR;\n    }\n\n    // Start reception\n    if (HAL_UART_Receive_IT(handle, rx_buffer, DATA_SIZE) != HAL_OK) {\n        return UART_ERR;\n    }\n\n    return UART_OK;\n}\n\n\nuart_status_t uart_deinit(UART_HandleTypeDef* handle) {\n    // Stop any ongoing transfers first\n    HAL_UART_Abort(handle);\n\n    // Deinitialize HAL\n    if (HAL_UART_DeInit(handle) != HAL_OK) {\n        return UART_ERR; \n    }\n\n    // Deinitialize Handler\n    #ifdef UART4\n    if (handle-&gt;Instance == UART4) {\n    uart4_tx_queue = NULL;\n    uart4_rx_queue = NULL;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if (handle-&gt;Instance == UART5) {\n    uart5_tx_queue = NULL;\n    uart5_rx_queue = NULL;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if (handle-&gt;Instance == USART1) {\n    usart1_tx_queue = NULL;\n    usart1_rx_queue = NULL;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if (handle-&gt;Instance == USART2) {\n    usart2_tx_queue = NULL;\n    usart2_rx_queue = NULL;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if (handle-&gt;Instance == USART3) {\n    usart3_tx_queue = NULL;\n    usart3_rx_queue = NULL;\n    }\n    #endif /* USART3 */\n\n    return UART_OK;\n}\n\n\n#ifdef UART4\n// static buffer for UART4 TX\nstatic uint8_t uart4_tx_buffer[UART4_TX_QUEUE_SIZE];\n#endif /* UART4 */\n\n#ifdef UART5\n// static buffer for UART5 TX\nstatic uint8_t uart5_tx_buffer[UART5_TX_QUEUE_SIZE]; // make buffer size same as queue size \n#endif /* UART5 */\n\n#ifdef USART1\n// static buffer for USART1 TX\nstatic uint8_t usart1_tx_buffer[USART1_TX_QUEUE_SIZE];\n#endif /* USART1 */\n\n#ifdef USART2\n// static buffer for USART2 TX\nstatic uint8_t usart2_tx_buffer[USART2_TX_QUEUE_SIZE]; // make buffer size same as queue size \n#endif /* USART2 */\n\n#ifdef USART3\n// static buffer for USART3 TX\nstatic uint8_t usart3_tx_buffer[USART3_TX_QUEUE_SIZE]; // make buffer size same as queue size \n#endif /* USART3 */\n\nuart_status_t uart_send(UART_HandleTypeDef* handle, const uint8_t* data, uint8_t length, TickType_t delay_ticks) {\n    if (length == 0 || !is_uart_initialized(handle)) { // check if UART is initialized and data length is not 0\n        return UART_ERR;\n    }\n\n    QueueHandle_t* tx_queue = NULL;\n    uint8_t* tx_buffer = NULL;\n\n    #ifdef UART4\n    if(handle-&gt;Instance == UART4) {\n        tx_buffer = uart4_tx_buffer; // for direct transmission\n        tx_queue = &amp;uart4_tx_queue;  // for queuing\n    }\n    #endif /* UART4*/\n\n    #ifdef UART5\n    if(handle-&gt;Instance == UART5) {\n        tx_buffer = uart5_tx_buffer;\n        tx_queue = &amp;uart5_tx_queue;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(handle-&gt;Instance == USART1) {\n        tx_buffer = usart1_tx_buffer; // for direct transmission\n        tx_queue = &amp;usart1_tx_queue;  // for queuing\n    }\n    #endif /* USART1*/\n\n    #ifdef USART2\n    if(handle-&gt;Instance == USART2) {\n        tx_buffer = usart2_tx_buffer;\n        tx_queue = &amp;usart2_tx_queue;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if(handle-&gt;Instance == USART3) {\n        tx_buffer = usart3_tx_buffer;\n        tx_queue = &amp;usart3_tx_queue;\n    }\n    #endif /* USART3 */\n\n\n    uart_status_t status = UART_SENT;\n\n    // Try direct transmission if possible\n    portENTER_CRITICAL();\n    if ((HAL_UART_GetState(handle) &amp; HAL_UART_STATE_BUSY_TX) != HAL_UART_STATE_BUSY_TX &amp;&amp;\n        tx_queue != NULL &amp;&amp; uxQueueMessagesWaiting (*tx_queue) == 0 ) { // check if UART is ready and queue is empty\n        // Copy data to static buffer\n        memcpy(tx_buffer, data, length);\n        if (HAL_UART_Transmit_IT(handle, tx_buffer, length) != HAL_OK) {\n            status = UART_ERR;\n        }\n        portEXIT_CRITICAL();\n        goto exit;\n    }\n    portEXIT_CRITICAL();\n\n    // Send data in chunks based on DATA_SIZE\n    for (uint8_t i = 0; i &lt; length; i+=DATA_SIZE) {\n    tx_payload_t payload;\n\n    // Ensure we only copy DATA_SIZE bytes at a time\n    uint8_t chunk_size = (length - i &lt; DATA_SIZE) ? (length - i) : DATA_SIZE;\n    // EX: i=4, length=6, DataSize=4, then chunk_size = 2, instead of usual 4 since we've reached end of length\n\n    // Copy the appropriate number of bytes to the payload data\n     memcpy(payload.data, &amp;data[i], chunk_size); // Usually chunk_size = DATA_SIZE until end of data length\n\n     // If data size is smaller than DATA_SIZE, fill the rest of the payload\n     if (chunk_size &lt; DATA_SIZE) {\n         memset(&amp;payload.data[chunk_size], 0, DATA_SIZE - chunk_size); // Fill the rest with 0 (or other padding if needed)\n     }\n\n    // Enqueue the payload to be transmitted\n    if (xQueueSend(*tx_queue, &amp;payload, delay_ticks) != pdTRUE) {\n        return UART_ERR;\n    } //delay_ticks: 0 = no wait, portMAX_DELAY = wait until space is available\n    }\n\nexit:\n    return status;\n}\n\nuart_status_t uart_recv(UART_HandleTypeDef* handle, uint8_t* data, uint8_t length, TickType_t delay_ticks) {\n    if (!data || length == 0 || !is_uart_initialized(handle)) { // check if data is not null, length is not 0 and UART is initialized\n        return UART_ERR;\n    }\n\n    QueueHandle_t rx_queue = NULL;\n    #ifdef UART4\n    if(handle-&gt;Instance == UART4) {\n        rx_queue = uart4_rx_queue;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if(handle-&gt;Instance == UART5) {\n        rx_queue = uart5_rx_queue;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(handle-&gt;Instance == USART1) {\n        rx_queue = usart1_rx_queue;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if(handle-&gt;Instance == USART2) {\n        rx_queue = usart2_rx_queue;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if(handle-&gt;Instance == USART3) {\n        rx_queue = usart3_rx_queue;\n    }\n    #endif /* USART3 */\n\n    uart_status_t status = UART_RECV;\n    rx_payload_t receivedPayload;\n    uint8_t bytes_received = 0;\n\n    // Receive all requested bytes\n    while (bytes_received &lt; length) {\n        if (xQueueReceive(rx_queue, &amp;receivedPayload, delay_ticks) == errQUEUE_EMPTY) {\n            return UART_EMPTY;  // Queue empty, no more data to receive\n        }\n\n        // Calculate how many bytes to copy from the payload based on DATA_SIZE\n        uint8_t copy_length = (length - bytes_received) &gt;= DATA_SIZE ? DATA_SIZE : (length - bytes_received);\n\n        // Copy the data from the payload to the user's data buffer\n        for (uint8_t i = 0; i &lt; copy_length; i++) {\n            data[bytes_received + i] = receivedPayload.data[i];\n        }\n\n        // Update the number of bytes received\n        bytes_received += copy_length;\n    }\n\n    return status;\n}\n\n// Transmit Callback occurs after a transmission if complete (depending on how huart is configure)\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {\n    BaseType_t higherPriorityTaskWoken = pdFALSE;\n    uint8_t tx_buffer[32];  // Buffer for collecting bytes to send\n    uint8_t count = 0;\n\n    QueueHandle_t *tx_queue = NULL;\n\n    #ifdef UART4\n    if(huart-&gt;Instance == UART4) {\n        tx_queue = &amp;uart4_tx_queue;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if(huart-&gt;Instance == UART5) {\n        tx_queue = &amp;uart5_tx_queue;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(huart-&gt;Instance == USART1) {\n        tx_queue = &amp;usart1_tx_queue;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if(huart-&gt;Instance == USART2) {\n        tx_queue = &amp;usart2_tx_queue;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if(huart-&gt;Instance == USART3) {\n        tx_queue = &amp;usart3_tx_queue;\n    }\n    #endif /* USART3 */\n\n    // Pull as many bytes as we can fit in the buffer\n    tx_payload_t payload;\n    while(count + DATA_SIZE &lt;= sizeof(tx_buffer) &amp;&amp; xQueueReceiveFromISR(*tx_queue, &amp;payload, &amp;higherPriorityTaskWoken) == pdTRUE) {\n        // Safely copy the data from the payload into the tx_buffer\n        memcpy(&amp;tx_buffer[count], payload.data, DATA_SIZE);\n        count += DATA_SIZE;\n    }\n\n    if(tx_queue == NULL) {\n        return; // No valid uart tx queue found\n    }\n\n    // Get as many bytes as we can from queue (up to buffer size)\n    while(count &lt; sizeof(tx_buffer) &amp;&amp; \n        xQueueReceiveFromISR(*tx_queue, &amp;tx_buffer[count], &amp;higherPriorityTaskWoken) == pdTRUE) {\n        count++;\n    }\n\n    //  If we got any bytes, transmit them\n    if(count &gt; 0) {\n      HAL_UART_Transmit_IT(huart, tx_buffer, count);\n    }\n\n    // Yield to a higher priority task if needed\n    portYIELD_FROM_ISR(higherPriorityTaskWoken);\n}\n\n// Receive Callback occurs after a receive is complete\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {\n    QueueHandle_t *rx_queue = NULL;\n    uint8_t *rx_buffer = NULL;\n\n    #ifdef UART4\n    if(huart-&gt;Instance == UART4) {\n        rx_queue = &amp;uart4_rx_queue;\n        rx_buffer = uart4_rx_buffer.data;\n    }\n    #endif /* UART4 */\n\n    #ifdef UART5\n    if(huart-&gt;Instance == UART5) {\n        rx_queue = &amp;uart5_rx_queue;\n        rx_buffer = uart5_rx_buffer.data;\n    }\n    #endif /* UART5 */\n\n    #ifdef USART1\n    if(huart-&gt;Instance == USART1) {\n        rx_queue = &amp;usart1_rx_queue;\n        rx_buffer = usart1_rx_buffer.data;\n    }\n    #endif /* USART1 */\n\n    #ifdef USART2\n    if(huart-&gt;Instance == USART2) {\n        rx_queue = &amp;usart2_rx_queue;\n        rx_buffer = usart2_rx_buffer.data;\n    }\n    #endif /* USART2 */\n\n    #ifdef USART3\n    if(huart-&gt;Instance == USART3) {\n        rx_queue = &amp;usart3_rx_queue;\n        rx_buffer = usart3_rx_buffer.data;\n    }\n    #endif /* USART3 */\n\n    rx_payload_t receivedData;\n    for (int i = 0; i &lt; DATA_SIZE; i++) {\n        receivedData.data[i] = rx_buffer[i]; //uartN_rx_buffer.data\n    rx_buffer[i] = 0x00; // clear rx buffer element\n    }\n\n    BaseType_t higherPriorityTaskWoken = pdFALSE;\n\n    xQueueSendFromISR(*rx_queue, &amp;receivedData, &amp;higherPriorityTaskWoken); // Send data from &amp;receivedData(pRxBuffPtr) to rx_queue\n\n    // Trigger the next interrupt\n    HAL_UART_Receive_IT(huart, rx_buffer, DATA_SIZE);// pRxBufferPtr is a pointer to the buffer that will store the received data\n\n    portYIELD_FROM_ISR(higherPriorityTaskWoken);\n}\n\n#ifdef UART4\nvoid UART4_IRQHandler(void) {\n    HAL_UART_IRQHandler(huart4);\n}\n#endif /* UART4 */\n\n#ifdef UART5\nvoid UART5_IRQHandler(void) {\n    HAL_UART_IRQHandler(huart5);\n}\n#endif /* UART5 */\n\n#ifdef USART1\nvoid USART1_IRQHandler(void) {\n    HAL_UART_IRQHandler(husart1);\n}\n#endif /* USART1 */\n\n#ifdef USART2\nvoid USART2_IRQHandler(void) {\n    HAL_UART_IRQHandler(husart2);\n}\n#endif /* USART2 */\n\n#ifdef USART3\nvoid USART3_IRQHandler(void) {\n    HAL_UART_IRQHandler(husart3);\n}\n#endif /* USART3 */\n</code></pre>"},{"location":"BSP/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"BSP/classes/","title":"Class Index","text":""},{"location":"BSP/classes/#r","title":"r","text":"<ul> <li>recv_entry_t</li> <li>rx_payload_t</li> </ul>"},{"location":"BSP/classes/#t","title":"t","text":"<ul> <li>tx_payload_t</li> </ul>"},{"location":"BSP/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>struct recv_entry_t </li> <li>struct rx_payload_t </li> <li>struct tx_payload_t </li> </ul>"},{"location":"BSP/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"BSP/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"BSP/class_members/","title":"Class Members","text":""},{"location":"BSP/class_members/#b","title":"b","text":"<ul> <li>buffer (recv_entry_t)</li> </ul>"},{"location":"BSP/class_members/#c","title":"c","text":"<ul> <li>circular (recv_entry_t)</li> </ul>"},{"location":"BSP/class_members/#d","title":"d","text":"<ul> <li>data (rx_payload_t, tx_payload_t)</li> </ul>"},{"location":"BSP/class_members/#h","title":"h","text":"<ul> <li>header (rx_payload_t, tx_payload_t)</li> </ul>"},{"location":"BSP/class_members/#i","title":"i","text":"<ul> <li>id (recv_entry_t)</li> </ul>"},{"location":"BSP/class_members/#q","title":"q","text":"<ul> <li>queue (recv_entry_t)</li> </ul>"},{"location":"BSP/class_members/#s","title":"s","text":"<ul> <li>size (recv_entry_t)</li> <li>storage (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"BSP/class_member_variables/","title":"Class Member Variables","text":""},{"location":"BSP/class_member_variables/#b","title":"b","text":"<ul> <li>buffer (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_variables/#c","title":"c","text":"<ul> <li>circular (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_variables/#d","title":"d","text":"<ul> <li>data (rx_payload_t, tx_payload_t)</li> </ul>"},{"location":"BSP/class_member_variables/#h","title":"h","text":"<ul> <li>header (rx_payload_t, tx_payload_t)</li> </ul>"},{"location":"BSP/class_member_variables/#i","title":"i","text":"<ul> <li>id (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_variables/#q","title":"q","text":"<ul> <li>queue (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_variables/#s","title":"s","text":"<ul> <li>size (recv_entry_t)</li> <li>storage (recv_entry_t)</li> </ul>"},{"location":"BSP/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"BSP/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"BSP/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"BSP/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"BSP/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"BSP/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"BSP/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"BSP/functions/","title":"Functions","text":""},{"location":"BSP/functions/#a","title":"a","text":"<ul> <li>adc_deinit (ADC.c)</li> <li>adc_init (ADC.c)</li> <li>adc_read (ADC.c)</li> </ul>"},{"location":"BSP/functions/#c","title":"c","text":"<ul> <li>can_deinit (CAN.c)</li> <li>can_init (CAN.c)</li> <li>can_recv (CAN.c)</li> <li>can_send (CAN.c)</li> <li>can_start (CAN.c)</li> <li>can_stop (CAN.c)</li> </ul>"},{"location":"BSP/functions/#h","title":"h","text":"<ul> <li>HAL_ADC_ConvCpltCallback (ADC.c)</li> <li>HAL_ADC_ErrorCallback (ADC.c)</li> <li>HAL_ADC_MspDeInit (ADC.c)</li> <li>HAL_ADC_MspGPIOInit (ADC.c)</li> <li>HAL_ADC_MspInit (ADC.c)</li> <li>HAL_CAN_MspDeInit (CAN.c)</li> <li>HAL_CAN_MspF4Init (CAN.c)</li> <li>HAL_CAN_MspInit (CAN.c)</li> <li>HAL_CAN_MspL4Init (CAN.c)</li> <li>HAL_CAN_RxFifo0MsgPendingCallback (CAN.c)</li> <li>HAL_CAN_TxMailbox0CompleteCallback (CAN.c)</li> <li>HAL_CAN_TxMailbox1CompleteCallback (CAN.c)</li> <li>HAL_CAN_TxMailbox2CompleteCallback (CAN.c)</li> <li>HAL_UART_MspDeInit (UART.c)</li> <li>HAL_UART_MspGPIODeInit (UART.c)</li> <li>HAL_UART_MspGPIOInit (UART.c)</li> <li>HAL_UART_MspInit (UART.c)</li> <li>HAL_UART_RxCpltCallback (UART.c)</li> <li>HAL_UART_TxCpltCallback (UART.c)</li> </ul>"},{"location":"BSP/functions/#i","title":"i","text":"<ul> <li>is_uart_initialized (UART.c)</li> </ul>"},{"location":"BSP/functions/#t","title":"t","text":"<ul> <li>transmit (CAN.c)</li> </ul>"},{"location":"BSP/functions/#u","title":"u","text":"<ul> <li>uart_deinit (UART.c)</li> <li>uart_init (UART.c)</li> <li>uart_recv (UART.c)</li> <li>uart_send (UART.c)</li> </ul>"},{"location":"BSP/macros/","title":"Macros","text":""},{"location":"BSP/macros/#d","title":"d","text":"<ul> <li>DATA_SIZE (CAN.c, UART.c)</li> </ul>"},{"location":"BSP/macros/#u","title":"u","text":"<ul> <li>UART_NVIC_PREEMPT_PRIO (UART.c)</li> </ul>"},{"location":"BSP/variables/","title":"Variables","text":""},{"location":"BSP/variables/#a","title":"a","text":"<ul> <li>adc_err_code (ADC.c)</li> </ul>"},{"location":"BSP/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}